{"id":"node_modules/pipez/build/pipez.es5.js","dependencies":[{"name":"/Users/teresapayne/Projects/FM/Beginning-Web-Dev/popdemo/package.json","includedInParent":true,"mtime":1601829711906},{"name":"/Users/teresapayne/Projects/FM/Beginning-Web-Dev/popdemo/node_modules/pipez/package.json","includedInParent":true,"mtime":1601829706105},{"name":"/Users/teresapayne/Projects/FM/Beginning-Web-Dev/popdemo/node_modules/pipez/.babelrc","includedInParent":true,"mtime":1531778766000}],"generated":{"js":"\"use strict\";\n\n/*  ------------------------------------------------------------------------ */\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nfunction _objectEntries(obj) {\n    var entries = [];\n    var keys = Object.keys(obj);\n\n    for (var k = 0; k < keys.length; ++k) entries.push([keys[k], obj[keys[k]]]);\n\n    return entries;\n}\n\nvar merge = function merge(to, from) {\n\n    for (var prop in from) {\n        Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));\n    }\n\n    return to;\n};\n\n/*  ------------------------------------------------------------------------ */\n\nvar pipez = module.exports = function (functions_, prev) {\n\n    var functions = {}; // bound to self\n\n    var functionNames = Reflect.ownKeys(functions_); // guaranteed to be in property creation order (as defined by the standard)\n    var self = Object.assign(\n\n    /*  Function of functions (call chain)  */\n\n    function () {\n        for (var _len = arguments.length, initial = Array(_len), _key = 0; _key < _len; _key++) {\n            initial[_key] = arguments[_key];\n        }\n\n        return functionNames.reduce(function (memo, k) {\n            return functions[k].call(self, memo, { initialArguments: initial });\n        }, initial);\n    }, // @hide\n\n    /*  Additional methods     */\n\n    {\n        configure: function configure() {\n            var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\n            var modifiedFunctions = {};\n\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                var _loop = function _loop() {\n                    var k = _step.value;\n\n\n                    var override = overrides[k],\n                        before = overrides['+' + k] || function (x) {\n                        return x;\n                    },\n                        after = overrides[k + '+'] || function (x) {\n                        return x;\n                    };\n\n                    var boundArgs = typeof override === 'boolean' ? { yes: override } : override || {};\n\n                    modifiedFunctions[k] = function (x, args) {\n\n                        var fn = typeof override === 'function' ? override : functions[k]; // dont cache so people can dynamically change .impl ()\n\n                        var newArgs = Object.assign({}, boundArgs, args),\n                            maybeFn = newArgs.yes === false ? function (x) {\n                            return x;\n                        } : fn;\n\n                        return after.call(this, maybeFn.call(this, before.call(this, x, newArgs), newArgs), newArgs);\n                    };\n                };\n\n                for (var _iterator = functionNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    _loop();\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n\n            return pipez(modifiedFunctions, self).methods(this.methods_);\n        },\n        from: function from(name) {\n\n            var subset = null;\n\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n                for (var _iterator2 = functionNames[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var _k = _step2.value;\n\n                    if (_k === name) {\n                        subset = { takeFirstArgument: function takeFirstArgument(args) {\n                                return args[0];\n                            } };\n                    }\n                    if (subset) {\n                        subset[_k] = functions[_k];\n                    }\n                }\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally {\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n\n            return pipez(subset, self);\n        },\n        before: function before(name) {\n\n            var subset = {};\n\n            var _iteratorNormalCompletion3 = true;\n            var _didIteratorError3 = false;\n            var _iteratorError3 = undefined;\n\n            try {\n                for (var _iterator3 = functionNames[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                    var _k2 = _step3.value;\n\n                    if (_k2 === name) {\n                        break;\n                    }\n                    subset[_k2] = functions[_k2];\n                }\n            } catch (err) {\n                _didIteratorError3 = true;\n                _iteratorError3 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                        _iterator3.return();\n                    }\n                } finally {\n                    if (_didIteratorError3) {\n                        throw _iteratorError3;\n                    }\n                }\n            }\n\n            return pipez(subset, self);\n        },\n\n\n        methods_: {},\n\n        methods: function methods(_methods) {\n            return merge(this, merge(this.methods_, _methods));\n        },\n\n\n        get impl() {\n            return functions;\n        },\n        get prev() {\n            return prev;\n        }\n    });\n\n    var _iteratorNormalCompletion4 = true;\n    var _didIteratorError4 = false;\n    var _iteratorError4 = undefined;\n\n    try {\n        for (var _iterator4 = _objectEntries(functions_)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var _step4$value = _slicedToArray(_step4.value, 2),\n                _k3 = _step4$value[0],\n                f = _step4$value[1];\n\n            functions[_k3] = f.bind(self);\n        }\n    } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                _iterator4.return();\n            }\n        } finally {\n            if (_didIteratorError4) {\n                throw _iteratorError4;\n            }\n        }\n    }\n\n    return self;\n};\n\n/*  ------------------------------------------------------------------------ */\n\n"},"sourceMaps":{"js":{"version":3,"sources":["../pipez.js"],"names":[],"mappings":"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","file":"pipez.es5.js","sourcesContent":["\"use strict\";\n\n/*  ------------------------------------------------------------------------ */\n\nconst merge = (to, from) => {\n\n    for (const prop in from) { Object.defineProperty (to, prop, Object.getOwnPropertyDescriptor (from, prop)) }\n\n    return to\n}\n\n/*  ------------------------------------------------------------------------ */\n\nconst pipez = module.exports = (functions_, prev) => {\n\n    let functions = {} // bound to self\n\n    const functionNames = Reflect.ownKeys (functions_) // guaranteed to be in property creation order (as defined by the standard)\n    const self = Object.assign (\n\n    /*  Function of functions (call chain)  */\n\n        (...initial) => functionNames.reduce ((memo, k) => functions[k].call (self, memo, { initialArguments: initial }), initial), // @hide\n\n    /*  Additional methods     */\n\n        {\n            configure (overrides = {}) {\n\n                const modifiedFunctions = {}\n\n                for (const k of functionNames) {\n\n                    const override = overrides[k],\n                          before   = overrides['+' + k] || (x => x),\n                          after    = overrides[k + '+'] || (x => x)\n\n                    const boundArgs = (typeof override === 'boolean') ? { yes: override } : (override || {})\n\n                    modifiedFunctions[k] = function (x, args) {\n\n                        const fn = (typeof override === 'function') ? override : functions[k] // dont cache so people can dynamically change .impl ()\n\n                        const newArgs = Object.assign ({}, boundArgs, args),\n                              maybeFn = (newArgs.yes === false) ? (x => x) : fn\n\n                        return after.call (this,\n                                    maybeFn.call (this,\n                                        before.call (this, x, newArgs), newArgs), newArgs)\n                    }\n                }\n\n                return pipez (modifiedFunctions, self).methods (this.methods_)\n            },\n\n            from (name) {\n\n                let subset = null\n\n                for (const k of functionNames) {\n                    if (k === name) { subset = { takeFirstArgument: args => args[0] } }\n                    if (subset) { subset[k] = functions[k] }\n                }\n\n                return pipez (subset, self)\n            },\n\n            before (name) {\n\n                let subset = {}\n\n                for (const k of functionNames) {\n                    if (k === name) { break }\n                    subset[k] = functions[k]\n                }\n\n                return pipez (subset, self)\n            },\n\n            methods_: {},\n\n            methods (methods) { return merge (this, merge (this.methods_, methods)) },\n\n            get impl () { return functions },\n            get prev () { return prev }\n        }\n    )\n\n    for (let [k, f] of Object.entries (functions_)) { functions[k] = f.bind (self) }\n\n    return self\n}\n\n/*  ------------------------------------------------------------------------ */\n"]}},"error":null,"hash":"cd61ecdda4901d613bb786ca99ac8b73","cacheData":{"env":{}}}