// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"node_modules/tslib/tslib.es6.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.__extends = __extends;
exports.__rest = __rest;
exports.__decorate = __decorate;
exports.__param = __param;
exports.__metadata = __metadata;
exports.__awaiter = __awaiter;
exports.__generator = __generator;
exports.__createBinding = __createBinding;
exports.__exportStar = __exportStar;
exports.__values = __values;
exports.__read = __read;
exports.__spread = __spread;
exports.__spreadArrays = __spreadArrays;
exports.__await = __await;
exports.__asyncGenerator = __asyncGenerator;
exports.__asyncDelegator = __asyncDelegator;
exports.__asyncValues = __asyncValues;
exports.__makeTemplateObject = __makeTemplateObject;
exports.__importStar = __importStar;
exports.__importDefault = __importDefault;
exports.__classPrivateFieldGet = __classPrivateFieldGet;
exports.__classPrivateFieldSet = __classPrivateFieldSet;
exports.__assign = void 0;

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function () {
  exports.__assign = __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

exports.__assign = __assign;

function __rest(s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}

function __decorate(decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
}

function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

function __generator(thisArg, body) {
  var _ = {
    label: 0,
    sent: function () {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];

      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;

        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };

        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;

        case 7:
          op = _.ops.pop();

          _.trys.pop();

          continue;

        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }

          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }

          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }

          if (t && _.label < t[2]) {
            _.label = t[2];

            _.ops.push(op);

            break;
          }

          if (t[2]) _.ops.pop();

          _.trys.pop();

          continue;
      }

      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}

function __createBinding(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
}

function __exportStar(m, exports) {
  for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
      m = s && o[s],
      i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function () {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
      r,
      ar = [],
      e;

  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }

  return ar;
}

function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));

  return ar;
}

function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
}

;

function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []),
      i,
      q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i;

  function verb(n) {
    if (g[n]) i[n] = function (v) {
      return new Promise(function (a, b) {
        q.push([n, v, a, b]) > 1 || resume(n, v);
      });
    };
  }

  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }

  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }

  function fulfill(value) {
    resume("next", value);
  }

  function reject(value) {
    resume("throw", value);
  }

  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}

function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function () {
    return this;
  }, i;

  function verb(n, f) {
    i[n] = o[n] ? function (v) {
      return (p = !p) ? {
        value: __await(o[n](v)),
        done: n === "return"
      } : f ? f(v) : v;
    } : f;
  }
}

function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator],
      i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i);

  function verb(n) {
    i[n] = o[n] && function (v) {
      return new Promise(function (resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }

  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function (v) {
      resolve({
        value: v,
        done: d
      });
    }, reject);
  }
}

function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", {
      value: raw
    });
  } else {
    cooked.raw = raw;
  }

  return cooked;
}

;

function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  result.default = mod;
  return result;
}

function __importDefault(mod) {
  return mod && mod.__esModule ? mod : {
    default: mod
  };
}

function __classPrivateFieldGet(receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }

  return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }

  privateMap.set(receiver, value);
  return value;
}
},{}],"node_modules/hey-listen/dist/hey-listen.es.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.warning = exports.invariant = void 0;

var warning = function () {};

exports.warning = warning;

var invariant = function () {};

exports.invariant = invariant;

if ("development" !== 'production') {
  exports.warning = warning = function (check, message) {
    if (!check && typeof console !== 'undefined') {
      console.warn(message);
    }
  };

  exports.invariant = invariant = function (check, message) {
    if (!check) {
      throw new Error(message);
    }
  };
}
},{}],"node_modules/style-value-types/dist/style-value-types.es.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.vw = exports.vh = exports.scale = exports.rgba = exports.rgbUnit = exports.px = exports.progressPercentage = exports.percent = exports.number = exports.hsla = exports.hex = exports.degrees = exports.complex = exports.color = exports.alpha = void 0;

var _tslib = require("tslib");

var clamp = function (min, max) {
  return function (v) {
    return Math.max(Math.min(v, max), min);
  };
};

var sanitize = function (v) {
  return v % 1 ? Number(v.toFixed(5)) : v;
};

var floatRegex = /(-)?(\d[\d\.]*)/g;
var colorRegex = /(#[0-9a-f]{6}|#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))/gi;
var singleColorRegex = /^(#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))$/i;
var number = {
  test: function (v) {
    return typeof v === 'number';
  },
  parse: parseFloat,
  transform: function (v) {
    return v;
  }
};
exports.number = number;
var alpha = (0, _tslib.__assign)((0, _tslib.__assign)({}, number), {
  transform: clamp(0, 1)
});
exports.alpha = alpha;
var scale = (0, _tslib.__assign)((0, _tslib.__assign)({}, number), {
  default: 1
});
exports.scale = scale;

var createUnitType = function (unit) {
  return {
    test: function (v) {
      return typeof v === 'string' && v.endsWith(unit) && v.split(' ').length === 1;
    },
    parse: parseFloat,
    transform: function (v) {
      return "" + v + unit;
    }
  };
};

var degrees = createUnitType('deg');
exports.degrees = degrees;
var percent = createUnitType('%');
exports.percent = percent;
var px = createUnitType('px');
exports.px = px;
var vh = createUnitType('vh');
exports.vh = vh;
var vw = createUnitType('vw');
exports.vw = vw;
var progressPercentage = (0, _tslib.__assign)((0, _tslib.__assign)({}, percent), {
  parse: function (v) {
    return percent.parse(v) / 100;
  },
  transform: function (v) {
    return percent.transform(v * 100);
  }
});
exports.progressPercentage = progressPercentage;

var getValueFromFunctionString = function (value) {
  return value.substring(value.indexOf('(') + 1, value.lastIndexOf(')'));
};

var clampRgbUnit = clamp(0, 255);

var isRgba = function (v) {
  return v.red !== undefined;
};

var isHsla = function (v) {
  return v.hue !== undefined;
};

function getValuesAsArray(value) {
  return getValueFromFunctionString(value).replace(/(,|\/)/g, ' ').split(/ \s*/);
}

var splitColorValues = function (terms) {
  return function (v) {
    if (typeof v !== 'string') return v;
    var values = {};
    var valuesArray = getValuesAsArray(v);

    for (var i = 0; i < 4; i++) {
      values[terms[i]] = valuesArray[i] !== undefined ? parseFloat(valuesArray[i]) : 1;
    }

    return values;
  };
};

var rgbaTemplate = function (_a) {
  var red = _a.red,
      green = _a.green,
      blue = _a.blue,
      _b = _a.alpha,
      alpha = _b === void 0 ? 1 : _b;
  return "rgba(" + red + ", " + green + ", " + blue + ", " + alpha + ")";
};

var hslaTemplate = function (_a) {
  var hue = _a.hue,
      saturation = _a.saturation,
      lightness = _a.lightness,
      _b = _a.alpha,
      alpha = _b === void 0 ? 1 : _b;
  return "hsla(" + hue + ", " + saturation + ", " + lightness + ", " + alpha + ")";
};

var rgbUnit = (0, _tslib.__assign)((0, _tslib.__assign)({}, number), {
  transform: function (v) {
    return Math.round(clampRgbUnit(v));
  }
});
exports.rgbUnit = rgbUnit;

function isColorString(color, colorType) {
  return color.startsWith(colorType) && singleColorRegex.test(color);
}

var rgba = {
  test: function (v) {
    return typeof v === 'string' ? isColorString(v, 'rgb') : isRgba(v);
  },
  parse: splitColorValues(['red', 'green', 'blue', 'alpha']),
  transform: function (_a) {
    var red = _a.red,
        green = _a.green,
        blue = _a.blue,
        _b = _a.alpha,
        alpha$1 = _b === void 0 ? 1 : _b;
    return rgbaTemplate({
      red: rgbUnit.transform(red),
      green: rgbUnit.transform(green),
      blue: rgbUnit.transform(blue),
      alpha: sanitize(alpha.transform(alpha$1))
    });
  }
};
exports.rgba = rgba;
var hsla = {
  test: function (v) {
    return typeof v === 'string' ? isColorString(v, 'hsl') : isHsla(v);
  },
  parse: splitColorValues(['hue', 'saturation', 'lightness', 'alpha']),
  transform: function (_a) {
    var hue = _a.hue,
        saturation = _a.saturation,
        lightness = _a.lightness,
        _b = _a.alpha,
        alpha$1 = _b === void 0 ? 1 : _b;
    return hslaTemplate({
      hue: Math.round(hue),
      saturation: percent.transform(sanitize(saturation)),
      lightness: percent.transform(sanitize(lightness)),
      alpha: sanitize(alpha.transform(alpha$1))
    });
  }
};
exports.hsla = hsla;
var hex = (0, _tslib.__assign)((0, _tslib.__assign)({}, rgba), {
  test: function (v) {
    return typeof v === 'string' && isColorString(v, '#');
  },
  parse: function (v) {
    var r = '';
    var g = '';
    var b = '';

    if (v.length > 4) {
      r = v.substr(1, 2);
      g = v.substr(3, 2);
      b = v.substr(5, 2);
    } else {
      r = v.substr(1, 1);
      g = v.substr(2, 1);
      b = v.substr(3, 1);
      r += r;
      g += g;
      b += b;
    }

    return {
      red: parseInt(r, 16),
      green: parseInt(g, 16),
      blue: parseInt(b, 16),
      alpha: 1
    };
  }
});
exports.hex = hex;
var color = {
  test: function (v) {
    return typeof v === 'string' && singleColorRegex.test(v) || isRgba(v) || isHsla(v);
  },
  parse: function (v) {
    if (rgba.test(v)) {
      return rgba.parse(v);
    } else if (hsla.test(v)) {
      return hsla.parse(v);
    } else if (hex.test(v)) {
      return hex.parse(v);
    }

    return v;
  },
  transform: function (v) {
    if (isRgba(v)) {
      return rgba.transform(v);
    } else if (isHsla(v)) {
      return hsla.transform(v);
    }

    return v;
  }
};
exports.color = color;
var COLOR_TOKEN = '${c}';
var NUMBER_TOKEN = '${n}';

var convertNumbersToZero = function (v) {
  return typeof v === 'number' ? 0 : v;
};

var complex = {
  test: function (v) {
    if (typeof v !== 'string' || !isNaN(v)) return false;
    var numValues = 0;
    var foundNumbers = v.match(floatRegex);
    var foundColors = v.match(colorRegex);
    if (foundNumbers) numValues += foundNumbers.length;
    if (foundColors) numValues += foundColors.length;
    return numValues > 0;
  },
  parse: function (v) {
    var input = v;
    var parsed = [];
    var foundColors = input.match(colorRegex);

    if (foundColors) {
      input = input.replace(colorRegex, COLOR_TOKEN);
      parsed.push.apply(parsed, foundColors.map(color.parse));
    }

    var foundNumbers = input.match(floatRegex);

    if (foundNumbers) {
      parsed.push.apply(parsed, foundNumbers.map(number.parse));
    }

    return parsed;
  },
  createTransformer: function (prop) {
    var template = prop;
    var token = 0;
    var foundColors = prop.match(colorRegex);
    var numColors = foundColors ? foundColors.length : 0;

    if (foundColors) {
      for (var i = 0; i < numColors; i++) {
        template = template.replace(foundColors[i], COLOR_TOKEN);
        token++;
      }
    }

    var foundNumbers = template.match(floatRegex);
    var numNumbers = foundNumbers ? foundNumbers.length : 0;

    if (foundNumbers) {
      for (var i = 0; i < numNumbers; i++) {
        template = template.replace(foundNumbers[i], NUMBER_TOKEN);
        token++;
      }
    }

    return function (v) {
      var output = template;

      for (var i = 0; i < token; i++) {
        output = output.replace(i < numColors ? COLOR_TOKEN : NUMBER_TOKEN, i < numColors ? color.transform(v[i]) : sanitize(v[i]));
      }

      return output;
    };
  },
  getAnimatableNone: function (target) {
    var parsedTarget = complex.parse(target);
    var targetTransformer = complex.createTransformer(target);
    return targetTransformer(parsedTarget.map(convertNumbersToZero));
  }
};
exports.complex = complex;
},{"tslib":"node_modules/tslib/tslib.es6.js"}],"../../../../.nvm/versions/node/v12.18.3/lib/node_modules/parcel-bundler/node_modules/process/browser.js":[function(require,module,exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};
},{}],"node_modules/framesync/dist/framesync.es.js":[function(require,module,exports) {
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFrameData = exports.cancelSync = exports.default = void 0;

var _heyListen = require("hey-listen");

var prevTime = 0;
var onNextFrame = typeof window !== 'undefined' && window.requestAnimationFrame !== undefined ? function (callback) {
  return window.requestAnimationFrame(callback);
} : function (callback) {
  var timestamp = Date.now();
  var timeToCall = Math.max(0, 16.7 - (timestamp - prevTime));
  prevTime = timestamp + timeToCall;
  setTimeout(function () {
    return callback(prevTime);
  }, timeToCall);
};

var createStep = function (setRunNextFrame) {
  var processToRun = [];
  var processToRunNextFrame = [];
  var numThisFrame = 0;
  var isProcessing = false;
  var i = 0;
  var cancelled = new WeakSet();
  var toKeepAlive = new WeakSet();
  var renderStep = {
    cancel: function (process) {
      var indexOfCallback = processToRunNextFrame.indexOf(process);
      cancelled.add(process);

      if (indexOfCallback !== -1) {
        processToRunNextFrame.splice(indexOfCallback, 1);
      }
    },
    process: function (frame) {
      var _a;

      isProcessing = true;
      _a = [processToRunNextFrame, processToRun], processToRun = _a[0], processToRunNextFrame = _a[1];
      processToRunNextFrame.length = 0;
      numThisFrame = processToRun.length;

      if (numThisFrame) {
        var process_1;

        for (i = 0; i < numThisFrame; i++) {
          process_1 = processToRun[i];
          process_1(frame);

          if (toKeepAlive.has(process_1) === true && !cancelled.has(process_1)) {
            renderStep.schedule(process_1);
            setRunNextFrame(true);
          }
        }
      }

      isProcessing = false;
    },
    schedule: function (process, keepAlive, immediate) {
      if (keepAlive === void 0) {
        keepAlive = false;
      }

      if (immediate === void 0) {
        immediate = false;
      }

      (0, _heyListen.invariant)(typeof process === "function", "Argument must be a function");
      var addToCurrentBuffer = immediate && isProcessing;
      var buffer = addToCurrentBuffer ? processToRun : processToRunNextFrame;
      cancelled.delete(process);
      if (keepAlive) toKeepAlive.add(process);

      if (buffer.indexOf(process) === -1) {
        buffer.push(process);
        if (addToCurrentBuffer) numThisFrame = processToRun.length;
      }
    }
  };
  return renderStep;
};

var maxElapsed = 40;
var defaultElapsed = 1 / 60 * 1000;
var useDefaultElapsed = true;
var willRunNextFrame = false;
var isProcessing = false;
var frame = {
  delta: 0,
  timestamp: 0
};
var stepsOrder = ["read", "update", "preRender", "render", "postRender"];

var setWillRunNextFrame = function (willRun) {
  return willRunNextFrame = willRun;
};

var steps = /*#__PURE__*/stepsOrder.reduce(function (acc, key) {
  acc[key] = createStep(setWillRunNextFrame);
  return acc;
}, {});
var sync = /*#__PURE__*/stepsOrder.reduce(function (acc, key) {
  var step = steps[key];

  acc[key] = function (process, keepAlive, immediate) {
    if (keepAlive === void 0) {
      keepAlive = false;
    }

    if (immediate === void 0) {
      immediate = false;
    }

    if (!willRunNextFrame) startLoop();
    step.schedule(process, keepAlive, immediate);
    return process;
  };

  return acc;
}, {});
var cancelSync = /*#__PURE__*/stepsOrder.reduce(function (acc, key) {
  acc[key] = steps[key].cancel;
  return acc;
}, {});
exports.cancelSync = cancelSync;

var processStep = function (stepId) {
  return steps[stepId].process(frame);
};

var processFrame = function (timestamp) {
  willRunNextFrame = false;
  frame.delta = useDefaultElapsed ? defaultElapsed : Math.max(Math.min(timestamp - frame.timestamp, maxElapsed), 1);
  if (!useDefaultElapsed) defaultElapsed = frame.delta;
  frame.timestamp = timestamp;
  isProcessing = true;
  stepsOrder.forEach(processStep);
  isProcessing = false;

  if (willRunNextFrame) {
    useDefaultElapsed = false;
    onNextFrame(processFrame);
  }
};

var startLoop = function () {
  willRunNextFrame = true;
  useDefaultElapsed = true;
  if (!isProcessing) onNextFrame(processFrame);
};

var getFrameData = function () {
  return frame;
};

exports.getFrameData = getFrameData;
var _default = sync;
exports.default = _default;
},{"hey-listen":"node_modules/hey-listen/dist/hey-listen.es.js","process":"../../../../.nvm/versions/node/v12.18.3/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"node_modules/popmotion/dist/popmotion.es.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.animate = animate;
exports.cubicBezier = cubicBezier;
exports.decay = decay;
exports.distance = distance;
exports.inertia = inertia;
exports.interpolate = interpolate;
exports.keyframes = keyframes;
exports.spring = spring;
exports.velocityPerFrame = velocityPerFrame;
exports.velocityPerSecond = velocityPerSecond;
exports.wrap = exports.toDecimal = exports.steps = exports.snap = exports.smoothFrame = exports.smooth = exports.reverseEasing = exports.radiansToDegrees = exports.progress = exports.pointFromVector = exports.pipe = exports.mixComplex = exports.mixColor = exports.mix = exports.mirrorEasing = exports.linear = exports.isPoint3D = exports.isPoint = exports.easeOut = exports.easeInOut = exports.easeIn = exports.degreesToRadians = exports.createExpoIn = exports.createBackIn = exports.createAttractor = exports.createAnticipate = exports.clamp = exports.circOut = exports.circInOut = exports.circIn = exports.bounceOut = exports.bounceInOut = exports.bounceIn = exports.backOut = exports.backInOut = exports.backIn = exports.attractExpo = exports.attract = exports.applyOffset = exports.anticipate = exports.angle = void 0;

var _tslib = require("tslib");

var _heyListen = require("hey-listen");

var _styleValueTypes = require("style-value-types");

var _framesync = _interopRequireWildcard(require("framesync"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var clamp = function (min, max, v) {
  return Math.min(Math.max(v, min), max);
};

exports.clamp = clamp;
var safeMin = 0.001;
var minDuration = 0.01;
var maxDuration = 10.0;
var minDamping = 0.05;
var maxDamping = 1;

function findSpring(_a) {
  var _b = _a.duration,
      duration = _b === void 0 ? 800 : _b,
      _c = _a.bounce,
      bounce = _c === void 0 ? 0.25 : _c,
      _d = _a.velocity,
      velocity = _d === void 0 ? 0 : _d,
      _e = _a.mass,
      mass = _e === void 0 ? 1 : _e;
  var envelope;
  var derivative;
  (0, _heyListen.warning)(duration <= maxDuration * 1000, "Spring duration must be 10 seconds or less");
  var dampingRatio = 1 - bounce;
  dampingRatio = clamp(minDamping, maxDamping, dampingRatio);
  duration = clamp(minDuration, maxDuration, duration / 1000);

  if (dampingRatio < 1) {
    envelope = function (undampedFreq) {
      var exponentialDecay = undampedFreq * dampingRatio;
      var delta = exponentialDecay * duration;
      var a = exponentialDecay - velocity;
      var b = calcAngularFreq(undampedFreq, dampingRatio);
      var c = Math.exp(-delta);
      return safeMin - a / b * c;
    };

    derivative = function (undampedFreq) {
      var exponentialDecay = undampedFreq * dampingRatio;
      var delta = exponentialDecay * duration;
      var d = delta * velocity + velocity;
      var e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration;
      var f = Math.exp(-delta);
      var g = calcAngularFreq(Math.pow(undampedFreq, 2), dampingRatio);
      var factor = -envelope(undampedFreq) + safeMin > 0 ? -1 : 1;
      return factor * ((d - e) * f) / g;
    };
  } else {
    envelope = function (undampedFreq) {
      var a = Math.exp(-undampedFreq * duration);
      var b = (undampedFreq - velocity) * duration + 1;
      return -safeMin + a * b;
    };

    derivative = function (undampedFreq) {
      var a = Math.exp(-undampedFreq * duration);
      var b = (velocity - undampedFreq) * (duration * duration);
      return a * b;
    };
  }

  var initialGuess = 5 / duration;
  var undampedFreq = approximateRoot(envelope, derivative, initialGuess);

  if (isNaN(undampedFreq)) {
    return {
      stiffness: 100,
      damping: 10
    };
  } else {
    var stiffness = Math.pow(undampedFreq, 2) * mass;
    return {
      stiffness: stiffness,
      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness)
    };
  }
}

var rootIterations = 12;

function approximateRoot(envelope, derivative, initialGuess) {
  var result = initialGuess;

  for (var i = 1; i < rootIterations; i++) {
    result = result - envelope(result) / derivative(result);
  }

  return result;
}

function calcAngularFreq(undampedFreq, dampingRatio) {
  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
}

var durationKeys = ["duration", "bounce"];
var physicsKeys = ["stiffness", "damping", "mass"];

function isSpringType(options, keys) {
  return keys.some(function (key) {
    return options[key] !== undefined;
  });
}

function getSpringOptions(options) {
  var springOptions = (0, _tslib.__assign)({
    velocity: 0.0,
    stiffness: 100,
    damping: 10,
    mass: 1.0,
    isResolvedFromDuration: false
  }, options);

  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
    var derived = findSpring(options);
    springOptions = (0, _tslib.__assign)((0, _tslib.__assign)((0, _tslib.__assign)({}, springOptions), derived), {
      velocity: 0.0,
      mass: 1.0
    });
    springOptions.isResolvedFromDuration = true;
  }

  return springOptions;
}

function spring(_a) {
  var _b = _a.from,
      from = _b === void 0 ? 0.0 : _b,
      _c = _a.to,
      to = _c === void 0 ? 1.0 : _c,
      _d = _a.restSpeed,
      restSpeed = _d === void 0 ? 2 : _d,
      restDelta = _a.restDelta,
      options = (0, _tslib.__rest)(_a, ["from", "to", "restSpeed", "restDelta"]);
  var state = {
    done: false,
    value: from
  };

  var _e = getSpringOptions(options),
      stiffness = _e.stiffness,
      damping = _e.damping,
      mass = _e.mass,
      velocity = _e.velocity,
      isResolvedFromDuration = _e.isResolvedFromDuration;

  var resolveSpring = zero;
  var resolveVelocity = zero;

  function createSpring() {
    var initialVelocity = velocity ? -(velocity / 1000) : 0.0;
    var initialDelta = to - from;
    var dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
    var undampedAngularFreq = Math.sqrt(stiffness / mass) / 1000;
    restDelta !== null && restDelta !== void 0 ? restDelta : restDelta = Math.abs(to - from) <= 1 ? 0.01 : 0.4;

    if (dampingRatio < 1) {
      var angularFreq_1 = calcAngularFreq(undampedAngularFreq, dampingRatio);

      resolveSpring = function (t) {
        var envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
        return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq_1 * Math.sin(angularFreq_1 * t) + initialDelta * Math.cos(angularFreq_1 * t));
      };

      resolveVelocity = function (t) {
        var envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
        return dampingRatio * undampedAngularFreq * envelope * (Math.sin(angularFreq_1 * t) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq_1 + initialDelta * Math.cos(angularFreq_1 * t)) - envelope * (Math.cos(angularFreq_1 * t) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) - angularFreq_1 * initialDelta * Math.sin(angularFreq_1 * t));
      };
    } else if (dampingRatio === 1) {
      resolveSpring = function (t) {
        return to - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);
      };
    } else {
      var dampedAngularFreq_1 = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);

      resolveSpring = function (t) {
        var envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
        var freqForT = Math.min(dampedAngularFreq_1 * t, 300);
        return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq_1 * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq_1;
      };
    }
  }

  createSpring();
  return {
    next: function (t) {
      var current = resolveSpring(t);

      if (!isResolvedFromDuration) {
        var currentVelocity = resolveVelocity(t) * 1000;
        var isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
        var isBelowDisplacementThreshold = Math.abs(to - current) <= restDelta;
        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
      } else {
        state.done = t >= options.duration;
      }

      state.value = state.done ? to : current;
      return state;
    },
    flipTarget: function () {
      var _a;

      velocity = -velocity;
      _a = [to, from], from = _a[0], to = _a[1];
      createSpring();
    }
  };
}

spring.needsInterpolation = function (a, b) {
  return typeof a === "string" || typeof b === "string";
};

var zero = function (_t) {
  return 0;
};

var progress = function (from, to, value) {
  var toFromDifference = to - from;
  return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
};

exports.progress = progress;

var mix = function (from, to, progress) {
  return -progress * from + progress * to + from;
};

exports.mix = mix;

var mixLinearColor = function (from, to, v) {
  var fromExpo = from * from;
  var toExpo = to * to;
  return Math.sqrt(Math.max(0, v * (toExpo - fromExpo) + fromExpo));
};

var colorTypes = [_styleValueTypes.hex, _styleValueTypes.rgba, _styleValueTypes.hsla];

var getColorType = function (v) {
  return colorTypes.find(function (type) {
    return type.test(v);
  });
};

var notAnimatable = function (color) {
  return "'" + color + "' is not an animatable color. Use the equivalent color code instead.";
};

var mixColor = function (from, to) {
  var fromColorType = getColorType(from);
  var toColorType = getColorType(to);
  (0, _heyListen.invariant)(!!fromColorType, notAnimatable(from));
  (0, _heyListen.invariant)(!!toColorType, notAnimatable(to));
  (0, _heyListen.invariant)(fromColorType.transform === toColorType.transform, 'Both colors must be hex/RGBA, OR both must be HSLA.');
  var fromColor = fromColorType.parse(from);
  var toColor = toColorType.parse(to);
  var blended = (0, _tslib.__assign)({}, fromColor);
  var mixFunc = fromColorType === _styleValueTypes.hsla ? mix : mixLinearColor;
  return function (v) {
    for (var key in blended) {
      if (key !== 'alpha') {
        blended[key] = mixFunc(fromColor[key], toColor[key], v);
      }
    }

    blended.alpha = mix(fromColor.alpha, toColor.alpha, v);
    return fromColorType.transform(blended);
  };
};

exports.mixColor = mixColor;
var zeroPoint = {
  x: 0,
  y: 0,
  z: 0
};

var isNum = function (v) {
  return typeof v === 'number';
};

var combineFunctions = function (a, b) {
  return function (v) {
    return b(a(v));
  };
};

var pipe = function () {
  var transformers = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    transformers[_i] = arguments[_i];
  }

  return transformers.reduce(combineFunctions);
};

exports.pipe = pipe;

function getMixer(origin, target) {
  if (isNum(origin)) {
    return function (v) {
      return mix(origin, target, v);
    };
  } else if (_styleValueTypes.color.test(origin)) {
    return mixColor(origin, target);
  } else {
    return mixComplex(origin, target);
  }
}

var mixArray = function (from, to) {
  var output = (0, _tslib.__spreadArrays)(from);
  var numValues = output.length;
  var blendValue = from.map(function (fromThis, i) {
    return getMixer(fromThis, to[i]);
  });
  return function (v) {
    for (var i = 0; i < numValues; i++) {
      output[i] = blendValue[i](v);
    }

    return output;
  };
};

var mixObject = function (origin, target) {
  var output = (0, _tslib.__assign)((0, _tslib.__assign)({}, origin), target);
  var blendValue = {};

  for (var key in output) {
    if (origin[key] !== undefined && target[key] !== undefined) {
      blendValue[key] = getMixer(origin[key], target[key]);
    }
  }

  return function (v) {
    for (var key in blendValue) {
      output[key] = blendValue[key](v);
    }

    return output;
  };
};

function analyse(value) {
  var parsed = _styleValueTypes.complex.parse(value);

  var numValues = parsed.length;
  var numNumbers = 0;
  var numRGB = 0;
  var numHSL = 0;

  for (var i = 0; i < numValues; i++) {
    if (numNumbers || typeof parsed[i] === 'number') {
      numNumbers++;
    } else {
      if (parsed[i].hue !== undefined) {
        numHSL++;
      } else {
        numRGB++;
      }
    }
  }

  return {
    parsed: parsed,
    numNumbers: numNumbers,
    numRGB: numRGB,
    numHSL: numHSL
  };
}

var mixComplex = function (origin, target) {
  var template = _styleValueTypes.complex.createTransformer(target);

  var originStats = analyse(origin);
  var targetStats = analyse(target);
  (0, _heyListen.invariant)(originStats.numHSL === targetStats.numHSL && originStats.numRGB === targetStats.numRGB && originStats.numNumbers >= targetStats.numNumbers, "Complex values '" + origin + "' and '" + target + "' too different to mix. Ensure all colors are of the same type.");
  return pipe(mixArray(originStats.parsed, targetStats.parsed), template);
};

exports.mixComplex = mixComplex;

var mixNumber = function (from, to) {
  return function (p) {
    return mix(from, to, p);
  };
};

function detectMixerFactory(v) {
  if (typeof v === 'number') {
    return mixNumber;
  } else if (typeof v === 'string') {
    if (_styleValueTypes.color.test(v)) {
      return mixColor;
    } else {
      return mixComplex;
    }
  } else if (Array.isArray(v)) {
    return mixArray;
  } else if (typeof v === 'object') {
    return mixObject;
  }
}

function createMixers(output, ease, customMixer) {
  var mixers = [];
  var mixerFactory = customMixer || detectMixerFactory(output[0]);
  var numMixers = output.length - 1;

  for (var i = 0; i < numMixers; i++) {
    var mixer = mixerFactory(output[i], output[i + 1]);

    if (ease) {
      var easingFunction = Array.isArray(ease) ? ease[i] : ease;
      mixer = pipe(easingFunction, mixer);
    }

    mixers.push(mixer);
  }

  return mixers;
}

function fastInterpolate(_a, _b) {
  var from = _a[0],
      to = _a[1];
  var mixer = _b[0];
  return function (v) {
    return mixer(progress(from, to, v));
  };
}

function slowInterpolate(input, mixers) {
  var inputLength = input.length;
  var lastInputIndex = inputLength - 1;
  return function (v) {
    var mixerIndex = 0;
    var foundMixerIndex = false;

    if (v <= input[0]) {
      foundMixerIndex = true;
    } else if (v >= input[lastInputIndex]) {
      mixerIndex = lastInputIndex - 1;
      foundMixerIndex = true;
    }

    if (!foundMixerIndex) {
      var i = 1;

      for (; i < inputLength; i++) {
        if (input[i] > v || i === lastInputIndex) {
          break;
        }
      }

      mixerIndex = i - 1;
    }

    var progressInRange = progress(input[mixerIndex], input[mixerIndex + 1], v);
    return mixers[mixerIndex](progressInRange);
  };
}

function interpolate(input, output, _a) {
  var _b = _a === void 0 ? {} : _a,
      _c = _b.clamp,
      isClamp = _c === void 0 ? true : _c,
      ease = _b.ease,
      mixer = _b.mixer;

  var inputLength = input.length;
  (0, _heyListen.invariant)(inputLength === output.length, 'Both input and output ranges must be the same length');
  (0, _heyListen.invariant)(!ease || !Array.isArray(ease) || ease.length === inputLength - 1, 'Array of easing functions must be of length `input.length - 1`, as it applies to the transitions **between** the defined values.');

  if (input[0] > input[inputLength - 1]) {
    input = [].concat(input);
    output = [].concat(output);
    input.reverse();
    output.reverse();
  }

  var mixers = createMixers(output, ease, mixer);
  var interpolator = inputLength === 2 ? fastInterpolate(input, mixers) : slowInterpolate(input, mixers);
  return isClamp ? function (v) {
    return interpolator(clamp(input[0], input[inputLength - 1], v));
  } : interpolator;
}

var reverseEasing = function (easing) {
  return function (p) {
    return 1 - easing(1 - p);
  };
};

exports.reverseEasing = reverseEasing;

var mirrorEasing = function (easing) {
  return function (p) {
    return p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;
  };
};

exports.mirrorEasing = mirrorEasing;

var createExpoIn = function (power) {
  return function (p) {
    return Math.pow(p, power);
  };
};

exports.createExpoIn = createExpoIn;

var createBackIn = function (power) {
  return function (p) {
    return p * p * ((power + 1) * p - power);
  };
};

exports.createBackIn = createBackIn;

var createAnticipate = function (power) {
  var backEasing = createBackIn(power);
  return function (p) {
    return (p *= 2) < 1 ? 0.5 * backEasing(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));
  };
};

exports.createAnticipate = createAnticipate;
var DEFAULT_OVERSHOOT_STRENGTH = 1.525;
var BOUNCE_FIRST_THRESHOLD = 4.0 / 11.0;
var BOUNCE_SECOND_THRESHOLD = 8.0 / 11.0;
var BOUNCE_THIRD_THRESHOLD = 9.0 / 10.0;

var linear = function (p) {
  return p;
};

exports.linear = linear;
var easeIn = /*#__PURE__*/createExpoIn(2);
exports.easeIn = easeIn;
var easeOut = /*#__PURE__*/reverseEasing(easeIn);
exports.easeOut = easeOut;
var easeInOut = /*#__PURE__*/mirrorEasing(easeIn);
exports.easeInOut = easeInOut;

var circIn = function (p) {
  return 1 - Math.sin(Math.acos(p));
};

exports.circIn = circIn;
var circOut = /*#__PURE__*/reverseEasing(circIn);
exports.circOut = circOut;
var circInOut = /*#__PURE__*/mirrorEasing(circOut);
exports.circInOut = circInOut;
var backIn = /*#__PURE__*/createBackIn(DEFAULT_OVERSHOOT_STRENGTH);
exports.backIn = backIn;
var backOut = /*#__PURE__*/reverseEasing(backIn);
exports.backOut = backOut;
var backInOut = /*#__PURE__*/mirrorEasing(backIn);
exports.backInOut = backInOut;
var anticipate = /*#__PURE__*/createAnticipate(DEFAULT_OVERSHOOT_STRENGTH);
exports.anticipate = anticipate;
var ca = 4356.0 / 361.0;
var cb = 35442.0 / 1805.0;
var cc = 16061.0 / 1805.0;

var bounceOut = function (p) {
  if (p === 1 || p === 0) return p;
  var p2 = p * p;
  return p < BOUNCE_FIRST_THRESHOLD ? 7.5625 * p2 : p < BOUNCE_SECOND_THRESHOLD ? 9.075 * p2 - 9.9 * p + 3.4 : p < BOUNCE_THIRD_THRESHOLD ? ca * p2 - cb * p + cc : 10.8 * p * p - 20.52 * p + 10.72;
};

exports.bounceOut = bounceOut;
var bounceIn = /*#__PURE__*/reverseEasing(bounceOut);
exports.bounceIn = bounceIn;

var bounceInOut = function (p) {
  return p < 0.5 ? 0.5 * (1.0 - bounceOut(1.0 - p * 2.0)) : 0.5 * bounceOut(p * 2.0 - 1.0) + 0.5;
};

exports.bounceInOut = bounceInOut;

function defaultEasing(values, easing) {
  return values.map(function () {
    return easing || easeInOut;
  }).splice(0, values.length - 1);
}

function defaultOffset(values) {
  var numValues = values.length;
  return values.map(function (_value, i) {
    return i !== 0 ? i / (numValues - 1) : 0;
  });
}

function convertOffsetToTimes(offset, duration) {
  return offset.map(function (o) {
    return o * duration;
  });
}

function keyframes(_a) {
  var _b = _a.from,
      from = _b === void 0 ? 0 : _b,
      _c = _a.to,
      to = _c === void 0 ? 1 : _c,
      ease = _a.ease,
      offset = _a.offset,
      _d = _a.duration,
      duration = _d === void 0 ? 300 : _d;
  var state = {
    done: false,
    value: from
  };
  var values = Array.isArray(to) ? to : [from, to];
  var times = convertOffsetToTimes(offset !== null && offset !== void 0 ? offset : defaultOffset(values), duration);

  function createInterpolator() {
    return interpolate(times, values, {
      ease: Array.isArray(ease) ? ease : defaultEasing(values, ease)
    });
  }

  var interpolator = createInterpolator();
  return {
    next: function (t) {
      state.value = interpolator(t);
      state.done = t >= duration;
      return state;
    },
    flipTarget: function () {
      values.reverse();
      interpolator = createInterpolator();
    }
  };
}

function decay(_a) {
  var _b = _a.velocity,
      velocity = _b === void 0 ? 0 : _b,
      _c = _a.from,
      from = _c === void 0 ? 0 : _c,
      _d = _a.power,
      power = _d === void 0 ? 0.8 : _d,
      _e = _a.timeConstant,
      timeConstant = _e === void 0 ? 350 : _e,
      _f = _a.restDelta,
      restDelta = _f === void 0 ? 0.5 : _f,
      modifyTarget = _a.modifyTarget;
  var state = {
    done: false,
    value: from
  };
  var amplitude = power * velocity;
  var ideal = from + amplitude;
  var target = modifyTarget === undefined ? ideal : modifyTarget(ideal);
  if (target !== ideal) amplitude = target - from;
  return {
    next: function (t) {
      var delta = -amplitude * Math.exp(-t / timeConstant);
      state.done = !(delta > restDelta || delta < -restDelta);
      state.value = state.done ? target : target + delta;
      return state;
    },
    flipTarget: function () {}
  };
}

var types = {
  keyframes: keyframes,
  spring: spring,
  decay: decay
};

function detectAnimationFromOptions(config) {
  if (Array.isArray(config.to)) {
    return keyframes;
  } else if (types[config.type]) {
    return types[config.type];
  }

  var keys = new Set(Object.keys(config));

  if (keys.has("ease") || keys.has("duration") && !keys.has("dampingRatio")) {
    return keyframes;
  } else if (keys.has("dampingRatio") || keys.has("stiffness") || keys.has("mass") || keys.has("damping") || keys.has("restSpeed") || keys.has("restDelta")) {
    return spring;
  }

  return keyframes;
}

function loopElapsed(elapsed, duration, delay) {
  if (delay === void 0) {
    delay = 0;
  }

  return elapsed - duration - delay;
}

function reverseElapsed(elapsed, duration, delay, isForwardPlayback) {
  if (delay === void 0) {
    delay = 0;
  }

  if (isForwardPlayback === void 0) {
    isForwardPlayback = true;
  }

  return isForwardPlayback ? loopElapsed(duration + -elapsed, duration, delay) : duration - (elapsed - duration) + delay;
}

function hasRepeatDelayElapsed(elapsed, duration, delay, isForwardPlayback) {
  return isForwardPlayback ? elapsed >= duration + delay : elapsed <= -delay;
}

var framesync = function (update) {
  var passTimestamp = function (_a) {
    var delta = _a.delta;
    return update(delta);
  };

  return {
    start: function () {
      return _framesync.default.update(passTimestamp, true, true);
    },
    stop: function () {
      return _framesync.cancelSync.update(passTimestamp);
    }
  };
};

function animate(_a) {
  var _b, _c;

  var from = _a.from,
      _d = _a.autoplay,
      autoplay = _d === void 0 ? true : _d,
      _e = _a.driver,
      driver = _e === void 0 ? framesync : _e,
      _f = _a.elapsed,
      elapsed = _f === void 0 ? 0 : _f,
      _g = _a.repeat,
      repeatMax = _g === void 0 ? 0 : _g,
      _h = _a.repeatType,
      repeatType = _h === void 0 ? "loop" : _h,
      _j = _a.repeatDelay,
      repeatDelay = _j === void 0 ? 0 : _j,
      onPlay = _a.onPlay,
      onStop = _a.onStop,
      onComplete = _a.onComplete,
      onRepeat = _a.onRepeat,
      onUpdate = _a.onUpdate,
      options = (0, _tslib.__rest)(_a, ["from", "autoplay", "driver", "elapsed", "repeat", "repeatType", "repeatDelay", "onPlay", "onStop", "onComplete", "onRepeat", "onUpdate"]);
  var to = options.to;
  var driverControls;
  var repeatCount = 0;
  var computedDuration = options.duration;
  var latest;
  var isComplete = false;
  var isForwardPlayback = true;
  var interpolateFromNumber;
  var animator = detectAnimationFromOptions(options);

  if ((_c = (_b = animator).needsInterpolation) === null || _c === void 0 ? void 0 : _c.call(_b, from, to)) {
    interpolateFromNumber = interpolate([0, 100], [from, to], {
      clamp: false
    });
    from = 0;
    to = 100;
  }

  var animation = animator((0, _tslib.__assign)((0, _tslib.__assign)({}, options), {
    from: from,
    to: to
  }));

  function repeat() {
    repeatCount++;

    if (repeatType === "reverse") {
      isForwardPlayback = repeatCount % 2 === 0;
      elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);
    } else {
      elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);
      if (repeatType === "mirror") animation.flipTarget();
    }

    isComplete = false;
    onRepeat && onRepeat();
  }

  function complete() {
    driverControls.stop();
    onComplete && onComplete();
  }

  function update(delta) {
    if (!isForwardPlayback) delta = -delta;
    elapsed += delta;

    if (!isComplete) {
      var state = animation.next(Math.max(0, elapsed));
      latest = state.value;
      if (interpolateFromNumber) latest = interpolateFromNumber(latest);
      isComplete = isForwardPlayback ? state.done : elapsed <= 0;
    }

    onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(latest);

    if (isComplete) {
      if (repeatCount === 0) computedDuration !== null && computedDuration !== void 0 ? computedDuration : computedDuration = elapsed;

      if (repeatCount < repeatMax) {
        hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();
      } else {
        complete();
      }
    }
  }

  function play() {
    onPlay === null || onPlay === void 0 ? void 0 : onPlay();
    driverControls = driver(update);
    driverControls.start();
  }

  autoplay && play();
  return {
    stop: function () {
      onStop === null || onStop === void 0 ? void 0 : onStop();
      driverControls.stop();
    }
  };
}

function velocityPerSecond(velocity, frameDuration) {
  return frameDuration ? velocity * (1000 / frameDuration) : 0;
}

function inertia(_a) {
  var _b = _a.from,
      from = _b === void 0 ? 0 : _b,
      _c = _a.velocity,
      velocity = _c === void 0 ? 0 : _c,
      min = _a.min,
      max = _a.max,
      _d = _a.power,
      power = _d === void 0 ? 0.8 : _d,
      _e = _a.timeConstant,
      timeConstant = _e === void 0 ? 750 : _e,
      _f = _a.bounceStiffness,
      bounceStiffness = _f === void 0 ? 500 : _f,
      _g = _a.bounceDamping,
      bounceDamping = _g === void 0 ? 10 : _g,
      _h = _a.restDelta,
      restDelta = _h === void 0 ? 1 : _h,
      modifyTarget = _a.modifyTarget,
      driver = _a.driver,
      onUpdate = _a.onUpdate,
      onComplete = _a.onComplete;
  var currentAnimation;

  function isOutOfBounds(v) {
    return min !== undefined && v < min || max !== undefined && v > max;
  }

  function boundaryNearest(v) {
    if (min === undefined) return max;
    if (max === undefined) return min;
    return Math.abs(min - v) < Math.abs(max - v) ? min : max;
  }

  function startAnimation(options) {
    currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop();
    currentAnimation = animate((0, _tslib.__assign)((0, _tslib.__assign)({}, options), {
      driver: driver,
      onUpdate: function (v) {
        var _a;

        onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(v);
        (_a = options.onUpdate) === null || _a === void 0 ? void 0 : _a.call(options, v);
      },
      onComplete: onComplete
    }));
  }

  function startSpring(options) {
    startAnimation((0, _tslib.__assign)({
      type: "spring",
      stiffness: bounceStiffness,
      damping: bounceDamping,
      restDelta: restDelta
    }, options));
  }

  if (isOutOfBounds(from)) {
    startSpring({
      from: from,
      velocity: velocity,
      to: boundaryNearest(from)
    });
  } else {
    var target = power * velocity + from;
    if (typeof modifyTarget !== "undefined") target = modifyTarget(target);
    var boundary_1 = boundaryNearest(target);
    var heading_1 = boundary_1 === min ? -1 : 1;
    var prev_1;
    var current_1;

    var checkBoundary = function (v) {
      prev_1 = current_1;
      current_1 = v;
      velocity = velocityPerSecond(v - prev_1, (0, _framesync.getFrameData)().delta);

      if (heading_1 === 1 && v > boundary_1 || heading_1 === -1 && v < boundary_1) {
        startSpring({
          from: v,
          to: boundary_1,
          velocity: velocity
        });
      }
    };

    startAnimation({
      type: "decay",
      from: from,
      velocity: velocity,
      timeConstant: timeConstant,
      power: power,
      restDelta: restDelta,
      modifyTarget: modifyTarget,
      onUpdate: isOutOfBounds(target) ? checkBoundary : undefined
    });
  }

  return {
    stop: function () {
      return currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop();
    }
  };
}

var radiansToDegrees = function (radians) {
  return radians * 180 / Math.PI;
};

exports.radiansToDegrees = radiansToDegrees;

var angle = function (a, b) {
  if (b === void 0) {
    b = zeroPoint;
  }

  return radiansToDegrees(Math.atan2(b.y - a.y, b.x - a.x));
};

exports.angle = angle;

var applyOffset = function (from, to) {
  var hasReceivedFrom = true;

  if (to === undefined) {
    to = from;
    hasReceivedFrom = false;
  }

  return function (v) {
    if (hasReceivedFrom) {
      return v - from + to;
    } else {
      from = v;
      hasReceivedFrom = true;
      return to;
    }
  };
};

exports.applyOffset = applyOffset;

var identity = function (v) {
  return v;
};

var createAttractor = function (alterDisplacement) {
  if (alterDisplacement === void 0) {
    alterDisplacement = identity;
  }

  return function (constant, origin, v) {
    var displacement = origin - v;
    var springModifiedDisplacement = -(0 - constant + 1) * (0 - alterDisplacement(Math.abs(displacement)));
    return displacement <= 0 ? origin + springModifiedDisplacement : origin - springModifiedDisplacement;
  };
};

exports.createAttractor = createAttractor;
var attract = /*#__PURE__*/createAttractor();
exports.attract = attract;
var attractExpo = /*#__PURE__*/createAttractor(Math.sqrt);
exports.attractExpo = attractExpo;

var degreesToRadians = function (degrees) {
  return degrees * Math.PI / 180;
};

exports.degreesToRadians = degreesToRadians;

var isPoint = function (point) {
  return point.hasOwnProperty('x') && point.hasOwnProperty('y');
};

exports.isPoint = isPoint;

var isPoint3D = function (point) {
  return isPoint(point) && point.hasOwnProperty('z');
};

exports.isPoint3D = isPoint3D;

var distance1D = function (a, b) {
  return Math.abs(a - b);
};

function distance(a, b) {
  if (isNum(a) && isNum(b)) {
    return distance1D(a, b);
  } else if (isPoint(a) && isPoint(b)) {
    var xDelta = distance1D(a.x, b.x);
    var yDelta = distance1D(a.y, b.y);
    var zDelta = isPoint3D(a) && isPoint3D(b) ? distance1D(a.z, b.z) : 0;
    return Math.sqrt(Math.pow(xDelta, 2) + Math.pow(yDelta, 2) + Math.pow(zDelta, 2));
  }
}

var pointFromVector = function (origin, angle, distance) {
  angle = degreesToRadians(angle);
  return {
    x: distance * Math.cos(angle) + origin.x,
    y: distance * Math.sin(angle) + origin.y
  };
};

exports.pointFromVector = pointFromVector;

var toDecimal = function (num, precision) {
  if (precision === void 0) {
    precision = 2;
  }

  precision = Math.pow(10, precision);
  return Math.round(num * precision) / precision;
};

exports.toDecimal = toDecimal;

var smoothFrame = function (prevValue, nextValue, duration, smoothing) {
  if (smoothing === void 0) {
    smoothing = 0;
  }

  return toDecimal(prevValue + duration * (nextValue - prevValue) / Math.max(smoothing, duration));
};

exports.smoothFrame = smoothFrame;

var smooth = function (strength) {
  if (strength === void 0) {
    strength = 50;
  }

  var previousValue = 0;
  var lastUpdated = 0;
  return function (v) {
    var currentFramestamp = (0, _framesync.getFrameData)().timestamp;
    var timeDelta = currentFramestamp !== lastUpdated ? currentFramestamp - lastUpdated : 0;
    var newValue = timeDelta ? smoothFrame(previousValue, v, timeDelta, strength) : previousValue;
    lastUpdated = currentFramestamp;
    previousValue = newValue;
    return newValue;
  };
};

exports.smooth = smooth;

var snap = function (points) {
  if (typeof points === 'number') {
    return function (v) {
      return Math.round(v / points) * points;
    };
  } else {
    var i_1 = 0;
    var numPoints_1 = points.length;
    return function (v) {
      var lastDistance = Math.abs(points[0] - v);

      for (i_1 = 1; i_1 < numPoints_1; i_1++) {
        var point = points[i_1];
        var distance = Math.abs(point - v);
        if (distance === 0) return point;
        if (distance > lastDistance) return points[i_1 - 1];
        if (i_1 === numPoints_1 - 1) return point;
        lastDistance = distance;
      }
    };
  }
};

exports.snap = snap;

function velocityPerFrame(xps, frameDuration) {
  return xps / (1000 / frameDuration);
}

var wrap = function (min, max, v) {
  var rangeSize = max - min;
  return ((v - min) % rangeSize + rangeSize) % rangeSize + min;
};

exports.wrap = wrap;

var a = function (a1, a2) {
  return 1.0 - 3.0 * a2 + 3.0 * a1;
};

var b = function (a1, a2) {
  return 3.0 * a2 - 6.0 * a1;
};

var c = function (a1) {
  return 3.0 * a1;
};

var calcBezier = function (t, a1, a2) {
  return ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;
};

var getSlope = function (t, a1, a2) {
  return 3.0 * a(a1, a2) * t * t + 2.0 * b(a1, a2) * t + c(a1);
};

var subdivisionPrecision = 0.0000001;
var subdivisionMaxIterations = 10;

function binarySubdivide(aX, aA, aB, mX1, mX2) {
  var currentX;
  var currentT;
  var i = 0;

  do {
    currentT = aA + (aB - aA) / 2.0;
    currentX = calcBezier(currentT, mX1, mX2) - aX;

    if (currentX > 0.0) {
      aB = currentT;
    } else {
      aA = currentT;
    }
  } while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations);

  return currentT;
}

var newtonIterations = 8;
var newtonMinSlope = 0.001;

function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
  for (var i = 0; i < newtonIterations; ++i) {
    var currentSlope = getSlope(aGuessT, mX1, mX2);

    if (currentSlope === 0.0) {
      return aGuessT;
    }

    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
    aGuessT -= currentX / currentSlope;
  }

  return aGuessT;
}

var kSplineTableSize = 11;
var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

function cubicBezier(mX1, mY1, mX2, mY2) {
  if (mX1 === mY1 && mX2 === mY2) return linear;
  var sampleValues = new Float32Array(kSplineTableSize);

  for (var i = 0; i < kSplineTableSize; ++i) {
    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
  }

  function getTForX(aX) {
    var intervalStart = 0.0;
    var currentSample = 1;
    var lastSample = kSplineTableSize - 1;

    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
      intervalStart += kSampleStepSize;
    }

    --currentSample;
    var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
    var guessForT = intervalStart + dist * kSampleStepSize;
    var initialSlope = getSlope(guessForT, mX1, mX2);

    if (initialSlope >= newtonMinSlope) {
      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
    } else if (initialSlope === 0.0) {
      return guessForT;
    } else {
      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
    }
  }

  return function (t) {
    return t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);
  };
}

var steps = function (steps, direction) {
  if (direction === void 0) {
    direction = 'end';
  }

  return function (progress) {
    progress = direction === 'end' ? Math.min(progress, 0.999) : Math.max(progress, 0.001);
    var expanded = progress * steps;
    var rounded = direction === 'end' ? Math.floor(expanded) : Math.ceil(expanded);
    return clamp(0, 1, rounded / steps);
  };
};

exports.steps = steps;
},{"tslib":"node_modules/tslib/tslib.es6.js","hey-listen":"node_modules/hey-listen/dist/hey-listen.es.js","style-value-types":"node_modules/style-value-types/dist/style-value-types.es.js","framesync":"node_modules/framesync/dist/framesync.es.js"}],"../../../../.nvm/versions/node/v12.18.3/lib/node_modules/parcel-bundler/node_modules/path-browserify/index.js":[function(require,module,exports) {
var process = require("process");
// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

},{"process":"../../../../.nvm/versions/node/v12.18.3/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"node_modules/underscore/underscore.js":[function(require,module,exports) {
var define;
//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.3';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result  either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = property('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createPredicateIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions
  function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
            i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  }

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = property;

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

},{}],"../../../../.nvm/versions/node/v12.18.3/lib/node_modules/parcel-bundler/src/builtins/_empty.js":[function(require,module,exports) {

},{}],"node_modules/useless/server/base/module-locator.js":[function(require,module,exports) {
var process = require("process");
"use strict";

var _ = require('underscore');
/*  ------------------------------------------------------------------------ */


var fs = require('fs'),
    path = require('path');
/*  ------------------------------------------------------------------------ */


var locator = module.exports = {
  hasBabelrc: function (x) {
    var moduleDir = locator.locateFromFile(x);
    var hasBabelrc = locator.isFile(module && path.join(moduleDir, '.babelrc'));
    return hasBabelrc;
  },
  modulePath: function (name, searchFrom) {
    var basePath = locator.locate(name, searchFrom);
    return basePath && path.join(basePath, 'node_modules', name);
  },
  cache: {},
  locateFromFile: function (file) {
    var dir = path.dirname(file);
    return this.cache[dir] || (this.cache[dir] = _.find(locator.parentDirsOf(file), function (dir) {
      return locator.isFile(path.join(dir, 'package.json'));
    }));
  },

  /*  Locates NPM module path     */
  locate: function (name, where) {
    return _.find(locator.parentDirsOf(where || process.cwd()), function (dir) {
      return locator.isDirectory(path.join(dir, 'node_modules', name));
    });
  },

  /*  Returns full paths to all parent directories, including itself     */
  parentDirsOf: _.memoize(function (fileOrDirectory) {
    var dirs = [path.dirname(fileOrDirectory)];

    while (true) {
      var current = dirs[dirs.length - 1];
      var parent = path.resolve(path.join(current, '..'));

      if (parent === current) {
        return dirs;
      } else {
        dirs.push(parent);
      }
    }
  }),

  /*  Helper predicates   */
  isDirectory: function (x) {
    try {
      return fs.lstatSync(x).isDirectory();
    } catch (e) {
      return false;
    }
  },
  isFile: function (x) {
    try {
      return fs.lstatSync(x).isFile();
    } catch (e) {
      return false;
    }
  }
};
/*  ------------------------------------------------------------------------ */
},{"underscore":"node_modules/underscore/underscore.js","fs":"../../../../.nvm/versions/node/v12.18.3/lib/node_modules/parcel-bundler/src/builtins/_empty.js","path":"../../../../.nvm/versions/node/v12.18.3/lib/node_modules/parcel-bundler/node_modules/path-browserify/index.js","process":"../../../../.nvm/versions/node/v12.18.3/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"node_modules/core-js/modules/_global.js":[function(require,module,exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

},{}],"node_modules/core-js/modules/_has.js":[function(require,module,exports) {
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

},{}],"node_modules/core-js/modules/_fails.js":[function(require,module,exports) {
module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

},{}],"node_modules/core-js/modules/_descriptors.js":[function(require,module,exports) {
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_fails":"node_modules/core-js/modules/_fails.js"}],"node_modules/core-js/modules/_core.js":[function(require,module,exports) {
var core = module.exports = { version: '2.6.11' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

},{}],"node_modules/core-js/modules/_is-object.js":[function(require,module,exports) {
module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

},{}],"node_modules/core-js/modules/_an-object.js":[function(require,module,exports) {
var isObject = require('./_is-object');
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

},{"./_is-object":"node_modules/core-js/modules/_is-object.js"}],"node_modules/core-js/modules/_dom-create.js":[function(require,module,exports) {
var isObject = require('./_is-object');
var document = require('./_global').document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

},{"./_is-object":"node_modules/core-js/modules/_is-object.js","./_global":"node_modules/core-js/modules/_global.js"}],"node_modules/core-js/modules/_ie8-dom-define.js":[function(require,module,exports) {
module.exports = !require('./_descriptors') && !require('./_fails')(function () {
  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_descriptors":"node_modules/core-js/modules/_descriptors.js","./_fails":"node_modules/core-js/modules/_fails.js","./_dom-create":"node_modules/core-js/modules/_dom-create.js"}],"node_modules/core-js/modules/_to-primitive.js":[function(require,module,exports) {
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

},{"./_is-object":"node_modules/core-js/modules/_is-object.js"}],"node_modules/core-js/modules/_object-dp.js":[function(require,module,exports) {
var anObject = require('./_an-object');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var toPrimitive = require('./_to-primitive');
var dP = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

},{"./_an-object":"node_modules/core-js/modules/_an-object.js","./_ie8-dom-define":"node_modules/core-js/modules/_ie8-dom-define.js","./_to-primitive":"node_modules/core-js/modules/_to-primitive.js","./_descriptors":"node_modules/core-js/modules/_descriptors.js"}],"node_modules/core-js/modules/_property-desc.js":[function(require,module,exports) {
module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

},{}],"node_modules/core-js/modules/_hide.js":[function(require,module,exports) {
var dP = require('./_object-dp');
var createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

},{"./_object-dp":"node_modules/core-js/modules/_object-dp.js","./_property-desc":"node_modules/core-js/modules/_property-desc.js","./_descriptors":"node_modules/core-js/modules/_descriptors.js"}],"node_modules/core-js/modules/_uid.js":[function(require,module,exports) {
var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

},{}],"node_modules/core-js/modules/_library.js":[function(require,module,exports) {
module.exports = false;

},{}],"node_modules/core-js/modules/_shared.js":[function(require,module,exports) {

var core = require('./_core');
var global = require('./_global');
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: require('./_library') ? 'pure' : 'global',
  copyright: ' 2019 Denis Pushkarev (zloirock.ru)'
});

},{"./_core":"node_modules/core-js/modules/_core.js","./_global":"node_modules/core-js/modules/_global.js","./_library":"node_modules/core-js/modules/_library.js"}],"node_modules/core-js/modules/_function-to-string.js":[function(require,module,exports) {
module.exports = require('./_shared')('native-function-to-string', Function.toString);

},{"./_shared":"node_modules/core-js/modules/_shared.js"}],"node_modules/core-js/modules/_redefine.js":[function(require,module,exports) {

var global = require('./_global');
var hide = require('./_hide');
var has = require('./_has');
var SRC = require('./_uid')('src');
var $toString = require('./_function-to-string');
var TO_STRING = 'toString';
var TPL = ('' + $toString).split(TO_STRING);

require('./_core').inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});

},{"./_global":"node_modules/core-js/modules/_global.js","./_hide":"node_modules/core-js/modules/_hide.js","./_has":"node_modules/core-js/modules/_has.js","./_uid":"node_modules/core-js/modules/_uid.js","./_function-to-string":"node_modules/core-js/modules/_function-to-string.js","./_core":"node_modules/core-js/modules/_core.js"}],"node_modules/core-js/modules/_a-function.js":[function(require,module,exports) {
module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

},{}],"node_modules/core-js/modules/_ctx.js":[function(require,module,exports) {
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

},{"./_a-function":"node_modules/core-js/modules/_a-function.js"}],"node_modules/core-js/modules/_export.js":[function(require,module,exports) {

var global = require('./_global');
var core = require('./_core');
var hide = require('./_hide');
var redefine = require('./_redefine');
var ctx = require('./_ctx');
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;

},{"./_global":"node_modules/core-js/modules/_global.js","./_core":"node_modules/core-js/modules/_core.js","./_hide":"node_modules/core-js/modules/_hide.js","./_redefine":"node_modules/core-js/modules/_redefine.js","./_ctx":"node_modules/core-js/modules/_ctx.js"}],"node_modules/core-js/modules/_meta.js":[function(require,module,exports) {
var META = require('./_uid')('meta');
var isObject = require('./_is-object');
var has = require('./_has');
var setDesc = require('./_object-dp').f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !require('./_fails')(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

},{"./_uid":"node_modules/core-js/modules/_uid.js","./_is-object":"node_modules/core-js/modules/_is-object.js","./_has":"node_modules/core-js/modules/_has.js","./_object-dp":"node_modules/core-js/modules/_object-dp.js","./_fails":"node_modules/core-js/modules/_fails.js"}],"node_modules/core-js/modules/_wks.js":[function(require,module,exports) {
var store = require('./_shared')('wks');
var uid = require('./_uid');
var Symbol = require('./_global').Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

},{"./_shared":"node_modules/core-js/modules/_shared.js","./_uid":"node_modules/core-js/modules/_uid.js","./_global":"node_modules/core-js/modules/_global.js"}],"node_modules/core-js/modules/_set-to-string-tag.js":[function(require,module,exports) {
var def = require('./_object-dp').f;
var has = require('./_has');
var TAG = require('./_wks')('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};

},{"./_object-dp":"node_modules/core-js/modules/_object-dp.js","./_has":"node_modules/core-js/modules/_has.js","./_wks":"node_modules/core-js/modules/_wks.js"}],"node_modules/core-js/modules/_wks-ext.js":[function(require,module,exports) {
exports.f = require('./_wks');

},{"./_wks":"node_modules/core-js/modules/_wks.js"}],"node_modules/core-js/modules/_wks-define.js":[function(require,module,exports) {

var global = require('./_global');
var core = require('./_core');
var LIBRARY = require('./_library');
var wksExt = require('./_wks-ext');
var defineProperty = require('./_object-dp').f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};

},{"./_global":"node_modules/core-js/modules/_global.js","./_core":"node_modules/core-js/modules/_core.js","./_library":"node_modules/core-js/modules/_library.js","./_wks-ext":"node_modules/core-js/modules/_wks-ext.js","./_object-dp":"node_modules/core-js/modules/_object-dp.js"}],"node_modules/core-js/modules/_cof.js":[function(require,module,exports) {
var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

},{}],"node_modules/core-js/modules/_iobject.js":[function(require,module,exports) {
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

},{"./_cof":"node_modules/core-js/modules/_cof.js"}],"node_modules/core-js/modules/_defined.js":[function(require,module,exports) {
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

},{}],"node_modules/core-js/modules/_to-iobject.js":[function(require,module,exports) {
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject');
var defined = require('./_defined');
module.exports = function (it) {
  return IObject(defined(it));
};

},{"./_iobject":"node_modules/core-js/modules/_iobject.js","./_defined":"node_modules/core-js/modules/_defined.js"}],"node_modules/core-js/modules/_to-integer.js":[function(require,module,exports) {
// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

},{}],"node_modules/core-js/modules/_to-length.js":[function(require,module,exports) {
// 7.1.15 ToLength
var toInteger = require('./_to-integer');
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

},{"./_to-integer":"node_modules/core-js/modules/_to-integer.js"}],"node_modules/core-js/modules/_to-absolute-index.js":[function(require,module,exports) {
var toInteger = require('./_to-integer');
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

},{"./_to-integer":"node_modules/core-js/modules/_to-integer.js"}],"node_modules/core-js/modules/_array-includes.js":[function(require,module,exports) {
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');
var toAbsoluteIndex = require('./_to-absolute-index');
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

},{"./_to-iobject":"node_modules/core-js/modules/_to-iobject.js","./_to-length":"node_modules/core-js/modules/_to-length.js","./_to-absolute-index":"node_modules/core-js/modules/_to-absolute-index.js"}],"node_modules/core-js/modules/_shared-key.js":[function(require,module,exports) {
var shared = require('./_shared')('keys');
var uid = require('./_uid');
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

},{"./_shared":"node_modules/core-js/modules/_shared.js","./_uid":"node_modules/core-js/modules/_uid.js"}],"node_modules/core-js/modules/_object-keys-internal.js":[function(require,module,exports) {
var has = require('./_has');
var toIObject = require('./_to-iobject');
var arrayIndexOf = require('./_array-includes')(false);
var IE_PROTO = require('./_shared-key')('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

},{"./_has":"node_modules/core-js/modules/_has.js","./_to-iobject":"node_modules/core-js/modules/_to-iobject.js","./_array-includes":"node_modules/core-js/modules/_array-includes.js","./_shared-key":"node_modules/core-js/modules/_shared-key.js"}],"node_modules/core-js/modules/_enum-bug-keys.js":[function(require,module,exports) {
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

},{}],"node_modules/core-js/modules/_object-keys.js":[function(require,module,exports) {
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = require('./_object-keys-internal');
var enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

},{"./_object-keys-internal":"node_modules/core-js/modules/_object-keys-internal.js","./_enum-bug-keys":"node_modules/core-js/modules/_enum-bug-keys.js"}],"node_modules/core-js/modules/_object-gops.js":[function(require,module,exports) {
exports.f = Object.getOwnPropertySymbols;

},{}],"node_modules/core-js/modules/_object-pie.js":[function(require,module,exports) {
exports.f = {}.propertyIsEnumerable;

},{}],"node_modules/core-js/modules/_enum-keys.js":[function(require,module,exports) {
// all enumerable object keys, includes symbols
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};

},{"./_object-keys":"node_modules/core-js/modules/_object-keys.js","./_object-gops":"node_modules/core-js/modules/_object-gops.js","./_object-pie":"node_modules/core-js/modules/_object-pie.js"}],"node_modules/core-js/modules/_is-array.js":[function(require,module,exports) {
// 7.2.2 IsArray(argument)
var cof = require('./_cof');
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};

},{"./_cof":"node_modules/core-js/modules/_cof.js"}],"node_modules/core-js/modules/_to-object.js":[function(require,module,exports) {
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function (it) {
  return Object(defined(it));
};

},{"./_defined":"node_modules/core-js/modules/_defined.js"}],"node_modules/core-js/modules/_object-dps.js":[function(require,module,exports) {
var dP = require('./_object-dp');
var anObject = require('./_an-object');
var getKeys = require('./_object-keys');

module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};

},{"./_object-dp":"node_modules/core-js/modules/_object-dp.js","./_an-object":"node_modules/core-js/modules/_an-object.js","./_object-keys":"node_modules/core-js/modules/_object-keys.js","./_descriptors":"node_modules/core-js/modules/_descriptors.js"}],"node_modules/core-js/modules/_html.js":[function(require,module,exports) {
var document = require('./_global').document;
module.exports = document && document.documentElement;

},{"./_global":"node_modules/core-js/modules/_global.js"}],"node_modules/core-js/modules/_object-create.js":[function(require,module,exports) {
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = require('./_an-object');
var dPs = require('./_object-dps');
var enumBugKeys = require('./_enum-bug-keys');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = require('./_dom-create')('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  require('./_html').appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":"node_modules/core-js/modules/_an-object.js","./_object-dps":"node_modules/core-js/modules/_object-dps.js","./_enum-bug-keys":"node_modules/core-js/modules/_enum-bug-keys.js","./_shared-key":"node_modules/core-js/modules/_shared-key.js","./_dom-create":"node_modules/core-js/modules/_dom-create.js","./_html":"node_modules/core-js/modules/_html.js"}],"node_modules/core-js/modules/_object-gopn.js":[function(require,module,exports) {
// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = require('./_object-keys-internal');
var hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};

},{"./_object-keys-internal":"node_modules/core-js/modules/_object-keys-internal.js","./_enum-bug-keys":"node_modules/core-js/modules/_enum-bug-keys.js"}],"node_modules/core-js/modules/_object-gopn-ext.js":[function(require,module,exports) {
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = require('./_to-iobject');
var gOPN = require('./_object-gopn').f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

},{"./_to-iobject":"node_modules/core-js/modules/_to-iobject.js","./_object-gopn":"node_modules/core-js/modules/_object-gopn.js"}],"node_modules/core-js/modules/_object-gopd.js":[function(require,module,exports) {
var pIE = require('./_object-pie');
var createDesc = require('./_property-desc');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var has = require('./_has');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

},{"./_object-pie":"node_modules/core-js/modules/_object-pie.js","./_property-desc":"node_modules/core-js/modules/_property-desc.js","./_to-iobject":"node_modules/core-js/modules/_to-iobject.js","./_to-primitive":"node_modules/core-js/modules/_to-primitive.js","./_has":"node_modules/core-js/modules/_has.js","./_ie8-dom-define":"node_modules/core-js/modules/_ie8-dom-define.js","./_descriptors":"node_modules/core-js/modules/_descriptors.js"}],"node_modules/core-js/modules/es6.symbol.js":[function(require,module,exports) {

'use strict';
// ECMAScript 6 symbols shim
var global = require('./_global');
var has = require('./_has');
var DESCRIPTORS = require('./_descriptors');
var $export = require('./_export');
var redefine = require('./_redefine');
var META = require('./_meta').KEY;
var $fails = require('./_fails');
var shared = require('./_shared');
var setToStringTag = require('./_set-to-string-tag');
var uid = require('./_uid');
var wks = require('./_wks');
var wksExt = require('./_wks-ext');
var wksDefine = require('./_wks-define');
var enumKeys = require('./_enum-keys');
var isArray = require('./_is-array');
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var toObject = require('./_to-object');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var createDesc = require('./_property-desc');
var _create = require('./_object-create');
var gOPNExt = require('./_object-gopn-ext');
var $GOPD = require('./_object-gopd');
var $GOPS = require('./_object-gops');
var $DP = require('./_object-dp');
var $keys = require('./_object-keys');
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function' && !!$GOPS.f;
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;
  require('./_object-pie').f = $propertyIsEnumerable;
  $GOPS.f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !require('./_library')) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
var FAILS_ON_PRIMITIVES = $fails(function () { $GOPS.f(1); });

$export($export.S + $export.F * FAILS_ON_PRIMITIVES, 'Object', {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return $GOPS.f(toObject(it));
  }
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

},{"./_global":"node_modules/core-js/modules/_global.js","./_has":"node_modules/core-js/modules/_has.js","./_descriptors":"node_modules/core-js/modules/_descriptors.js","./_export":"node_modules/core-js/modules/_export.js","./_redefine":"node_modules/core-js/modules/_redefine.js","./_meta":"node_modules/core-js/modules/_meta.js","./_fails":"node_modules/core-js/modules/_fails.js","./_shared":"node_modules/core-js/modules/_shared.js","./_set-to-string-tag":"node_modules/core-js/modules/_set-to-string-tag.js","./_uid":"node_modules/core-js/modules/_uid.js","./_wks":"node_modules/core-js/modules/_wks.js","./_wks-ext":"node_modules/core-js/modules/_wks-ext.js","./_wks-define":"node_modules/core-js/modules/_wks-define.js","./_enum-keys":"node_modules/core-js/modules/_enum-keys.js","./_is-array":"node_modules/core-js/modules/_is-array.js","./_an-object":"node_modules/core-js/modules/_an-object.js","./_is-object":"node_modules/core-js/modules/_is-object.js","./_to-object":"node_modules/core-js/modules/_to-object.js","./_to-iobject":"node_modules/core-js/modules/_to-iobject.js","./_to-primitive":"node_modules/core-js/modules/_to-primitive.js","./_property-desc":"node_modules/core-js/modules/_property-desc.js","./_object-create":"node_modules/core-js/modules/_object-create.js","./_object-gopn-ext":"node_modules/core-js/modules/_object-gopn-ext.js","./_object-gopd":"node_modules/core-js/modules/_object-gopd.js","./_object-gops":"node_modules/core-js/modules/_object-gops.js","./_object-dp":"node_modules/core-js/modules/_object-dp.js","./_object-keys":"node_modules/core-js/modules/_object-keys.js","./_object-gopn":"node_modules/core-js/modules/_object-gopn.js","./_object-pie":"node_modules/core-js/modules/_object-pie.js","./_library":"node_modules/core-js/modules/_library.js","./_hide":"node_modules/core-js/modules/_hide.js"}],"node_modules/core-js/modules/es6.object.create.js":[function(require,module,exports) {
var $export = require('./_export');
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: require('./_object-create') });

},{"./_export":"node_modules/core-js/modules/_export.js","./_object-create":"node_modules/core-js/modules/_object-create.js"}],"node_modules/core-js/modules/es6.object.define-property.js":[function(require,module,exports) {
var $export = require('./_export');
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperty: require('./_object-dp').f });

},{"./_export":"node_modules/core-js/modules/_export.js","./_descriptors":"node_modules/core-js/modules/_descriptors.js","./_object-dp":"node_modules/core-js/modules/_object-dp.js"}],"node_modules/core-js/modules/es6.object.define-properties.js":[function(require,module,exports) {
var $export = require('./_export');
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperties: require('./_object-dps') });

},{"./_export":"node_modules/core-js/modules/_export.js","./_descriptors":"node_modules/core-js/modules/_descriptors.js","./_object-dps":"node_modules/core-js/modules/_object-dps.js"}],"node_modules/core-js/modules/_object-sap.js":[function(require,module,exports) {
// most Object methods by ES6 should accept primitives
var $export = require('./_export');
var core = require('./_core');
var fails = require('./_fails');
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};

},{"./_export":"node_modules/core-js/modules/_export.js","./_core":"node_modules/core-js/modules/_core.js","./_fails":"node_modules/core-js/modules/_fails.js"}],"node_modules/core-js/modules/es6.object.get-own-property-descriptor.js":[function(require,module,exports) {
// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = require('./_to-iobject');
var $getOwnPropertyDescriptor = require('./_object-gopd').f;

require('./_object-sap')('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});

},{"./_to-iobject":"node_modules/core-js/modules/_to-iobject.js","./_object-gopd":"node_modules/core-js/modules/_object-gopd.js","./_object-sap":"node_modules/core-js/modules/_object-sap.js"}],"node_modules/core-js/modules/_object-gpo.js":[function(require,module,exports) {
// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = require('./_has');
var toObject = require('./_to-object');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

},{"./_has":"node_modules/core-js/modules/_has.js","./_to-object":"node_modules/core-js/modules/_to-object.js","./_shared-key":"node_modules/core-js/modules/_shared-key.js"}],"node_modules/core-js/modules/es6.object.get-prototype-of.js":[function(require,module,exports) {
// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = require('./_to-object');
var $getPrototypeOf = require('./_object-gpo');

require('./_object-sap')('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});

},{"./_to-object":"node_modules/core-js/modules/_to-object.js","./_object-gpo":"node_modules/core-js/modules/_object-gpo.js","./_object-sap":"node_modules/core-js/modules/_object-sap.js"}],"node_modules/core-js/modules/es6.object.keys.js":[function(require,module,exports) {
// 19.1.2.14 Object.keys(O)
var toObject = require('./_to-object');
var $keys = require('./_object-keys');

require('./_object-sap')('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});

},{"./_to-object":"node_modules/core-js/modules/_to-object.js","./_object-keys":"node_modules/core-js/modules/_object-keys.js","./_object-sap":"node_modules/core-js/modules/_object-sap.js"}],"node_modules/core-js/modules/es6.object.get-own-property-names.js":[function(require,module,exports) {
// 19.1.2.7 Object.getOwnPropertyNames(O)
require('./_object-sap')('getOwnPropertyNames', function () {
  return require('./_object-gopn-ext').f;
});

},{"./_object-sap":"node_modules/core-js/modules/_object-sap.js","./_object-gopn-ext":"node_modules/core-js/modules/_object-gopn-ext.js"}],"node_modules/core-js/modules/es6.object.freeze.js":[function(require,module,exports) {
// 19.1.2.5 Object.freeze(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('freeze', function ($freeze) {
  return function freeze(it) {
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});

},{"./_is-object":"node_modules/core-js/modules/_is-object.js","./_meta":"node_modules/core-js/modules/_meta.js","./_object-sap":"node_modules/core-js/modules/_object-sap.js"}],"node_modules/core-js/modules/es6.object.seal.js":[function(require,module,exports) {
// 19.1.2.17 Object.seal(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('seal', function ($seal) {
  return function seal(it) {
    return $seal && isObject(it) ? $seal(meta(it)) : it;
  };
});

},{"./_is-object":"node_modules/core-js/modules/_is-object.js","./_meta":"node_modules/core-js/modules/_meta.js","./_object-sap":"node_modules/core-js/modules/_object-sap.js"}],"node_modules/core-js/modules/es6.object.prevent-extensions.js":[function(require,module,exports) {
// 19.1.2.15 Object.preventExtensions(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('preventExtensions', function ($preventExtensions) {
  return function preventExtensions(it) {
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});

},{"./_is-object":"node_modules/core-js/modules/_is-object.js","./_meta":"node_modules/core-js/modules/_meta.js","./_object-sap":"node_modules/core-js/modules/_object-sap.js"}],"node_modules/core-js/modules/es6.object.is-frozen.js":[function(require,module,exports) {
// 19.1.2.12 Object.isFrozen(O)
var isObject = require('./_is-object');

require('./_object-sap')('isFrozen', function ($isFrozen) {
  return function isFrozen(it) {
    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});

},{"./_is-object":"node_modules/core-js/modules/_is-object.js","./_object-sap":"node_modules/core-js/modules/_object-sap.js"}],"node_modules/core-js/modules/es6.object.is-sealed.js":[function(require,module,exports) {
// 19.1.2.13 Object.isSealed(O)
var isObject = require('./_is-object');

require('./_object-sap')('isSealed', function ($isSealed) {
  return function isSealed(it) {
    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});

},{"./_is-object":"node_modules/core-js/modules/_is-object.js","./_object-sap":"node_modules/core-js/modules/_object-sap.js"}],"node_modules/core-js/modules/es6.object.is-extensible.js":[function(require,module,exports) {
// 19.1.2.11 Object.isExtensible(O)
var isObject = require('./_is-object');

require('./_object-sap')('isExtensible', function ($isExtensible) {
  return function isExtensible(it) {
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});

},{"./_is-object":"node_modules/core-js/modules/_is-object.js","./_object-sap":"node_modules/core-js/modules/_object-sap.js"}],"node_modules/core-js/modules/_object-assign.js":[function(require,module,exports) {
'use strict';
// 19.1.2.1 Object.assign(target, source, ...)
var DESCRIPTORS = require('./_descriptors');
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
var toObject = require('./_to-object');
var IObject = require('./_iobject');
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || require('./_fails')(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || isEnum.call(S, key)) T[key] = S[key];
    }
  } return T;
} : $assign;

},{"./_descriptors":"node_modules/core-js/modules/_descriptors.js","./_object-keys":"node_modules/core-js/modules/_object-keys.js","./_object-gops":"node_modules/core-js/modules/_object-gops.js","./_object-pie":"node_modules/core-js/modules/_object-pie.js","./_to-object":"node_modules/core-js/modules/_to-object.js","./_iobject":"node_modules/core-js/modules/_iobject.js","./_fails":"node_modules/core-js/modules/_fails.js"}],"node_modules/core-js/modules/es6.object.assign.js":[function(require,module,exports) {
// 19.1.3.1 Object.assign(target, source)
var $export = require('./_export');

$export($export.S + $export.F, 'Object', { assign: require('./_object-assign') });

},{"./_export":"node_modules/core-js/modules/_export.js","./_object-assign":"node_modules/core-js/modules/_object-assign.js"}],"node_modules/core-js/modules/_same-value.js":[function(require,module,exports) {
// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};

},{}],"node_modules/core-js/modules/es6.object.is.js":[function(require,module,exports) {
// 19.1.3.10 Object.is(value1, value2)
var $export = require('./_export');
$export($export.S, 'Object', { is: require('./_same-value') });

},{"./_export":"node_modules/core-js/modules/_export.js","./_same-value":"node_modules/core-js/modules/_same-value.js"}],"node_modules/core-js/modules/_set-proto.js":[function(require,module,exports) {
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = require('./_is-object');
var anObject = require('./_an-object');
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};

},{"./_is-object":"node_modules/core-js/modules/_is-object.js","./_an-object":"node_modules/core-js/modules/_an-object.js","./_ctx":"node_modules/core-js/modules/_ctx.js","./_object-gopd":"node_modules/core-js/modules/_object-gopd.js"}],"node_modules/core-js/modules/es6.object.set-prototype-of.js":[function(require,module,exports) {
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = require('./_export');
$export($export.S, 'Object', { setPrototypeOf: require('./_set-proto').set });

},{"./_export":"node_modules/core-js/modules/_export.js","./_set-proto":"node_modules/core-js/modules/_set-proto.js"}],"node_modules/core-js/modules/_classof.js":[function(require,module,exports) {
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./_cof');
var TAG = require('./_wks')('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

},{"./_cof":"node_modules/core-js/modules/_cof.js","./_wks":"node_modules/core-js/modules/_wks.js"}],"node_modules/core-js/modules/es6.object.to-string.js":[function(require,module,exports) {
'use strict';
// 19.1.3.6 Object.prototype.toString()
var classof = require('./_classof');
var test = {};
test[require('./_wks')('toStringTag')] = 'z';
if (test + '' != '[object z]') {
  require('./_redefine')(Object.prototype, 'toString', function toString() {
    return '[object ' + classof(this) + ']';
  }, true);
}

},{"./_classof":"node_modules/core-js/modules/_classof.js","./_wks":"node_modules/core-js/modules/_wks.js","./_redefine":"node_modules/core-js/modules/_redefine.js"}],"node_modules/core-js/modules/_invoke.js":[function(require,module,exports) {
// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};

},{}],"node_modules/core-js/modules/_bind.js":[function(require,module,exports) {
'use strict';
var aFunction = require('./_a-function');
var isObject = require('./_is-object');
var invoke = require('./_invoke');
var arraySlice = [].slice;
var factories = {};

var construct = function (F, len, args) {
  if (!(len in factories)) {
    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';
    // eslint-disable-next-line no-new-func
    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  } return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /* , ...args */) {
  var fn = aFunction(this);
  var partArgs = arraySlice.call(arguments, 1);
  var bound = function (/* args... */) {
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
  return bound;
};

},{"./_a-function":"node_modules/core-js/modules/_a-function.js","./_is-object":"node_modules/core-js/modules/_is-object.js","./_invoke":"node_modules/core-js/modules/_invoke.js"}],"node_modules/core-js/modules/es6.function.bind.js":[function(require,module,exports) {
// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = require('./_export');

$export($export.P, 'Function', { bind: require('./_bind') });

},{"./_export":"node_modules/core-js/modules/_export.js","./_bind":"node_modules/core-js/modules/_bind.js"}],"node_modules/core-js/modules/es6.function.name.js":[function(require,module,exports) {
var dP = require('./_object-dp').f;
var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// 19.2.4.2 name
NAME in FProto || require('./_descriptors') && dP(FProto, NAME, {
  configurable: true,
  get: function () {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});

},{"./_object-dp":"node_modules/core-js/modules/_object-dp.js","./_descriptors":"node_modules/core-js/modules/_descriptors.js"}],"node_modules/core-js/modules/es6.function.has-instance.js":[function(require,module,exports) {
'use strict';
var isObject = require('./_is-object');
var getPrototypeOf = require('./_object-gpo');
var HAS_INSTANCE = require('./_wks')('hasInstance');
var FunctionProto = Function.prototype;
// 19.2.3.6 Function.prototype[@@hasInstance](V)
if (!(HAS_INSTANCE in FunctionProto)) require('./_object-dp').f(FunctionProto, HAS_INSTANCE, { value: function (O) {
  if (typeof this != 'function' || !isObject(O)) return false;
  if (!isObject(this.prototype)) return O instanceof this;
  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
  while (O = getPrototypeOf(O)) if (this.prototype === O) return true;
  return false;
} });

},{"./_is-object":"node_modules/core-js/modules/_is-object.js","./_object-gpo":"node_modules/core-js/modules/_object-gpo.js","./_wks":"node_modules/core-js/modules/_wks.js","./_object-dp":"node_modules/core-js/modules/_object-dp.js"}],"node_modules/core-js/modules/_string-ws.js":[function(require,module,exports) {
module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

},{}],"node_modules/core-js/modules/_string-trim.js":[function(require,module,exports) {
var $export = require('./_export');
var defined = require('./_defined');
var fails = require('./_fails');
var spaces = require('./_string-ws');
var space = '[' + spaces + ']';
var non = '\u200b\u0085';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function (KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;

},{"./_export":"node_modules/core-js/modules/_export.js","./_defined":"node_modules/core-js/modules/_defined.js","./_fails":"node_modules/core-js/modules/_fails.js","./_string-ws":"node_modules/core-js/modules/_string-ws.js"}],"node_modules/core-js/modules/_parse-int.js":[function(require,module,exports) {
var $parseInt = require('./_global').parseInt;
var $trim = require('./_string-trim').trim;
var ws = require('./_string-ws');
var hex = /^[-+]?0[xX]/;

module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
  var string = $trim(String(str), 3);
  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
} : $parseInt;

},{"./_global":"node_modules/core-js/modules/_global.js","./_string-trim":"node_modules/core-js/modules/_string-trim.js","./_string-ws":"node_modules/core-js/modules/_string-ws.js"}],"node_modules/core-js/modules/es6.parse-int.js":[function(require,module,exports) {
var $export = require('./_export');
var $parseInt = require('./_parse-int');
// 18.2.5 parseInt(string, radix)
$export($export.G + $export.F * (parseInt != $parseInt), { parseInt: $parseInt });

},{"./_export":"node_modules/core-js/modules/_export.js","./_parse-int":"node_modules/core-js/modules/_parse-int.js"}],"node_modules/core-js/modules/_parse-float.js":[function(require,module,exports) {
var $parseFloat = require('./_global').parseFloat;
var $trim = require('./_string-trim').trim;

module.exports = 1 / $parseFloat(require('./_string-ws') + '-0') !== -Infinity ? function parseFloat(str) {
  var string = $trim(String(str), 3);
  var result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;

},{"./_global":"node_modules/core-js/modules/_global.js","./_string-trim":"node_modules/core-js/modules/_string-trim.js","./_string-ws":"node_modules/core-js/modules/_string-ws.js"}],"node_modules/core-js/modules/es6.parse-float.js":[function(require,module,exports) {
var $export = require('./_export');
var $parseFloat = require('./_parse-float');
// 18.2.4 parseFloat(string)
$export($export.G + $export.F * (parseFloat != $parseFloat), { parseFloat: $parseFloat });

},{"./_export":"node_modules/core-js/modules/_export.js","./_parse-float":"node_modules/core-js/modules/_parse-float.js"}],"node_modules/core-js/modules/_inherit-if-required.js":[function(require,module,exports) {
var isObject = require('./_is-object');
var setPrototypeOf = require('./_set-proto').set;
module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  } return that;
};

},{"./_is-object":"node_modules/core-js/modules/_is-object.js","./_set-proto":"node_modules/core-js/modules/_set-proto.js"}],"node_modules/core-js/modules/es6.number.constructor.js":[function(require,module,exports) {

'use strict';
var global = require('./_global');
var has = require('./_has');
var cof = require('./_cof');
var inheritIfRequired = require('./_inherit-if-required');
var toPrimitive = require('./_to-primitive');
var fails = require('./_fails');
var gOPN = require('./_object-gopn').f;
var gOPD = require('./_object-gopd').f;
var dP = require('./_object-dp').f;
var $trim = require('./_string-trim').trim;
var NUMBER = 'Number';
var $Number = global[NUMBER];
var Base = $Number;
var proto = $Number.prototype;
// Opera ~12 has broken Object#toString
var BROKEN_COF = cof(require('./_object-create')(proto)) == NUMBER;
var TRIM = 'trim' in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber = function (argument) {
  var it = toPrimitive(argument, false);
  if (typeof it == 'string' && it.length > 2) {
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0);
    var third, radix, maxCode;
    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
        default: return +it;
      }
      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
        code = digits.charCodeAt(i);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
  $Number = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var that = this;
    return that instanceof $Number
      // check on 1..constructor(foo) case
      && (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER)
        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for (var keys = require('./_descriptors') ? gOPN(Base) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES6 (in case, if modules with ES6 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++) {
    if (has(Base, key = keys[j]) && !has($Number, key)) {
      dP($Number, key, gOPD(Base, key));
    }
  }
  $Number.prototype = proto;
  proto.constructor = $Number;
  require('./_redefine')(global, NUMBER, $Number);
}

},{"./_global":"node_modules/core-js/modules/_global.js","./_has":"node_modules/core-js/modules/_has.js","./_cof":"node_modules/core-js/modules/_cof.js","./_inherit-if-required":"node_modules/core-js/modules/_inherit-if-required.js","./_to-primitive":"node_modules/core-js/modules/_to-primitive.js","./_fails":"node_modules/core-js/modules/_fails.js","./_object-gopn":"node_modules/core-js/modules/_object-gopn.js","./_object-gopd":"node_modules/core-js/modules/_object-gopd.js","./_object-dp":"node_modules/core-js/modules/_object-dp.js","./_string-trim":"node_modules/core-js/modules/_string-trim.js","./_object-create":"node_modules/core-js/modules/_object-create.js","./_descriptors":"node_modules/core-js/modules/_descriptors.js","./_redefine":"node_modules/core-js/modules/_redefine.js"}],"node_modules/core-js/modules/_a-number-value.js":[function(require,module,exports) {
var cof = require('./_cof');
module.exports = function (it, msg) {
  if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);
  return +it;
};

},{"./_cof":"node_modules/core-js/modules/_cof.js"}],"node_modules/core-js/modules/_string-repeat.js":[function(require,module,exports) {
'use strict';
var toInteger = require('./_to-integer');
var defined = require('./_defined');

module.exports = function repeat(count) {
  var str = String(defined(this));
  var res = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;
  return res;
};

},{"./_to-integer":"node_modules/core-js/modules/_to-integer.js","./_defined":"node_modules/core-js/modules/_defined.js"}],"node_modules/core-js/modules/es6.number.to-fixed.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var toInteger = require('./_to-integer');
var aNumberValue = require('./_a-number-value');
var repeat = require('./_string-repeat');
var $toFixed = 1.0.toFixed;
var floor = Math.floor;
var data = [0, 0, 0, 0, 0, 0];
var ERROR = 'Number.toFixed: incorrect invocation!';
var ZERO = '0';

var multiply = function (n, c) {
  var i = -1;
  var c2 = c;
  while (++i < 6) {
    c2 += n * data[i];
    data[i] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};
var divide = function (n) {
  var i = 6;
  var c = 0;
  while (--i >= 0) {
    c += data[i];
    data[i] = floor(c / n);
    c = (c % n) * 1e7;
  }
};
var numToString = function () {
  var i = 6;
  var s = '';
  while (--i >= 0) {
    if (s !== '' || i === 0 || data[i] !== 0) {
      var t = String(data[i]);
      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
    }
  } return s;
};
var pow = function (x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};
var log = function (x) {
  var n = 0;
  var x2 = x;
  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }
  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  } return n;
};

$export($export.P + $export.F * (!!$toFixed && (
  0.00008.toFixed(3) !== '0.000' ||
  0.9.toFixed(0) !== '1' ||
  1.255.toFixed(2) !== '1.25' ||
  1000000000000000128.0.toFixed(0) !== '1000000000000000128'
) || !require('./_fails')(function () {
  // V8 ~ Android 4.3-
  $toFixed.call({});
})), 'Number', {
  toFixed: function toFixed(fractionDigits) {
    var x = aNumberValue(this, ERROR);
    var f = toInteger(fractionDigits);
    var s = '';
    var m = ZERO;
    var e, z, j, k;
    if (f < 0 || f > 20) throw RangeError(ERROR);
    // eslint-disable-next-line no-self-compare
    if (x != x) return 'NaN';
    if (x <= -1e21 || x >= 1e21) return String(x);
    if (x < 0) {
      s = '-';
      x = -x;
    }
    if (x > 1e-21) {
      e = log(x * pow(2, 69, 1)) - 69;
      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if (e > 0) {
        multiply(0, z);
        j = f;
        while (j >= 7) {
          multiply(1e7, 0);
          j -= 7;
        }
        multiply(pow(10, j, 1), 0);
        j = e - 1;
        while (j >= 23) {
          divide(1 << 23);
          j -= 23;
        }
        divide(1 << j);
        multiply(1, 1);
        divide(2);
        m = numToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        m = numToString() + repeat.call(ZERO, f);
      }
    }
    if (f > 0) {
      k = m.length;
      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
    } else {
      m = s + m;
    } return m;
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_to-integer":"node_modules/core-js/modules/_to-integer.js","./_a-number-value":"node_modules/core-js/modules/_a-number-value.js","./_string-repeat":"node_modules/core-js/modules/_string-repeat.js","./_fails":"node_modules/core-js/modules/_fails.js"}],"node_modules/core-js/modules/es6.number.to-precision.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $fails = require('./_fails');
var aNumberValue = require('./_a-number-value');
var $toPrecision = 1.0.toPrecision;

$export($export.P + $export.F * ($fails(function () {
  // IE7-
  return $toPrecision.call(1, undefined) !== '1';
}) || !$fails(function () {
  // V8 ~ Android 4.3-
  $toPrecision.call({});
})), 'Number', {
  toPrecision: function toPrecision(precision) {
    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_fails":"node_modules/core-js/modules/_fails.js","./_a-number-value":"node_modules/core-js/modules/_a-number-value.js"}],"node_modules/core-js/modules/es6.number.epsilon.js":[function(require,module,exports) {
// 20.1.2.1 Number.EPSILON
var $export = require('./_export');

$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });

},{"./_export":"node_modules/core-js/modules/_export.js"}],"node_modules/core-js/modules/es6.number.is-finite.js":[function(require,module,exports) {
// 20.1.2.2 Number.isFinite(number)
var $export = require('./_export');
var _isFinite = require('./_global').isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it) {
    return typeof it == 'number' && _isFinite(it);
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_global":"node_modules/core-js/modules/_global.js"}],"node_modules/core-js/modules/_is-integer.js":[function(require,module,exports) {
// 20.1.2.3 Number.isInteger(number)
var isObject = require('./_is-object');
var floor = Math.floor;
module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};

},{"./_is-object":"node_modules/core-js/modules/_is-object.js"}],"node_modules/core-js/modules/es6.number.is-integer.js":[function(require,module,exports) {
// 20.1.2.3 Number.isInteger(number)
var $export = require('./_export');

$export($export.S, 'Number', { isInteger: require('./_is-integer') });

},{"./_export":"node_modules/core-js/modules/_export.js","./_is-integer":"node_modules/core-js/modules/_is-integer.js"}],"node_modules/core-js/modules/es6.number.is-nan.js":[function(require,module,exports) {
// 20.1.2.4 Number.isNaN(number)
var $export = require('./_export');

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js"}],"node_modules/core-js/modules/es6.number.is-safe-integer.js":[function(require,module,exports) {
// 20.1.2.5 Number.isSafeInteger(number)
var $export = require('./_export');
var isInteger = require('./_is-integer');
var abs = Math.abs;

$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number) {
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_is-integer":"node_modules/core-js/modules/_is-integer.js"}],"node_modules/core-js/modules/es6.number.max-safe-integer.js":[function(require,module,exports) {
// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = require('./_export');

$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });

},{"./_export":"node_modules/core-js/modules/_export.js"}],"node_modules/core-js/modules/es6.number.min-safe-integer.js":[function(require,module,exports) {
// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = require('./_export');

$export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });

},{"./_export":"node_modules/core-js/modules/_export.js"}],"node_modules/core-js/modules/es6.number.parse-float.js":[function(require,module,exports) {
var $export = require('./_export');
var $parseFloat = require('./_parse-float');
// 20.1.2.12 Number.parseFloat(string)
$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', { parseFloat: $parseFloat });

},{"./_export":"node_modules/core-js/modules/_export.js","./_parse-float":"node_modules/core-js/modules/_parse-float.js"}],"node_modules/core-js/modules/es6.number.parse-int.js":[function(require,module,exports) {
var $export = require('./_export');
var $parseInt = require('./_parse-int');
// 20.1.2.13 Number.parseInt(string, radix)
$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', { parseInt: $parseInt });

},{"./_export":"node_modules/core-js/modules/_export.js","./_parse-int":"node_modules/core-js/modules/_parse-int.js"}],"node_modules/core-js/modules/_math-log1p.js":[function(require,module,exports) {
// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x) {
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};

},{}],"node_modules/core-js/modules/es6.math.acosh.js":[function(require,module,exports) {
// 20.2.2.3 Math.acosh(x)
var $export = require('./_export');
var log1p = require('./_math-log1p');
var sqrt = Math.sqrt;
var $acosh = Math.acosh;

$export($export.S + $export.F * !($acosh
  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
  && Math.floor($acosh(Number.MAX_VALUE)) == 710
  // Tor Browser bug: Math.acosh(Infinity) -> NaN
  && $acosh(Infinity) == Infinity
), 'Math', {
  acosh: function acosh(x) {
    return (x = +x) < 1 ? NaN : x > 94906265.62425156
      ? Math.log(x) + Math.LN2
      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_math-log1p":"node_modules/core-js/modules/_math-log1p.js"}],"node_modules/core-js/modules/es6.math.asinh.js":[function(require,module,exports) {
// 20.2.2.5 Math.asinh(x)
var $export = require('./_export');
var $asinh = Math.asinh;

function asinh(x) {
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
}

// Tor Browser bug: Math.asinh(0) -> -0
$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });

},{"./_export":"node_modules/core-js/modules/_export.js"}],"node_modules/core-js/modules/es6.math.atanh.js":[function(require,module,exports) {
// 20.2.2.7 Math.atanh(x)
var $export = require('./_export');
var $atanh = Math.atanh;

// Tor Browser bug: Math.atanh(-0) -> 0
$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x) {
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js"}],"node_modules/core-js/modules/_math-sign.js":[function(require,module,exports) {
// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};

},{}],"node_modules/core-js/modules/es6.math.cbrt.js":[function(require,module,exports) {
// 20.2.2.9 Math.cbrt(x)
var $export = require('./_export');
var sign = require('./_math-sign');

$export($export.S, 'Math', {
  cbrt: function cbrt(x) {
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_math-sign":"node_modules/core-js/modules/_math-sign.js"}],"node_modules/core-js/modules/es6.math.clz32.js":[function(require,module,exports) {
// 20.2.2.11 Math.clz32(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  clz32: function clz32(x) {
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js"}],"node_modules/core-js/modules/es6.math.cosh.js":[function(require,module,exports) {
// 20.2.2.12 Math.cosh(x)
var $export = require('./_export');
var exp = Math.exp;

$export($export.S, 'Math', {
  cosh: function cosh(x) {
    return (exp(x = +x) + exp(-x)) / 2;
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js"}],"node_modules/core-js/modules/_math-expm1.js":[function(require,module,exports) {
// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = (!$expm1
  // Old FF bug
  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
  // Tor Browser bug
  || $expm1(-2e-17) != -2e-17
) ? function expm1(x) {
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;

},{}],"node_modules/core-js/modules/es6.math.expm1.js":[function(require,module,exports) {
// 20.2.2.14 Math.expm1(x)
var $export = require('./_export');
var $expm1 = require('./_math-expm1');

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 });

},{"./_export":"node_modules/core-js/modules/_export.js","./_math-expm1":"node_modules/core-js/modules/_math-expm1.js"}],"node_modules/core-js/modules/_math-fround.js":[function(require,module,exports) {
// 20.2.2.16 Math.fround(x)
var sign = require('./_math-sign');
var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);

var roundTiesToEven = function (n) {
  return n + 1 / EPSILON - 1 / EPSILON;
};

module.exports = Math.fround || function fround(x) {
  var $abs = Math.abs(x);
  var $sign = sign(x);
  var a, result;
  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
  a = (1 + EPSILON32 / EPSILON) * $abs;
  result = a - (a - $abs);
  // eslint-disable-next-line no-self-compare
  if (result > MAX32 || result != result) return $sign * Infinity;
  return $sign * result;
};

},{"./_math-sign":"node_modules/core-js/modules/_math-sign.js"}],"node_modules/core-js/modules/es6.math.fround.js":[function(require,module,exports) {
// 20.2.2.16 Math.fround(x)
var $export = require('./_export');

$export($export.S, 'Math', { fround: require('./_math-fround') });

},{"./_export":"node_modules/core-js/modules/_export.js","./_math-fround":"node_modules/core-js/modules/_math-fround.js"}],"node_modules/core-js/modules/es6.math.hypot.js":[function(require,module,exports) {
// 20.2.2.17 Math.hypot([value1[, value2[,  ]]])
var $export = require('./_export');
var abs = Math.abs;

$export($export.S, 'Math', {
  hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg, div;
    while (i < aLen) {
      arg = abs(arguments[i++]);
      if (larg < arg) {
        div = larg / arg;
        sum = sum * div * div + 1;
        larg = arg;
      } else if (arg > 0) {
        div = arg / larg;
        sum += div * div;
      } else sum += arg;
    }
    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js"}],"node_modules/core-js/modules/es6.math.imul.js":[function(require,module,exports) {
// 20.2.2.18 Math.imul(x, y)
var $export = require('./_export');
var $imul = Math.imul;

// some WebKit versions fails with big numbers, some has wrong arity
$export($export.S + $export.F * require('./_fails')(function () {
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y) {
    var UINT16 = 0xffff;
    var xn = +x;
    var yn = +y;
    var xl = UINT16 & xn;
    var yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_fails":"node_modules/core-js/modules/_fails.js"}],"node_modules/core-js/modules/es6.math.log10.js":[function(require,module,exports) {
// 20.2.2.21 Math.log10(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  log10: function log10(x) {
    return Math.log(x) * Math.LOG10E;
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js"}],"node_modules/core-js/modules/es6.math.log1p.js":[function(require,module,exports) {
// 20.2.2.20 Math.log1p(x)
var $export = require('./_export');

$export($export.S, 'Math', { log1p: require('./_math-log1p') });

},{"./_export":"node_modules/core-js/modules/_export.js","./_math-log1p":"node_modules/core-js/modules/_math-log1p.js"}],"node_modules/core-js/modules/es6.math.log2.js":[function(require,module,exports) {
// 20.2.2.22 Math.log2(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  log2: function log2(x) {
    return Math.log(x) / Math.LN2;
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js"}],"node_modules/core-js/modules/es6.math.sign.js":[function(require,module,exports) {
// 20.2.2.28 Math.sign(x)
var $export = require('./_export');

$export($export.S, 'Math', { sign: require('./_math-sign') });

},{"./_export":"node_modules/core-js/modules/_export.js","./_math-sign":"node_modules/core-js/modules/_math-sign.js"}],"node_modules/core-js/modules/es6.math.sinh.js":[function(require,module,exports) {
// 20.2.2.30 Math.sinh(x)
var $export = require('./_export');
var expm1 = require('./_math-expm1');
var exp = Math.exp;

// V8 near Chromium 38 has a problem with very small numbers
$export($export.S + $export.F * require('./_fails')(function () {
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x) {
    return Math.abs(x = +x) < 1
      ? (expm1(x) - expm1(-x)) / 2
      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_math-expm1":"node_modules/core-js/modules/_math-expm1.js","./_fails":"node_modules/core-js/modules/_fails.js"}],"node_modules/core-js/modules/es6.math.tanh.js":[function(require,module,exports) {
// 20.2.2.33 Math.tanh(x)
var $export = require('./_export');
var expm1 = require('./_math-expm1');
var exp = Math.exp;

$export($export.S, 'Math', {
  tanh: function tanh(x) {
    var a = expm1(x = +x);
    var b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_math-expm1":"node_modules/core-js/modules/_math-expm1.js"}],"node_modules/core-js/modules/es6.math.trunc.js":[function(require,module,exports) {
// 20.2.2.34 Math.trunc(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  trunc: function trunc(it) {
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js"}],"node_modules/core-js/modules/es6.string.from-code-point.js":[function(require,module,exports) {
var $export = require('./_export');
var toAbsoluteIndex = require('./_to-absolute-index');
var fromCharCode = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars
    var res = [];
    var aLen = arguments.length;
    var i = 0;
    var code;
    while (aLen > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
      );
    } return res.join('');
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_to-absolute-index":"node_modules/core-js/modules/_to-absolute-index.js"}],"node_modules/core-js/modules/es6.string.raw.js":[function(require,module,exports) {
var $export = require('./_export');
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite) {
    var tpl = toIObject(callSite.raw);
    var len = toLength(tpl.length);
    var aLen = arguments.length;
    var res = [];
    var i = 0;
    while (len > i) {
      res.push(String(tpl[i++]));
      if (i < aLen) res.push(String(arguments[i]));
    } return res.join('');
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_to-iobject":"node_modules/core-js/modules/_to-iobject.js","./_to-length":"node_modules/core-js/modules/_to-length.js"}],"node_modules/core-js/modules/es6.string.trim.js":[function(require,module,exports) {
'use strict';
// 21.1.3.25 String.prototype.trim()
require('./_string-trim')('trim', function ($trim) {
  return function trim() {
    return $trim(this, 3);
  };
});

},{"./_string-trim":"node_modules/core-js/modules/_string-trim.js"}],"node_modules/core-js/modules/_string-at.js":[function(require,module,exports) {
var toInteger = require('./_to-integer');
var defined = require('./_defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

},{"./_to-integer":"node_modules/core-js/modules/_to-integer.js","./_defined":"node_modules/core-js/modules/_defined.js"}],"node_modules/core-js/modules/_iterators.js":[function(require,module,exports) {
module.exports = {};

},{}],"node_modules/core-js/modules/_iter-create.js":[function(require,module,exports) {
'use strict';
var create = require('./_object-create');
var descriptor = require('./_property-desc');
var setToStringTag = require('./_set-to-string-tag');
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};

},{"./_object-create":"node_modules/core-js/modules/_object-create.js","./_property-desc":"node_modules/core-js/modules/_property-desc.js","./_set-to-string-tag":"node_modules/core-js/modules/_set-to-string-tag.js","./_hide":"node_modules/core-js/modules/_hide.js","./_wks":"node_modules/core-js/modules/_wks.js"}],"node_modules/core-js/modules/_iter-define.js":[function(require,module,exports) {
'use strict';
var LIBRARY = require('./_library');
var $export = require('./_export');
var redefine = require('./_redefine');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var $iterCreate = require('./_iter-create');
var setToStringTag = require('./_set-to-string-tag');
var getPrototypeOf = require('./_object-gpo');
var ITERATOR = require('./_wks')('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

},{"./_library":"node_modules/core-js/modules/_library.js","./_export":"node_modules/core-js/modules/_export.js","./_redefine":"node_modules/core-js/modules/_redefine.js","./_hide":"node_modules/core-js/modules/_hide.js","./_iterators":"node_modules/core-js/modules/_iterators.js","./_iter-create":"node_modules/core-js/modules/_iter-create.js","./_set-to-string-tag":"node_modules/core-js/modules/_set-to-string-tag.js","./_object-gpo":"node_modules/core-js/modules/_object-gpo.js","./_wks":"node_modules/core-js/modules/_wks.js"}],"node_modules/core-js/modules/es6.string.iterator.js":[function(require,module,exports) {
'use strict';
var $at = require('./_string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./_iter-define')(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});

},{"./_string-at":"node_modules/core-js/modules/_string-at.js","./_iter-define":"node_modules/core-js/modules/_iter-define.js"}],"node_modules/core-js/modules/es6.string.code-point-at.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $at = require('./_string-at')(false);
$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos) {
    return $at(this, pos);
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_string-at":"node_modules/core-js/modules/_string-at.js"}],"node_modules/core-js/modules/_is-regexp.js":[function(require,module,exports) {
// 7.2.8 IsRegExp(argument)
var isObject = require('./_is-object');
var cof = require('./_cof');
var MATCH = require('./_wks')('match');
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};

},{"./_is-object":"node_modules/core-js/modules/_is-object.js","./_cof":"node_modules/core-js/modules/_cof.js","./_wks":"node_modules/core-js/modules/_wks.js"}],"node_modules/core-js/modules/_string-context.js":[function(require,module,exports) {
// helper for String#{startsWith, endsWith, includes}
var isRegExp = require('./_is-regexp');
var defined = require('./_defined');

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};

},{"./_is-regexp":"node_modules/core-js/modules/_is-regexp.js","./_defined":"node_modules/core-js/modules/_defined.js"}],"node_modules/core-js/modules/_fails-is-regexp.js":[function(require,module,exports) {
var MATCH = require('./_wks')('match');
module.exports = function (KEY) {
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) { /* empty */ }
  } return true;
};

},{"./_wks":"node_modules/core-js/modules/_wks.js"}],"node_modules/core-js/modules/es6.string.ends-with.js":[function(require,module,exports) {
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
'use strict';
var $export = require('./_export');
var toLength = require('./_to-length');
var context = require('./_string-context');
var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];

$export($export.P + $export.F * require('./_fails-is-regexp')(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString /* , endPosition = @length */) {
    var that = context(this, searchString, ENDS_WITH);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    var search = String(searchString);
    return $endsWith
      ? $endsWith.call(that, search, end)
      : that.slice(end - search.length, end) === search;
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_to-length":"node_modules/core-js/modules/_to-length.js","./_string-context":"node_modules/core-js/modules/_string-context.js","./_fails-is-regexp":"node_modules/core-js/modules/_fails-is-regexp.js"}],"node_modules/core-js/modules/es6.string.includes.js":[function(require,module,exports) {
// 21.1.3.7 String.prototype.includes(searchString, position = 0)
'use strict';
var $export = require('./_export');
var context = require('./_string-context');
var INCLUDES = 'includes';

$export($export.P + $export.F * require('./_fails-is-regexp')(INCLUDES), 'String', {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~context(this, searchString, INCLUDES)
      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_string-context":"node_modules/core-js/modules/_string-context.js","./_fails-is-regexp":"node_modules/core-js/modules/_fails-is-regexp.js"}],"node_modules/core-js/modules/es6.string.repeat.js":[function(require,module,exports) {
var $export = require('./_export');

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: require('./_string-repeat')
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_string-repeat":"node_modules/core-js/modules/_string-repeat.js"}],"node_modules/core-js/modules/es6.string.starts-with.js":[function(require,module,exports) {
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])
'use strict';
var $export = require('./_export');
var toLength = require('./_to-length');
var context = require('./_string-context');
var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];

$export($export.P + $export.F * require('./_fails-is-regexp')(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = context(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith
      ? $startsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search;
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_to-length":"node_modules/core-js/modules/_to-length.js","./_string-context":"node_modules/core-js/modules/_string-context.js","./_fails-is-regexp":"node_modules/core-js/modules/_fails-is-regexp.js"}],"node_modules/core-js/modules/_string-html.js":[function(require,module,exports) {
var $export = require('./_export');
var fails = require('./_fails');
var defined = require('./_defined');
var quot = /"/g;
// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
var createHTML = function (string, tag, attribute, value) {
  var S = String(defined(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};
module.exports = function (NAME, exec) {
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function () {
    var test = ''[NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};

},{"./_export":"node_modules/core-js/modules/_export.js","./_fails":"node_modules/core-js/modules/_fails.js","./_defined":"node_modules/core-js/modules/_defined.js"}],"node_modules/core-js/modules/es6.string.anchor.js":[function(require,module,exports) {
'use strict';
// B.2.3.2 String.prototype.anchor(name)
require('./_string-html')('anchor', function (createHTML) {
  return function anchor(name) {
    return createHTML(this, 'a', 'name', name);
  };
});

},{"./_string-html":"node_modules/core-js/modules/_string-html.js"}],"node_modules/core-js/modules/es6.string.big.js":[function(require,module,exports) {
'use strict';
// B.2.3.3 String.prototype.big()
require('./_string-html')('big', function (createHTML) {
  return function big() {
    return createHTML(this, 'big', '', '');
  };
});

},{"./_string-html":"node_modules/core-js/modules/_string-html.js"}],"node_modules/core-js/modules/es6.string.blink.js":[function(require,module,exports) {
'use strict';
// B.2.3.4 String.prototype.blink()
require('./_string-html')('blink', function (createHTML) {
  return function blink() {
    return createHTML(this, 'blink', '', '');
  };
});

},{"./_string-html":"node_modules/core-js/modules/_string-html.js"}],"node_modules/core-js/modules/es6.string.bold.js":[function(require,module,exports) {
'use strict';
// B.2.3.5 String.prototype.bold()
require('./_string-html')('bold', function (createHTML) {
  return function bold() {
    return createHTML(this, 'b', '', '');
  };
});

},{"./_string-html":"node_modules/core-js/modules/_string-html.js"}],"node_modules/core-js/modules/es6.string.fixed.js":[function(require,module,exports) {
'use strict';
// B.2.3.6 String.prototype.fixed()
require('./_string-html')('fixed', function (createHTML) {
  return function fixed() {
    return createHTML(this, 'tt', '', '');
  };
});

},{"./_string-html":"node_modules/core-js/modules/_string-html.js"}],"node_modules/core-js/modules/es6.string.fontcolor.js":[function(require,module,exports) {
'use strict';
// B.2.3.7 String.prototype.fontcolor(color)
require('./_string-html')('fontcolor', function (createHTML) {
  return function fontcolor(color) {
    return createHTML(this, 'font', 'color', color);
  };
});

},{"./_string-html":"node_modules/core-js/modules/_string-html.js"}],"node_modules/core-js/modules/es6.string.fontsize.js":[function(require,module,exports) {
'use strict';
// B.2.3.8 String.prototype.fontsize(size)
require('./_string-html')('fontsize', function (createHTML) {
  return function fontsize(size) {
    return createHTML(this, 'font', 'size', size);
  };
});

},{"./_string-html":"node_modules/core-js/modules/_string-html.js"}],"node_modules/core-js/modules/es6.string.italics.js":[function(require,module,exports) {
'use strict';
// B.2.3.9 String.prototype.italics()
require('./_string-html')('italics', function (createHTML) {
  return function italics() {
    return createHTML(this, 'i', '', '');
  };
});

},{"./_string-html":"node_modules/core-js/modules/_string-html.js"}],"node_modules/core-js/modules/es6.string.link.js":[function(require,module,exports) {
'use strict';
// B.2.3.10 String.prototype.link(url)
require('./_string-html')('link', function (createHTML) {
  return function link(url) {
    return createHTML(this, 'a', 'href', url);
  };
});

},{"./_string-html":"node_modules/core-js/modules/_string-html.js"}],"node_modules/core-js/modules/es6.string.small.js":[function(require,module,exports) {
'use strict';
// B.2.3.11 String.prototype.small()
require('./_string-html')('small', function (createHTML) {
  return function small() {
    return createHTML(this, 'small', '', '');
  };
});

},{"./_string-html":"node_modules/core-js/modules/_string-html.js"}],"node_modules/core-js/modules/es6.string.strike.js":[function(require,module,exports) {
'use strict';
// B.2.3.12 String.prototype.strike()
require('./_string-html')('strike', function (createHTML) {
  return function strike() {
    return createHTML(this, 'strike', '', '');
  };
});

},{"./_string-html":"node_modules/core-js/modules/_string-html.js"}],"node_modules/core-js/modules/es6.string.sub.js":[function(require,module,exports) {
'use strict';
// B.2.3.13 String.prototype.sub()
require('./_string-html')('sub', function (createHTML) {
  return function sub() {
    return createHTML(this, 'sub', '', '');
  };
});

},{"./_string-html":"node_modules/core-js/modules/_string-html.js"}],"node_modules/core-js/modules/es6.string.sup.js":[function(require,module,exports) {
'use strict';
// B.2.3.14 String.prototype.sup()
require('./_string-html')('sup', function (createHTML) {
  return function sup() {
    return createHTML(this, 'sup', '', '');
  };
});

},{"./_string-html":"node_modules/core-js/modules/_string-html.js"}],"node_modules/core-js/modules/es6.date.now.js":[function(require,module,exports) {
// 20.3.3.1 / 15.9.4.4 Date.now()
var $export = require('./_export');

$export($export.S, 'Date', { now: function () { return new Date().getTime(); } });

},{"./_export":"node_modules/core-js/modules/_export.js"}],"node_modules/core-js/modules/es6.date.to-json.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var toPrimitive = require('./_to-primitive');

$export($export.P + $export.F * require('./_fails')(function () {
  return new Date(NaN).toJSON() !== null
    || Date.prototype.toJSON.call({ toISOString: function () { return 1; } }) !== 1;
}), 'Date', {
  // eslint-disable-next-line no-unused-vars
  toJSON: function toJSON(key) {
    var O = toObject(this);
    var pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_to-object":"node_modules/core-js/modules/_to-object.js","./_to-primitive":"node_modules/core-js/modules/_to-primitive.js","./_fails":"node_modules/core-js/modules/_fails.js"}],"node_modules/core-js/modules/_date-to-iso-string.js":[function(require,module,exports) {
'use strict';
// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var fails = require('./_fails');
var getTime = Date.prototype.getTime;
var $toISOString = Date.prototype.toISOString;

var lz = function (num) {
  return num > 9 ? num : '0' + num;
};

// PhantomJS / old WebKit has a broken implementations
module.exports = (fails(function () {
  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
}) || !fails(function () {
  $toISOString.call(new Date(NaN));
})) ? function toISOString() {
  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
  var d = this;
  var y = d.getUTCFullYear();
  var m = d.getUTCMilliseconds();
  var s = y < 0 ? '-' : y > 9999 ? '+' : '';
  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
    '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
    'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
    ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
} : $toISOString;

},{"./_fails":"node_modules/core-js/modules/_fails.js"}],"node_modules/core-js/modules/es6.date.to-iso-string.js":[function(require,module,exports) {
// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var $export = require('./_export');
var toISOString = require('./_date-to-iso-string');

// PhantomJS / old WebKit has a broken implementations
$export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), 'Date', {
  toISOString: toISOString
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_date-to-iso-string":"node_modules/core-js/modules/_date-to-iso-string.js"}],"node_modules/core-js/modules/es6.date.to-string.js":[function(require,module,exports) {
var DateProto = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var $toString = DateProto[TO_STRING];
var getTime = DateProto.getTime;
if (new Date(NaN) + '' != INVALID_DATE) {
  require('./_redefine')(DateProto, TO_STRING, function toString() {
    var value = getTime.call(this);
    // eslint-disable-next-line no-self-compare
    return value === value ? $toString.call(this) : INVALID_DATE;
  });
}

},{"./_redefine":"node_modules/core-js/modules/_redefine.js"}],"node_modules/core-js/modules/_date-to-primitive.js":[function(require,module,exports) {
'use strict';
var anObject = require('./_an-object');
var toPrimitive = require('./_to-primitive');
var NUMBER = 'number';

module.exports = function (hint) {
  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
  return toPrimitive(anObject(this), hint != NUMBER);
};

},{"./_an-object":"node_modules/core-js/modules/_an-object.js","./_to-primitive":"node_modules/core-js/modules/_to-primitive.js"}],"node_modules/core-js/modules/es6.date.to-primitive.js":[function(require,module,exports) {
var TO_PRIMITIVE = require('./_wks')('toPrimitive');
var proto = Date.prototype;

if (!(TO_PRIMITIVE in proto)) require('./_hide')(proto, TO_PRIMITIVE, require('./_date-to-primitive'));

},{"./_wks":"node_modules/core-js/modules/_wks.js","./_hide":"node_modules/core-js/modules/_hide.js","./_date-to-primitive":"node_modules/core-js/modules/_date-to-primitive.js"}],"node_modules/core-js/modules/es6.array.is-array.js":[function(require,module,exports) {
// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = require('./_export');

$export($export.S, 'Array', { isArray: require('./_is-array') });

},{"./_export":"node_modules/core-js/modules/_export.js","./_is-array":"node_modules/core-js/modules/_is-array.js"}],"node_modules/core-js/modules/_iter-call.js":[function(require,module,exports) {
// call something on iterator step with safe closing on error
var anObject = require('./_an-object');
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};

},{"./_an-object":"node_modules/core-js/modules/_an-object.js"}],"node_modules/core-js/modules/_is-array-iter.js":[function(require,module,exports) {
// check on default Array iterator
var Iterators = require('./_iterators');
var ITERATOR = require('./_wks')('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

},{"./_iterators":"node_modules/core-js/modules/_iterators.js","./_wks":"node_modules/core-js/modules/_wks.js"}],"node_modules/core-js/modules/_create-property.js":[function(require,module,exports) {
'use strict';
var $defineProperty = require('./_object-dp');
var createDesc = require('./_property-desc');

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};

},{"./_object-dp":"node_modules/core-js/modules/_object-dp.js","./_property-desc":"node_modules/core-js/modules/_property-desc.js"}],"node_modules/core-js/modules/core.get-iterator-method.js":[function(require,module,exports) {
var classof = require('./_classof');
var ITERATOR = require('./_wks')('iterator');
var Iterators = require('./_iterators');
module.exports = require('./_core').getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};

},{"./_classof":"node_modules/core-js/modules/_classof.js","./_wks":"node_modules/core-js/modules/_wks.js","./_iterators":"node_modules/core-js/modules/_iterators.js","./_core":"node_modules/core-js/modules/_core.js"}],"node_modules/core-js/modules/_iter-detect.js":[function(require,module,exports) {
var ITERATOR = require('./_wks')('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};

},{"./_wks":"node_modules/core-js/modules/_wks.js"}],"node_modules/core-js/modules/es6.array.from.js":[function(require,module,exports) {
'use strict';
var ctx = require('./_ctx');
var $export = require('./_export');
var toObject = require('./_to-object');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var toLength = require('./_to-length');
var createProperty = require('./_create-property');
var getIterFn = require('./core.get-iterator-method');

$export($export.S + $export.F * !require('./_iter-detect')(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});

},{"./_ctx":"node_modules/core-js/modules/_ctx.js","./_export":"node_modules/core-js/modules/_export.js","./_to-object":"node_modules/core-js/modules/_to-object.js","./_iter-call":"node_modules/core-js/modules/_iter-call.js","./_is-array-iter":"node_modules/core-js/modules/_is-array-iter.js","./_to-length":"node_modules/core-js/modules/_to-length.js","./_create-property":"node_modules/core-js/modules/_create-property.js","./core.get-iterator-method":"node_modules/core-js/modules/core.get-iterator-method.js","./_iter-detect":"node_modules/core-js/modules/_iter-detect.js"}],"node_modules/core-js/modules/es6.array.of.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var createProperty = require('./_create-property');

// WebKit Array.of isn't generic
$export($export.S + $export.F * require('./_fails')(function () {
  function F() { /* empty */ }
  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of(/* ...args */) {
    var index = 0;
    var aLen = arguments.length;
    var result = new (typeof this == 'function' ? this : Array)(aLen);
    while (aLen > index) createProperty(result, index, arguments[index++]);
    result.length = aLen;
    return result;
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_create-property":"node_modules/core-js/modules/_create-property.js","./_fails":"node_modules/core-js/modules/_fails.js"}],"node_modules/core-js/modules/_strict-method.js":[function(require,module,exports) {
'use strict';
var fails = require('./_fails');

module.exports = function (method, arg) {
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call
    arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);
  });
};

},{"./_fails":"node_modules/core-js/modules/_fails.js"}],"node_modules/core-js/modules/es6.array.join.js":[function(require,module,exports) {
'use strict';
// 22.1.3.13 Array.prototype.join(separator)
var $export = require('./_export');
var toIObject = require('./_to-iobject');
var arrayJoin = [].join;

// fallback for not array-like strings
$export($export.P + $export.F * (require('./_iobject') != Object || !require('./_strict-method')(arrayJoin)), 'Array', {
  join: function join(separator) {
    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_to-iobject":"node_modules/core-js/modules/_to-iobject.js","./_iobject":"node_modules/core-js/modules/_iobject.js","./_strict-method":"node_modules/core-js/modules/_strict-method.js"}],"node_modules/core-js/modules/es6.array.slice.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var html = require('./_html');
var cof = require('./_cof');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
var arraySlice = [].slice;

// fallback for not array-like ES3 strings and DOM objects
$export($export.P + $export.F * require('./_fails')(function () {
  if (html) arraySlice.call(html);
}), 'Array', {
  slice: function slice(begin, end) {
    var len = toLength(this.length);
    var klass = cof(this);
    end = end === undefined ? len : end;
    if (klass == 'Array') return arraySlice.call(this, begin, end);
    var start = toAbsoluteIndex(begin, len);
    var upTo = toAbsoluteIndex(end, len);
    var size = toLength(upTo - start);
    var cloned = new Array(size);
    var i = 0;
    for (; i < size; i++) cloned[i] = klass == 'String'
      ? this.charAt(start + i)
      : this[start + i];
    return cloned;
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_html":"node_modules/core-js/modules/_html.js","./_cof":"node_modules/core-js/modules/_cof.js","./_to-absolute-index":"node_modules/core-js/modules/_to-absolute-index.js","./_to-length":"node_modules/core-js/modules/_to-length.js","./_fails":"node_modules/core-js/modules/_fails.js"}],"node_modules/core-js/modules/es6.array.sort.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var aFunction = require('./_a-function');
var toObject = require('./_to-object');
var fails = require('./_fails');
var $sort = [].sort;
var test = [1, 2, 3];

$export($export.P + $export.F * (fails(function () {
  // IE8-
  test.sort(undefined);
}) || !fails(function () {
  // V8 bug
  test.sort(null);
  // Old WebKit
}) || !require('./_strict-method')($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn) {
    return comparefn === undefined
      ? $sort.call(toObject(this))
      : $sort.call(toObject(this), aFunction(comparefn));
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_a-function":"node_modules/core-js/modules/_a-function.js","./_to-object":"node_modules/core-js/modules/_to-object.js","./_fails":"node_modules/core-js/modules/_fails.js","./_strict-method":"node_modules/core-js/modules/_strict-method.js"}],"node_modules/core-js/modules/_array-species-constructor.js":[function(require,module,exports) {
var isObject = require('./_is-object');
var isArray = require('./_is-array');
var SPECIES = require('./_wks')('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};

},{"./_is-object":"node_modules/core-js/modules/_is-object.js","./_is-array":"node_modules/core-js/modules/_is-array.js","./_wks":"node_modules/core-js/modules/_wks.js"}],"node_modules/core-js/modules/_array-species-create.js":[function(require,module,exports) {
// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = require('./_array-species-constructor');

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};

},{"./_array-species-constructor":"node_modules/core-js/modules/_array-species-constructor.js"}],"node_modules/core-js/modules/_array-methods.js":[function(require,module,exports) {
// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = require('./_ctx');
var IObject = require('./_iobject');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var asc = require('./_array-species-create');
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

},{"./_ctx":"node_modules/core-js/modules/_ctx.js","./_iobject":"node_modules/core-js/modules/_iobject.js","./_to-object":"node_modules/core-js/modules/_to-object.js","./_to-length":"node_modules/core-js/modules/_to-length.js","./_array-species-create":"node_modules/core-js/modules/_array-species-create.js"}],"node_modules/core-js/modules/es6.array.for-each.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $forEach = require('./_array-methods')(0);
var STRICT = require('./_strict-method')([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn /* , thisArg */) {
    return $forEach(this, callbackfn, arguments[1]);
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_array-methods":"node_modules/core-js/modules/_array-methods.js","./_strict-method":"node_modules/core-js/modules/_strict-method.js"}],"node_modules/core-js/modules/es6.array.map.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $map = require('./_array-methods')(1);

$export($export.P + $export.F * !require('./_strict-method')([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments[1]);
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_array-methods":"node_modules/core-js/modules/_array-methods.js","./_strict-method":"node_modules/core-js/modules/_strict-method.js"}],"node_modules/core-js/modules/es6.array.filter.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $filter = require('./_array-methods')(2);

$export($export.P + $export.F * !require('./_strict-method')([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments[1]);
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_array-methods":"node_modules/core-js/modules/_array-methods.js","./_strict-method":"node_modules/core-js/modules/_strict-method.js"}],"node_modules/core-js/modules/es6.array.some.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $some = require('./_array-methods')(3);

$export($export.P + $export.F * !require('./_strict-method')([].some, true), 'Array', {
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn /* , thisArg */) {
    return $some(this, callbackfn, arguments[1]);
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_array-methods":"node_modules/core-js/modules/_array-methods.js","./_strict-method":"node_modules/core-js/modules/_strict-method.js"}],"node_modules/core-js/modules/es6.array.every.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $every = require('./_array-methods')(4);

$export($export.P + $export.F * !require('./_strict-method')([].every, true), 'Array', {
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: function every(callbackfn /* , thisArg */) {
    return $every(this, callbackfn, arguments[1]);
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_array-methods":"node_modules/core-js/modules/_array-methods.js","./_strict-method":"node_modules/core-js/modules/_strict-method.js"}],"node_modules/core-js/modules/_array-reduce.js":[function(require,module,exports) {
var aFunction = require('./_a-function');
var toObject = require('./_to-object');
var IObject = require('./_iobject');
var toLength = require('./_to-length');

module.exports = function (that, callbackfn, aLen, memo, isRight) {
  aFunction(callbackfn);
  var O = toObject(that);
  var self = IObject(O);
  var length = toLength(O.length);
  var index = isRight ? length - 1 : 0;
  var i = isRight ? -1 : 1;
  if (aLen < 2) for (;;) {
    if (index in self) {
      memo = self[index];
      index += i;
      break;
    }
    index += i;
    if (isRight ? index < 0 : length <= index) {
      throw TypeError('Reduce of empty array with no initial value');
    }
  }
  for (;isRight ? index >= 0 : length > index; index += i) if (index in self) {
    memo = callbackfn(memo, self[index], index, O);
  }
  return memo;
};

},{"./_a-function":"node_modules/core-js/modules/_a-function.js","./_to-object":"node_modules/core-js/modules/_to-object.js","./_iobject":"node_modules/core-js/modules/_iobject.js","./_to-length":"node_modules/core-js/modules/_to-length.js"}],"node_modules/core-js/modules/es6.array.reduce.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $reduce = require('./_array-reduce');

$export($export.P + $export.F * !require('./_strict-method')([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_array-reduce":"node_modules/core-js/modules/_array-reduce.js","./_strict-method":"node_modules/core-js/modules/_strict-method.js"}],"node_modules/core-js/modules/es6.array.reduce-right.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $reduce = require('./_array-reduce');

$export($export.P + $export.F * !require('./_strict-method')([].reduceRight, true), 'Array', {
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: function reduceRight(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_array-reduce":"node_modules/core-js/modules/_array-reduce.js","./_strict-method":"node_modules/core-js/modules/_strict-method.js"}],"node_modules/core-js/modules/es6.array.index-of.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $indexOf = require('./_array-includes')(false);
var $native = [].indexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !require('./_strict-method')($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? $native.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments[1]);
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_array-includes":"node_modules/core-js/modules/_array-includes.js","./_strict-method":"node_modules/core-js/modules/_strict-method.js"}],"node_modules/core-js/modules/es6.array.last-index-of.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var toIObject = require('./_to-iobject');
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
var $native = [].lastIndexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !require('./_strict-method')($native)), 'Array', {
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
    // convert -0 to +0
    if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
    var O = toIObject(this);
    var length = toLength(O.length);
    var index = length - 1;
    if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
    if (index < 0) index = length + index;
    for (;index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0;
    return -1;
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_to-iobject":"node_modules/core-js/modules/_to-iobject.js","./_to-integer":"node_modules/core-js/modules/_to-integer.js","./_to-length":"node_modules/core-js/modules/_to-length.js","./_strict-method":"node_modules/core-js/modules/_strict-method.js"}],"node_modules/core-js/modules/_array-copy-within.js":[function(require,module,exports) {
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
'use strict';
var toObject = require('./_to-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');

module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else delete O[to];
    to += inc;
    from += inc;
  } return O;
};

},{"./_to-object":"node_modules/core-js/modules/_to-object.js","./_to-absolute-index":"node_modules/core-js/modules/_to-absolute-index.js","./_to-length":"node_modules/core-js/modules/_to-length.js"}],"node_modules/core-js/modules/_add-to-unscopables.js":[function(require,module,exports) {
// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = require('./_wks')('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) require('./_hide')(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};

},{"./_wks":"node_modules/core-js/modules/_wks.js","./_hide":"node_modules/core-js/modules/_hide.js"}],"node_modules/core-js/modules/es6.array.copy-within.js":[function(require,module,exports) {
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = require('./_export');

$export($export.P, 'Array', { copyWithin: require('./_array-copy-within') });

require('./_add-to-unscopables')('copyWithin');

},{"./_export":"node_modules/core-js/modules/_export.js","./_array-copy-within":"node_modules/core-js/modules/_array-copy-within.js","./_add-to-unscopables":"node_modules/core-js/modules/_add-to-unscopables.js"}],"node_modules/core-js/modules/_array-fill.js":[function(require,module,exports) {
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
'use strict';
var toObject = require('./_to-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};

},{"./_to-object":"node_modules/core-js/modules/_to-object.js","./_to-absolute-index":"node_modules/core-js/modules/_to-absolute-index.js","./_to-length":"node_modules/core-js/modules/_to-length.js"}],"node_modules/core-js/modules/es6.array.fill.js":[function(require,module,exports) {
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = require('./_export');

$export($export.P, 'Array', { fill: require('./_array-fill') });

require('./_add-to-unscopables')('fill');

},{"./_export":"node_modules/core-js/modules/_export.js","./_array-fill":"node_modules/core-js/modules/_array-fill.js","./_add-to-unscopables":"node_modules/core-js/modules/_add-to-unscopables.js"}],"node_modules/core-js/modules/es6.array.find.js":[function(require,module,exports) {
'use strict';
// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = require('./_export');
var $find = require('./_array-methods')(5);
var KEY = 'find';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
require('./_add-to-unscopables')(KEY);

},{"./_export":"node_modules/core-js/modules/_export.js","./_array-methods":"node_modules/core-js/modules/_array-methods.js","./_add-to-unscopables":"node_modules/core-js/modules/_add-to-unscopables.js"}],"node_modules/core-js/modules/es6.array.find-index.js":[function(require,module,exports) {
'use strict';
// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var $export = require('./_export');
var $find = require('./_array-methods')(6);
var KEY = 'findIndex';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
require('./_add-to-unscopables')(KEY);

},{"./_export":"node_modules/core-js/modules/_export.js","./_array-methods":"node_modules/core-js/modules/_array-methods.js","./_add-to-unscopables":"node_modules/core-js/modules/_add-to-unscopables.js"}],"node_modules/core-js/modules/_set-species.js":[function(require,module,exports) {

'use strict';
var global = require('./_global');
var dP = require('./_object-dp');
var DESCRIPTORS = require('./_descriptors');
var SPECIES = require('./_wks')('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};

},{"./_global":"node_modules/core-js/modules/_global.js","./_object-dp":"node_modules/core-js/modules/_object-dp.js","./_descriptors":"node_modules/core-js/modules/_descriptors.js","./_wks":"node_modules/core-js/modules/_wks.js"}],"node_modules/core-js/modules/es6.array.species.js":[function(require,module,exports) {
require('./_set-species')('Array');

},{"./_set-species":"node_modules/core-js/modules/_set-species.js"}],"node_modules/core-js/modules/_iter-step.js":[function(require,module,exports) {
module.exports = function (done, value) {
  return { value: value, done: !!done };
};

},{}],"node_modules/core-js/modules/es6.array.iterator.js":[function(require,module,exports) {
'use strict';
var addToUnscopables = require('./_add-to-unscopables');
var step = require('./_iter-step');
var Iterators = require('./_iterators');
var toIObject = require('./_to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = require('./_iter-define')(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

},{"./_add-to-unscopables":"node_modules/core-js/modules/_add-to-unscopables.js","./_iter-step":"node_modules/core-js/modules/_iter-step.js","./_iterators":"node_modules/core-js/modules/_iterators.js","./_to-iobject":"node_modules/core-js/modules/_to-iobject.js","./_iter-define":"node_modules/core-js/modules/_iter-define.js"}],"node_modules/core-js/modules/_flags.js":[function(require,module,exports) {
'use strict';
// 21.2.5.3 get RegExp.prototype.flags
var anObject = require('./_an-object');
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};

},{"./_an-object":"node_modules/core-js/modules/_an-object.js"}],"node_modules/core-js/modules/es6.regexp.constructor.js":[function(require,module,exports) {

var global = require('./_global');
var inheritIfRequired = require('./_inherit-if-required');
var dP = require('./_object-dp').f;
var gOPN = require('./_object-gopn').f;
var isRegExp = require('./_is-regexp');
var $flags = require('./_flags');
var $RegExp = global.RegExp;
var Base = $RegExp;
var proto = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;
// "new" creates a new object, old webkit buggy here
var CORRECT_NEW = new $RegExp(re1) !== re1;

if (require('./_descriptors') && (!CORRECT_NEW || require('./_fails')(function () {
  re2[require('./_wks')('match')] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
  $RegExp = function RegExp(p, f) {
    var tiRE = this instanceof $RegExp;
    var piRE = isRegExp(p);
    var fiU = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
      : inheritIfRequired(CORRECT_NEW
        ? new Base(piRE && !fiU ? p.source : p, f)
        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
      , tiRE ? this : proto, $RegExp);
  };
  var proxy = function (key) {
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function () { return Base[key]; },
      set: function (it) { Base[key] = it; }
    });
  };
  for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);
  proto.constructor = $RegExp;
  $RegExp.prototype = proto;
  require('./_redefine')(global, 'RegExp', $RegExp);
}

require('./_set-species')('RegExp');

},{"./_global":"node_modules/core-js/modules/_global.js","./_inherit-if-required":"node_modules/core-js/modules/_inherit-if-required.js","./_object-dp":"node_modules/core-js/modules/_object-dp.js","./_object-gopn":"node_modules/core-js/modules/_object-gopn.js","./_is-regexp":"node_modules/core-js/modules/_is-regexp.js","./_flags":"node_modules/core-js/modules/_flags.js","./_descriptors":"node_modules/core-js/modules/_descriptors.js","./_fails":"node_modules/core-js/modules/_fails.js","./_wks":"node_modules/core-js/modules/_wks.js","./_redefine":"node_modules/core-js/modules/_redefine.js","./_set-species":"node_modules/core-js/modules/_set-species.js"}],"node_modules/core-js/modules/_regexp-exec.js":[function(require,module,exports) {
'use strict';

var regexpFlags = require('./_flags');

var nativeExec = RegExp.prototype.exec;
// This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.
var nativeReplace = String.prototype.replace;

var patchedExec = nativeExec;

var LAST_INDEX = 'lastIndex';

var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/,
      re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
})();

// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re));
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];

    match = nativeExec.call(re, str);

    if (UPDATES_LAST_INDEX_WRONG && match) {
      re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      // eslint-disable-next-line no-loop-func
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

module.exports = patchedExec;

},{"./_flags":"node_modules/core-js/modules/_flags.js"}],"node_modules/core-js/modules/es6.regexp.exec.js":[function(require,module,exports) {
'use strict';
var regexpExec = require('./_regexp-exec');
require('./_export')({
  target: 'RegExp',
  proto: true,
  forced: regexpExec !== /./.exec
}, {
  exec: regexpExec
});

},{"./_regexp-exec":"node_modules/core-js/modules/_regexp-exec.js","./_export":"node_modules/core-js/modules/_export.js"}],"node_modules/core-js/modules/es6.regexp.flags.js":[function(require,module,exports) {
// 21.2.5.3 get RegExp.prototype.flags()
if (require('./_descriptors') && /./g.flags != 'g') require('./_object-dp').f(RegExp.prototype, 'flags', {
  configurable: true,
  get: require('./_flags')
});

},{"./_descriptors":"node_modules/core-js/modules/_descriptors.js","./_object-dp":"node_modules/core-js/modules/_object-dp.js","./_flags":"node_modules/core-js/modules/_flags.js"}],"node_modules/core-js/modules/es6.regexp.to-string.js":[function(require,module,exports) {

'use strict';
require('./es6.regexp.flags');
var anObject = require('./_an-object');
var $flags = require('./_flags');
var DESCRIPTORS = require('./_descriptors');
var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function (fn) {
  require('./_redefine')(RegExp.prototype, TO_STRING, fn, true);
};

// 21.2.5.14 RegExp.prototype.toString()
if (require('./_fails')(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {
  define(function toString() {
    var R = anObject(this);
    return '/'.concat(R.source, '/',
      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  });
// FF44- RegExp#toString has a wrong name
} else if ($toString.name != TO_STRING) {
  define(function toString() {
    return $toString.call(this);
  });
}

},{"./es6.regexp.flags":"node_modules/core-js/modules/es6.regexp.flags.js","./_an-object":"node_modules/core-js/modules/_an-object.js","./_flags":"node_modules/core-js/modules/_flags.js","./_descriptors":"node_modules/core-js/modules/_descriptors.js","./_redefine":"node_modules/core-js/modules/_redefine.js","./_fails":"node_modules/core-js/modules/_fails.js"}],"node_modules/core-js/modules/_advance-string-index.js":[function(require,module,exports) {
'use strict';
var at = require('./_string-at')(true);

 // `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex
module.exports = function (S, index, unicode) {
  return index + (unicode ? at(S, index).length : 1);
};

},{"./_string-at":"node_modules/core-js/modules/_string-at.js"}],"node_modules/core-js/modules/_regexp-exec-abstract.js":[function(require,module,exports) {
'use strict';

var classof = require('./_classof');
var builtinExec = RegExp.prototype.exec;

 // `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec
module.exports = function (R, S) {
  var exec = R.exec;
  if (typeof exec === 'function') {
    var result = exec.call(R, S);
    if (typeof result !== 'object') {
      throw new TypeError('RegExp exec method returned something other than an Object or null');
    }
    return result;
  }
  if (classof(R) !== 'RegExp') {
    throw new TypeError('RegExp#exec called on incompatible receiver');
  }
  return builtinExec.call(R, S);
};

},{"./_classof":"node_modules/core-js/modules/_classof.js"}],"node_modules/core-js/modules/_fix-re-wks.js":[function(require,module,exports) {
'use strict';
require('./es6.regexp.exec');
var redefine = require('./_redefine');
var hide = require('./_hide');
var fails = require('./_fails');
var defined = require('./_defined');
var wks = require('./_wks');
var regexpExec = require('./_regexp-exec');

var SPECIES = wks('species');

var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  return ''.replace(re, '$<a>') !== '7';
});

var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = (function () {
  // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function () { return originalExec.apply(this, arguments); };
  var result = 'ab'.split(re);
  return result.length === 2 && result[0] === 'a' && result[1] === 'b';
})();

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);

  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;
    re.exec = function () { execCalled = true; return null; };
    if (KEY === 'split') {
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES] = function () { return re; };
    }
    re[SYMBOL]('');
    return !execCalled;
  }) : undefined;

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) ||
    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
  ) {
    var nativeRegExpMethod = /./[SYMBOL];
    var fns = exec(
      defined,
      SYMBOL,
      ''[KEY],
      function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
        if (regexp.exec === regexpExec) {
          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
            // The native String method already delegates to @@method (this
            // polyfilled function), leasing to infinite recursion.
            // We avoid it by directly calling the native @@method method.
            return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
          }
          return { done: true, value: nativeMethod.call(str, regexp, arg2) };
        }
        return { done: false };
      }
    );
    var strfn = fns[0];
    var rxfn = fns[1];

    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return rxfn.call(string, this); }
    );
  }
};

},{"./es6.regexp.exec":"node_modules/core-js/modules/es6.regexp.exec.js","./_redefine":"node_modules/core-js/modules/_redefine.js","./_hide":"node_modules/core-js/modules/_hide.js","./_fails":"node_modules/core-js/modules/_fails.js","./_defined":"node_modules/core-js/modules/_defined.js","./_wks":"node_modules/core-js/modules/_wks.js","./_regexp-exec":"node_modules/core-js/modules/_regexp-exec.js"}],"node_modules/core-js/modules/es6.regexp.match.js":[function(require,module,exports) {
'use strict';

var anObject = require('./_an-object');
var toLength = require('./_to-length');
var advanceStringIndex = require('./_advance-string-index');
var regExpExec = require('./_regexp-exec-abstract');

// @@match logic
require('./_fix-re-wks')('match', 1, function (defined, MATCH, $match, maybeCallNative) {
  return [
    // `String.prototype.match` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.match
    function match(regexp) {
      var O = defined(this);
      var fn = regexp == undefined ? undefined : regexp[MATCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
    },
    // `RegExp.prototype[@@match]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
    function (regexp) {
      var res = maybeCallNative($match, regexp, this);
      if (res.done) return res.value;
      var rx = anObject(regexp);
      var S = String(this);
      if (!rx.global) return regExpExec(rx, S);
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
      var A = [];
      var n = 0;
      var result;
      while ((result = regExpExec(rx, S)) !== null) {
        var matchStr = String(result[0]);
        A[n] = matchStr;
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
        n++;
      }
      return n === 0 ? null : A;
    }
  ];
});

},{"./_an-object":"node_modules/core-js/modules/_an-object.js","./_to-length":"node_modules/core-js/modules/_to-length.js","./_advance-string-index":"node_modules/core-js/modules/_advance-string-index.js","./_regexp-exec-abstract":"node_modules/core-js/modules/_regexp-exec-abstract.js","./_fix-re-wks":"node_modules/core-js/modules/_fix-re-wks.js"}],"node_modules/core-js/modules/es6.regexp.replace.js":[function(require,module,exports) {
var global = arguments[3];
'use strict';

var anObject = require('./_an-object');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var toInteger = require('./_to-integer');
var advanceStringIndex = require('./_advance-string-index');
var regExpExec = require('./_regexp-exec-abstract');
var max = Math.max;
var min = Math.min;
var floor = Math.floor;
var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
};

// @@replace logic
require('./_fix-re-wks')('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {
  return [
    // `String.prototype.replace` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.replace
    function replace(searchValue, replaceValue) {
      var O = defined(this);
      var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
      return fn !== undefined
        ? fn.call(searchValue, O, replaceValue)
        : $replace.call(String(O), searchValue, replaceValue);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
    function (regexp, replaceValue) {
      var res = maybeCallNative($replace, regexp, this, replaceValue);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var functionalReplace = typeof replaceValue === 'function';
      if (!functionalReplace) replaceValue = String(replaceValue);
      var global = rx.global;
      if (global) {
        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }
      var results = [];
      while (true) {
        var result = regExpExec(rx, S);
        if (result === null) break;
        results.push(result);
        if (!global) break;
        var matchStr = String(result[0]);
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      }
      var accumulatedResult = '';
      var nextSourcePosition = 0;
      for (var i = 0; i < results.length; i++) {
        result = results[i];
        var matched = String(result[0]);
        var position = max(min(toInteger(result.index), S.length), 0);
        var captures = [];
        // NOTE: This is equivalent to
        //   captures = result.slice(1).map(maybeToString)
        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
        var namedCaptures = result.groups;
        if (functionalReplace) {
          var replacerArgs = [matched].concat(captures, position, S);
          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
          var replacement = String(replaceValue.apply(undefined, replacerArgs));
        } else {
          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
        }
        if (position >= nextSourcePosition) {
          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
          nextSourcePosition = position + matched.length;
        }
      }
      return accumulatedResult + S.slice(nextSourcePosition);
    }
  ];

    // https://tc39.github.io/ecma262/#sec-getsubstitution
  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
    if (namedCaptures !== undefined) {
      namedCaptures = toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }
    return $replace.call(replacement, symbols, function (match, ch) {
      var capture;
      switch (ch.charAt(0)) {
        case '$': return '$';
        case '&': return matched;
        case '`': return str.slice(0, position);
        case "'": return str.slice(tailPos);
        case '<':
          capture = namedCaptures[ch.slice(1, -1)];
          break;
        default: // \d\d?
          var n = +ch;
          if (n === 0) return match;
          if (n > m) {
            var f = floor(n / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
            return match;
          }
          capture = captures[n - 1];
      }
      return capture === undefined ? '' : capture;
    });
  }
});

},{"./_an-object":"node_modules/core-js/modules/_an-object.js","./_to-object":"node_modules/core-js/modules/_to-object.js","./_to-length":"node_modules/core-js/modules/_to-length.js","./_to-integer":"node_modules/core-js/modules/_to-integer.js","./_advance-string-index":"node_modules/core-js/modules/_advance-string-index.js","./_regexp-exec-abstract":"node_modules/core-js/modules/_regexp-exec-abstract.js","./_fix-re-wks":"node_modules/core-js/modules/_fix-re-wks.js"}],"node_modules/core-js/modules/es6.regexp.search.js":[function(require,module,exports) {
'use strict';

var anObject = require('./_an-object');
var sameValue = require('./_same-value');
var regExpExec = require('./_regexp-exec-abstract');

// @@search logic
require('./_fix-re-wks')('search', 1, function (defined, SEARCH, $search, maybeCallNative) {
  return [
    // `String.prototype.search` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.search
    function search(regexp) {
      var O = defined(this);
      var fn = regexp == undefined ? undefined : regexp[SEARCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
    },
    // `RegExp.prototype[@@search]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
    function (regexp) {
      var res = maybeCallNative($search, regexp, this);
      if (res.done) return res.value;
      var rx = anObject(regexp);
      var S = String(this);
      var previousLastIndex = rx.lastIndex;
      if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
      var result = regExpExec(rx, S);
      if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
      return result === null ? -1 : result.index;
    }
  ];
});

},{"./_an-object":"node_modules/core-js/modules/_an-object.js","./_same-value":"node_modules/core-js/modules/_same-value.js","./_regexp-exec-abstract":"node_modules/core-js/modules/_regexp-exec-abstract.js","./_fix-re-wks":"node_modules/core-js/modules/_fix-re-wks.js"}],"node_modules/core-js/modules/_species-constructor.js":[function(require,module,exports) {
// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = require('./_an-object');
var aFunction = require('./_a-function');
var SPECIES = require('./_wks')('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};

},{"./_an-object":"node_modules/core-js/modules/_an-object.js","./_a-function":"node_modules/core-js/modules/_a-function.js","./_wks":"node_modules/core-js/modules/_wks.js"}],"node_modules/core-js/modules/es6.regexp.split.js":[function(require,module,exports) {
'use strict';

var isRegExp = require('./_is-regexp');
var anObject = require('./_an-object');
var speciesConstructor = require('./_species-constructor');
var advanceStringIndex = require('./_advance-string-index');
var toLength = require('./_to-length');
var callRegExpExec = require('./_regexp-exec-abstract');
var regexpExec = require('./_regexp-exec');
var fails = require('./_fails');
var $min = Math.min;
var $push = [].push;
var $SPLIT = 'split';
var LENGTH = 'length';
var LAST_INDEX = 'lastIndex';
var MAX_UINT32 = 0xffffffff;

// babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
var SUPPORTS_Y = !fails(function () { RegExp(MAX_UINT32, 'y'); });

// @@split logic
require('./_fix-re-wks')('split', 2, function (defined, SPLIT, $split, maybeCallNative) {
  var internalSplit;
  if (
    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
    ''[$SPLIT](/.?/)[LENGTH]
  ) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function (separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return [];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) return $split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? MAX_UINT32 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;
      while (match = regexpExec.call(separatorCopy, string)) {
        lastIndex = separatorCopy[LAST_INDEX];
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }
        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
  // Chakra, V8
  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    internalSplit = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : $split.call(this, separator, limit);
    };
  } else {
    internalSplit = $split;
  }

  return [
    // `String.prototype.split` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.split
    function split(separator, limit) {
      var O = defined(this);
      var splitter = separator == undefined ? undefined : separator[SPLIT];
      return splitter !== undefined
        ? splitter.call(separator, O, limit)
        : internalSplit.call(String(O), separator, limit);
    },
    // `RegExp.prototype[@@split]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
    //
    // NOTE: This cannot be properly polyfilled in engines that don't support
    // the 'y' flag.
    function (regexp, limit) {
      var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== $split);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var C = speciesConstructor(rx, RegExp);

      var unicodeMatching = rx.unicode;
      var flags = (rx.ignoreCase ? 'i' : '') +
                  (rx.multiline ? 'm' : '') +
                  (rx.unicode ? 'u' : '') +
                  (SUPPORTS_Y ? 'y' : 'g');

      // ^(? + rx + ) is needed, in combination with some S slicing, to
      // simulate the 'y' flag.
      var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
      var p = 0;
      var q = 0;
      var A = [];
      while (q < S.length) {
        splitter.lastIndex = SUPPORTS_Y ? q : 0;
        var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
        var e;
        if (
          z === null ||
          (e = $min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p
        ) {
          q = advanceStringIndex(S, q, unicodeMatching);
        } else {
          A.push(S.slice(p, q));
          if (A.length === lim) return A;
          for (var i = 1; i <= z.length - 1; i++) {
            A.push(z[i]);
            if (A.length === lim) return A;
          }
          q = p = e;
        }
      }
      A.push(S.slice(p));
      return A;
    }
  ];
});

},{"./_is-regexp":"node_modules/core-js/modules/_is-regexp.js","./_an-object":"node_modules/core-js/modules/_an-object.js","./_species-constructor":"node_modules/core-js/modules/_species-constructor.js","./_advance-string-index":"node_modules/core-js/modules/_advance-string-index.js","./_to-length":"node_modules/core-js/modules/_to-length.js","./_regexp-exec-abstract":"node_modules/core-js/modules/_regexp-exec-abstract.js","./_regexp-exec":"node_modules/core-js/modules/_regexp-exec.js","./_fails":"node_modules/core-js/modules/_fails.js","./_fix-re-wks":"node_modules/core-js/modules/_fix-re-wks.js"}],"node_modules/core-js/modules/_an-instance.js":[function(require,module,exports) {
module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};

},{}],"node_modules/core-js/modules/_for-of.js":[function(require,module,exports) {
var ctx = require('./_ctx');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var anObject = require('./_an-object');
var toLength = require('./_to-length');
var getIterFn = require('./core.get-iterator-method');
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;

},{"./_ctx":"node_modules/core-js/modules/_ctx.js","./_iter-call":"node_modules/core-js/modules/_iter-call.js","./_is-array-iter":"node_modules/core-js/modules/_is-array-iter.js","./_an-object":"node_modules/core-js/modules/_an-object.js","./_to-length":"node_modules/core-js/modules/_to-length.js","./core.get-iterator-method":"node_modules/core-js/modules/core.get-iterator-method.js"}],"node_modules/core-js/modules/_task.js":[function(require,module,exports) {


var ctx = require('./_ctx');
var invoke = require('./_invoke');
var html = require('./_html');
var cel = require('./_dom-create');
var global = require('./_global');
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (require('./_cof')(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};

},{"./_ctx":"node_modules/core-js/modules/_ctx.js","./_invoke":"node_modules/core-js/modules/_invoke.js","./_html":"node_modules/core-js/modules/_html.js","./_dom-create":"node_modules/core-js/modules/_dom-create.js","./_global":"node_modules/core-js/modules/_global.js","./_cof":"node_modules/core-js/modules/_cof.js"}],"node_modules/core-js/modules/_microtask.js":[function(require,module,exports) {


var global = require('./_global');
var macrotask = require('./_task').set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = require('./_cof')(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};

},{"./_global":"node_modules/core-js/modules/_global.js","./_task":"node_modules/core-js/modules/_task.js","./_cof":"node_modules/core-js/modules/_cof.js"}],"node_modules/core-js/modules/_new-promise-capability.js":[function(require,module,exports) {
'use strict';
// 25.4.1.5 NewPromiseCapability(C)
var aFunction = require('./_a-function');

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};

},{"./_a-function":"node_modules/core-js/modules/_a-function.js"}],"node_modules/core-js/modules/_perform.js":[function(require,module,exports) {
module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};

},{}],"node_modules/core-js/modules/_user-agent.js":[function(require,module,exports) {

var global = require('./_global');
var navigator = global.navigator;

module.exports = navigator && navigator.userAgent || '';

},{"./_global":"node_modules/core-js/modules/_global.js"}],"node_modules/core-js/modules/_promise-resolve.js":[function(require,module,exports) {
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var newPromiseCapability = require('./_new-promise-capability');

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

},{"./_an-object":"node_modules/core-js/modules/_an-object.js","./_is-object":"node_modules/core-js/modules/_is-object.js","./_new-promise-capability":"node_modules/core-js/modules/_new-promise-capability.js"}],"node_modules/core-js/modules/_redefine-all.js":[function(require,module,exports) {
var redefine = require('./_redefine');
module.exports = function (target, src, safe) {
  for (var key in src) redefine(target, key, src[key], safe);
  return target;
};

},{"./_redefine":"node_modules/core-js/modules/_redefine.js"}],"node_modules/core-js/modules/es6.promise.js":[function(require,module,exports) {


'use strict';
var LIBRARY = require('./_library');
var global = require('./_global');
var ctx = require('./_ctx');
var classof = require('./_classof');
var $export = require('./_export');
var isObject = require('./_is-object');
var aFunction = require('./_a-function');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var speciesConstructor = require('./_species-constructor');
var task = require('./_task').set;
var microtask = require('./_microtask')();
var newPromiseCapabilityModule = require('./_new-promise-capability');
var perform = require('./_perform');
var userAgent = require('./_user-agent');
var promiseResolve = require('./_promise-resolve');
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[require('./_wks')('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function')
      && promise.then(empty) instanceof FakePromise
      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // we can't detect it synchronously, so just check versions
      && v8.indexOf('6.6') !== 0
      && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // may throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = require('./_redefine-all')($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
require('./_set-to-string-tag')($Promise, PROMISE);
require('./_set-species')(PROMISE);
Wrapper = require('./_core')[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && require('./_iter-detect')(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});

},{"./_library":"node_modules/core-js/modules/_library.js","./_global":"node_modules/core-js/modules/_global.js","./_ctx":"node_modules/core-js/modules/_ctx.js","./_classof":"node_modules/core-js/modules/_classof.js","./_export":"node_modules/core-js/modules/_export.js","./_is-object":"node_modules/core-js/modules/_is-object.js","./_a-function":"node_modules/core-js/modules/_a-function.js","./_an-instance":"node_modules/core-js/modules/_an-instance.js","./_for-of":"node_modules/core-js/modules/_for-of.js","./_species-constructor":"node_modules/core-js/modules/_species-constructor.js","./_task":"node_modules/core-js/modules/_task.js","./_microtask":"node_modules/core-js/modules/_microtask.js","./_new-promise-capability":"node_modules/core-js/modules/_new-promise-capability.js","./_perform":"node_modules/core-js/modules/_perform.js","./_user-agent":"node_modules/core-js/modules/_user-agent.js","./_promise-resolve":"node_modules/core-js/modules/_promise-resolve.js","./_wks":"node_modules/core-js/modules/_wks.js","./_redefine-all":"node_modules/core-js/modules/_redefine-all.js","./_set-to-string-tag":"node_modules/core-js/modules/_set-to-string-tag.js","./_set-species":"node_modules/core-js/modules/_set-species.js","./_core":"node_modules/core-js/modules/_core.js","./_iter-detect":"node_modules/core-js/modules/_iter-detect.js"}],"node_modules/core-js/modules/_validate-collection.js":[function(require,module,exports) {
var isObject = require('./_is-object');
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};

},{"./_is-object":"node_modules/core-js/modules/_is-object.js"}],"node_modules/core-js/modules/_collection-strong.js":[function(require,module,exports) {
'use strict';
var dP = require('./_object-dp').f;
var create = require('./_object-create');
var redefineAll = require('./_redefine-all');
var ctx = require('./_ctx');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var $iterDefine = require('./_iter-define');
var step = require('./_iter-step');
var setSpecies = require('./_set-species');
var DESCRIPTORS = require('./_descriptors');
var fastKey = require('./_meta').fastKey;
var validate = require('./_validate-collection');
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};

},{"./_object-dp":"node_modules/core-js/modules/_object-dp.js","./_object-create":"node_modules/core-js/modules/_object-create.js","./_redefine-all":"node_modules/core-js/modules/_redefine-all.js","./_ctx":"node_modules/core-js/modules/_ctx.js","./_an-instance":"node_modules/core-js/modules/_an-instance.js","./_for-of":"node_modules/core-js/modules/_for-of.js","./_iter-define":"node_modules/core-js/modules/_iter-define.js","./_iter-step":"node_modules/core-js/modules/_iter-step.js","./_set-species":"node_modules/core-js/modules/_set-species.js","./_descriptors":"node_modules/core-js/modules/_descriptors.js","./_meta":"node_modules/core-js/modules/_meta.js","./_validate-collection":"node_modules/core-js/modules/_validate-collection.js"}],"node_modules/core-js/modules/_collection.js":[function(require,module,exports) {

'use strict';
var global = require('./_global');
var $export = require('./_export');
var redefine = require('./_redefine');
var redefineAll = require('./_redefine-all');
var meta = require('./_meta');
var forOf = require('./_for-of');
var anInstance = require('./_an-instance');
var isObject = require('./_is-object');
var fails = require('./_fails');
var $iterDetect = require('./_iter-detect');
var setToStringTag = require('./_set-to-string-tag');
var inheritIfRequired = require('./_inherit-if-required');

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  var fixMethod = function (KEY) {
    var fn = proto[KEY];
    redefine(proto, KEY,
      KEY == 'delete' ? function (a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a) {
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }
        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  };
  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance = new C();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
    // weak collections should not contains .clear method
    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};

},{"./_global":"node_modules/core-js/modules/_global.js","./_export":"node_modules/core-js/modules/_export.js","./_redefine":"node_modules/core-js/modules/_redefine.js","./_redefine-all":"node_modules/core-js/modules/_redefine-all.js","./_meta":"node_modules/core-js/modules/_meta.js","./_for-of":"node_modules/core-js/modules/_for-of.js","./_an-instance":"node_modules/core-js/modules/_an-instance.js","./_is-object":"node_modules/core-js/modules/_is-object.js","./_fails":"node_modules/core-js/modules/_fails.js","./_iter-detect":"node_modules/core-js/modules/_iter-detect.js","./_set-to-string-tag":"node_modules/core-js/modules/_set-to-string-tag.js","./_inherit-if-required":"node_modules/core-js/modules/_inherit-if-required.js"}],"node_modules/core-js/modules/es6.map.js":[function(require,module,exports) {
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var MAP = 'Map';

// 23.1 Map Objects
module.exports = require('./_collection')(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);

},{"./_collection-strong":"node_modules/core-js/modules/_collection-strong.js","./_validate-collection":"node_modules/core-js/modules/_validate-collection.js","./_collection":"node_modules/core-js/modules/_collection.js"}],"node_modules/core-js/modules/es6.set.js":[function(require,module,exports) {
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var SET = 'Set';

// 23.2 Set Objects
module.exports = require('./_collection')(SET, function (get) {
  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);

},{"./_collection-strong":"node_modules/core-js/modules/_collection-strong.js","./_validate-collection":"node_modules/core-js/modules/_validate-collection.js","./_collection":"node_modules/core-js/modules/_collection.js"}],"node_modules/core-js/modules/_collection-weak.js":[function(require,module,exports) {
'use strict';
var redefineAll = require('./_redefine-all');
var getWeak = require('./_meta').getWeak;
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var createArrayMethod = require('./_array-methods');
var $has = require('./_has');
var validate = require('./_validate-collection');
var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function () {
  this.a = [];
};
var findUncaughtFrozen = function (store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function (key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;      // collection type
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};

},{"./_redefine-all":"node_modules/core-js/modules/_redefine-all.js","./_meta":"node_modules/core-js/modules/_meta.js","./_an-object":"node_modules/core-js/modules/_an-object.js","./_is-object":"node_modules/core-js/modules/_is-object.js","./_an-instance":"node_modules/core-js/modules/_an-instance.js","./_for-of":"node_modules/core-js/modules/_for-of.js","./_array-methods":"node_modules/core-js/modules/_array-methods.js","./_has":"node_modules/core-js/modules/_has.js","./_validate-collection":"node_modules/core-js/modules/_validate-collection.js"}],"node_modules/core-js/modules/es6.weak-map.js":[function(require,module,exports) {

'use strict';
var global = require('./_global');
var each = require('./_array-methods')(0);
var redefine = require('./_redefine');
var meta = require('./_meta');
var assign = require('./_object-assign');
var weak = require('./_collection-weak');
var isObject = require('./_is-object');
var validate = require('./_validate-collection');
var NATIVE_WEAK_MAP = require('./_validate-collection');
var IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global;
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var InternalMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = require('./_collection')(WEAK_MAP, wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if (NATIVE_WEAK_MAP && IS_IE11) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}

},{"./_global":"node_modules/core-js/modules/_global.js","./_array-methods":"node_modules/core-js/modules/_array-methods.js","./_redefine":"node_modules/core-js/modules/_redefine.js","./_meta":"node_modules/core-js/modules/_meta.js","./_object-assign":"node_modules/core-js/modules/_object-assign.js","./_collection-weak":"node_modules/core-js/modules/_collection-weak.js","./_is-object":"node_modules/core-js/modules/_is-object.js","./_validate-collection":"node_modules/core-js/modules/_validate-collection.js","./_collection":"node_modules/core-js/modules/_collection.js"}],"node_modules/core-js/modules/es6.weak-set.js":[function(require,module,exports) {
'use strict';
var weak = require('./_collection-weak');
var validate = require('./_validate-collection');
var WEAK_SET = 'WeakSet';

// 23.4 WeakSet Objects
require('./_collection')(WEAK_SET, function (get) {
  return function WeakSet() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value) {
    return weak.def(validate(this, WEAK_SET), value, true);
  }
}, weak, false, true);

},{"./_collection-weak":"node_modules/core-js/modules/_collection-weak.js","./_validate-collection":"node_modules/core-js/modules/_validate-collection.js","./_collection":"node_modules/core-js/modules/_collection.js"}],"node_modules/core-js/modules/_typed.js":[function(require,module,exports) {

var global = require('./_global');
var hide = require('./_hide');
var uid = require('./_uid');
var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;

var TypedArrayConstructors = (
  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
).split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};

},{"./_global":"node_modules/core-js/modules/_global.js","./_hide":"node_modules/core-js/modules/_hide.js","./_uid":"node_modules/core-js/modules/_uid.js"}],"node_modules/core-js/modules/_to-index.js":[function(require,module,exports) {
// https://tc39.github.io/ecma262/#sec-toindex
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};

},{"./_to-integer":"node_modules/core-js/modules/_to-integer.js","./_to-length":"node_modules/core-js/modules/_to-length.js"}],"node_modules/core-js/modules/_typed-buffer.js":[function(require,module,exports) {

'use strict';
var global = require('./_global');
var DESCRIPTORS = require('./_descriptors');
var LIBRARY = require('./_library');
var $typed = require('./_typed');
var hide = require('./_hide');
var redefineAll = require('./_redefine-all');
var fails = require('./_fails');
var anInstance = require('./_an-instance');
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
var toIndex = require('./_to-index');
var gOPN = require('./_object-gopn').f;
var dP = require('./_object-dp').f;
var arrayFill = require('./_array-fill');
var setToStringTag = require('./_set-to-string-tag');
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError;
// eslint-disable-next-line no-shadow-restricted-names
var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;

// IEEE754 conversions based on https://github.com/feross/ieee754
function packIEEE754(value, mLen, nBytes) {
  var buffer = new Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value);
  // eslint-disable-next-line no-self-compare
  if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);
    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
  buffer[--i] |= s * 128;
  return buffer;
}
function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;
  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  } return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}
function packI8(it) {
  return [it & 0xff];
}
function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}
function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}
function packF64(it) {
  return packIEEE754(it, 52, 8);
}
function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}
function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);
  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    this._b = arrayFill.call(new Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH];
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    $ArrayBuffer(1);
  }) || !fails(function () {
    new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new $ArrayBuffer(); // eslint-disable-line no-new
    new $ArrayBuffer(1.5); // eslint-disable-line no-new
    new $ArrayBuffer(NaN); // eslint-disable-line no-new
    return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new BaseBuffer(toIndex(length));
    };
    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
    }
    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;

},{"./_global":"node_modules/core-js/modules/_global.js","./_descriptors":"node_modules/core-js/modules/_descriptors.js","./_library":"node_modules/core-js/modules/_library.js","./_typed":"node_modules/core-js/modules/_typed.js","./_hide":"node_modules/core-js/modules/_hide.js","./_redefine-all":"node_modules/core-js/modules/_redefine-all.js","./_fails":"node_modules/core-js/modules/_fails.js","./_an-instance":"node_modules/core-js/modules/_an-instance.js","./_to-integer":"node_modules/core-js/modules/_to-integer.js","./_to-length":"node_modules/core-js/modules/_to-length.js","./_to-index":"node_modules/core-js/modules/_to-index.js","./_object-gopn":"node_modules/core-js/modules/_object-gopn.js","./_object-dp":"node_modules/core-js/modules/_object-dp.js","./_array-fill":"node_modules/core-js/modules/_array-fill.js","./_set-to-string-tag":"node_modules/core-js/modules/_set-to-string-tag.js"}],"node_modules/core-js/modules/es6.typed.array-buffer.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $typed = require('./_typed');
var buffer = require('./_typed-buffer');
var anObject = require('./_an-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
var isObject = require('./_is-object');
var ArrayBuffer = require('./_global').ArrayBuffer;
var speciesConstructor = require('./_species-constructor');
var $ArrayBuffer = buffer.ArrayBuffer;
var $DataView = buffer.DataView;
var $isView = $typed.ABV && ArrayBuffer.isView;
var $slice = $ArrayBuffer.prototype.slice;
var VIEW = $typed.VIEW;
var ARRAY_BUFFER = 'ArrayBuffer';

$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });

$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it) {
    return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});

$export($export.P + $export.U + $export.F * require('./_fails')(function () {
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end) {
    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix
    var len = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, len);
    var fin = toAbsoluteIndex(end === undefined ? len : end, len);
    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(fin - first));
    var viewS = new $DataView(this);
    var viewT = new $DataView(result);
    var index = 0;
    while (first < fin) {
      viewT.setUint8(index++, viewS.getUint8(first++));
    } return result;
  }
});

require('./_set-species')(ARRAY_BUFFER);

},{"./_export":"node_modules/core-js/modules/_export.js","./_typed":"node_modules/core-js/modules/_typed.js","./_typed-buffer":"node_modules/core-js/modules/_typed-buffer.js","./_an-object":"node_modules/core-js/modules/_an-object.js","./_to-absolute-index":"node_modules/core-js/modules/_to-absolute-index.js","./_to-length":"node_modules/core-js/modules/_to-length.js","./_is-object":"node_modules/core-js/modules/_is-object.js","./_global":"node_modules/core-js/modules/_global.js","./_species-constructor":"node_modules/core-js/modules/_species-constructor.js","./_fails":"node_modules/core-js/modules/_fails.js","./_set-species":"node_modules/core-js/modules/_set-species.js"}],"node_modules/core-js/modules/es6.typed.data-view.js":[function(require,module,exports) {
var $export = require('./_export');
$export($export.G + $export.W + $export.F * !require('./_typed').ABV, {
  DataView: require('./_typed-buffer').DataView
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_typed":"node_modules/core-js/modules/_typed.js","./_typed-buffer":"node_modules/core-js/modules/_typed-buffer.js"}],"node_modules/core-js/modules/_typed-array.js":[function(require,module,exports) {
var global = arguments[3];
'use strict';
if (require('./_descriptors')) {
  var LIBRARY = require('./_library');
  var global = require('./_global');
  var fails = require('./_fails');
  var $export = require('./_export');
  var $typed = require('./_typed');
  var $buffer = require('./_typed-buffer');
  var ctx = require('./_ctx');
  var anInstance = require('./_an-instance');
  var propertyDesc = require('./_property-desc');
  var hide = require('./_hide');
  var redefineAll = require('./_redefine-all');
  var toInteger = require('./_to-integer');
  var toLength = require('./_to-length');
  var toIndex = require('./_to-index');
  var toAbsoluteIndex = require('./_to-absolute-index');
  var toPrimitive = require('./_to-primitive');
  var has = require('./_has');
  var classof = require('./_classof');
  var isObject = require('./_is-object');
  var toObject = require('./_to-object');
  var isArrayIter = require('./_is-array-iter');
  var create = require('./_object-create');
  var getPrototypeOf = require('./_object-gpo');
  var gOPN = require('./_object-gopn').f;
  var getIterFn = require('./core.get-iterator-method');
  var uid = require('./_uid');
  var wks = require('./_wks');
  var createArrayMethod = require('./_array-methods');
  var createArrayIncludes = require('./_array-includes');
  var speciesConstructor = require('./_species-constructor');
  var ArrayIterators = require('./es6.array.iterator');
  var Iterators = require('./_iterators');
  var $iterDetect = require('./_iter-detect');
  var setSpecies = require('./_set-species');
  var arrayFill = require('./_array-fill');
  var arrayCopyWithin = require('./_array-copy-within');
  var $DP = require('./_object-dp');
  var $GOPD = require('./_object-gopd');
  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';

  var $map = createArrayMethod(1, function (O, length) {
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
    new Uint8Array(1).set({});
  });

  var toOffset = function (it, BYTES) {
    var offset = toInteger(it);
    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function (it) {
    if (isObject(it) && TYPED_ARRAY in it) return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function (C, length) {
    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
      throw TypeError('It is not a typed array constructor!');
    } return new C(length);
  };

  var speciesFromList = function (O, list) {
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = allocate(C, length);
    while (length > index) result[index] = list[index++];
    return result;
  };

  var addGetter = function (it, key, internal) {
    dP(it, key, { get: function () { return this._d[internal]; } });
  };

  var $from = function from(source /* , mapfn, thisArg */) {
    var O = toObject(source);
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iterFn = getIterFn(O);
    var i, length, values, result, step, iterator;
    if (iterFn != undefined && !isArrayIter(iterFn)) {
      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
        values.push(step.value);
      } O = values;
    }
    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };

  var $of = function of(/* ...items */) {
    var index = 0;
    var length = arguments.length;
    var result = allocate(this, length);
    while (length > index) result[index] = arguments[index++];
    return result;
  };

  // iOS Safari 6.x fails here
  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });

  var $toLocaleString = function toLocaleString() {
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start /* , end */) {
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn /* , thisArg */) {
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn /* , thisArg */) {
      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
        arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate /* , thisArg */) {
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate /* , thisArg */) {
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn /* , thisArg */) {
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement /* , fromIndex */) {
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement /* , fromIndex */) {
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator) { // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn /* , thisArg */) {
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse() {
      var that = this;
      var length = validate(that).length;
      var middle = Math.floor(length / 2);
      var index = 0;
      var value;
      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      } return that;
    },
    some: function some(callbackfn /* , thisArg */) {
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn) {
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end) {
      var O = validate(this);
      var length = O.length;
      var $begin = toAbsoluteIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
        O.buffer,
        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)
      );
    }
  };

  var $slice = function slice(start, end) {
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /* , offset */) {
    validate(this);
    var offset = toOffset(arguments[1], 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError(WRONG_LENGTH);
    while (index < len) this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries() {
      return arrayEntries.call(validate(this));
    },
    keys: function keys() {
      return arrayKeys.call(validate(this));
    },
    values: function values() {
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function (target, key) {
    return isObject(target)
      && target[TYPED_ARRAY]
      && typeof key != 'symbol'
      && key in target
      && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key) {
    return isTAIndex(target, key = toPrimitive(key, true))
      ? propertyDesc(2, target[key])
      : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc) {
    if (isTAIndex(target, key = toPrimitive(key, true))
      && isObject(desc)
      && has(desc, 'value')
      && !has(desc, 'get')
      && !has(desc, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !desc.configurable
      && (!has(desc, 'writable') || desc.writable)
      && (!has(desc, 'enumerable') || desc.enumerable)
    ) {
      target[key] = desc.value;
      return target;
    } return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
    $GOPD.f = $getDesc;
    $DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty: $setDesc
  });

  if (fails(function () { arrayToString.call({}); })) {
    arrayToString = arrayToLocaleString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice: $slice,
    set: $set,
    constructor: function () { /* noop */ },
    toString: arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function () { return this[TYPED_ARRAY]; }
  });

  // eslint-disable-next-line max-statements
  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
    CLAMPED = !!CLAMPED;
    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + KEY;
    var SETTER = 'set' + KEY;
    var TypedArray = global[NAME];
    var Base = TypedArray || {};
    var TAC = TypedArray && getPrototypeOf(TypedArray);
    var FORCED = !TypedArray || !$typed.ABV;
    var O = {};
    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
    var getter = function (that, index) {
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };
    var setter = function (that, index, value) {
      var data = that._d;
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };
    var addElement = function (that, index) {
      dP(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if (FORCED) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME, '_d');
        var index = 0;
        var offset = 0;
        var buffer, byteLength, length, klass;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new $ArrayBuffer(byteLength);
        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (TYPED_ARRAY in data) {
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }
        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if (!fails(function () {
      TypedArray(1);
    }) || !fails(function () {
      new TypedArray(-1); // eslint-disable-line no-new
    }) || !$iterDetect(function (iter) {
      new TypedArray(); // eslint-disable-line no-new
      new TypedArray(null); // eslint-disable-line no-new
      new TypedArray(1.5); // eslint-disable-line no-new
      new TypedArray(iter); // eslint-disable-line no-new
    }, true)) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME);
        var klass;
        // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645
        if (!isObject(data)) return new Base(toIndex(data));
        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          return $length !== undefined
            ? new Base(data, toOffset($offset, BYTES), $length)
            : $offset !== undefined
              ? new Base(data, toOffset($offset, BYTES))
              : new Base(data);
        }
        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
    }
    var $nativeIterator = TypedArrayPrototype[ITERATOR];
    var CORRECT_ITER_NAME = !!$nativeIterator
      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
    var $iterator = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
      dP(TypedArrayPrototype, TAG, {
        get: function () { return NAME; }
      });
    }

    O[NAME] = TypedArray;

    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES
    });

    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {
      from: $from,
      of: $of
    });

    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

    $export($export.P, NAME, proto);

    setSpecies(NAME);

    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;

    $export($export.P + $export.F * fails(function () {
      new TypedArray(1).slice();
    }), NAME, { slice: $slice });

    $export($export.P + $export.F * (fails(function () {
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
    }) || !fails(function () {
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, { toLocaleString: $toLocaleString });

    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () { /* empty */ };

},{"./_descriptors":"node_modules/core-js/modules/_descriptors.js","./_library":"node_modules/core-js/modules/_library.js","./_global":"node_modules/core-js/modules/_global.js","./_fails":"node_modules/core-js/modules/_fails.js","./_export":"node_modules/core-js/modules/_export.js","./_typed":"node_modules/core-js/modules/_typed.js","./_typed-buffer":"node_modules/core-js/modules/_typed-buffer.js","./_ctx":"node_modules/core-js/modules/_ctx.js","./_an-instance":"node_modules/core-js/modules/_an-instance.js","./_property-desc":"node_modules/core-js/modules/_property-desc.js","./_hide":"node_modules/core-js/modules/_hide.js","./_redefine-all":"node_modules/core-js/modules/_redefine-all.js","./_to-integer":"node_modules/core-js/modules/_to-integer.js","./_to-length":"node_modules/core-js/modules/_to-length.js","./_to-index":"node_modules/core-js/modules/_to-index.js","./_to-absolute-index":"node_modules/core-js/modules/_to-absolute-index.js","./_to-primitive":"node_modules/core-js/modules/_to-primitive.js","./_has":"node_modules/core-js/modules/_has.js","./_classof":"node_modules/core-js/modules/_classof.js","./_is-object":"node_modules/core-js/modules/_is-object.js","./_to-object":"node_modules/core-js/modules/_to-object.js","./_is-array-iter":"node_modules/core-js/modules/_is-array-iter.js","./_object-create":"node_modules/core-js/modules/_object-create.js","./_object-gpo":"node_modules/core-js/modules/_object-gpo.js","./_object-gopn":"node_modules/core-js/modules/_object-gopn.js","./core.get-iterator-method":"node_modules/core-js/modules/core.get-iterator-method.js","./_uid":"node_modules/core-js/modules/_uid.js","./_wks":"node_modules/core-js/modules/_wks.js","./_array-methods":"node_modules/core-js/modules/_array-methods.js","./_array-includes":"node_modules/core-js/modules/_array-includes.js","./_species-constructor":"node_modules/core-js/modules/_species-constructor.js","./es6.array.iterator":"node_modules/core-js/modules/es6.array.iterator.js","./_iterators":"node_modules/core-js/modules/_iterators.js","./_iter-detect":"node_modules/core-js/modules/_iter-detect.js","./_set-species":"node_modules/core-js/modules/_set-species.js","./_array-fill":"node_modules/core-js/modules/_array-fill.js","./_array-copy-within":"node_modules/core-js/modules/_array-copy-within.js","./_object-dp":"node_modules/core-js/modules/_object-dp.js","./_object-gopd":"node_modules/core-js/modules/_object-gopd.js"}],"node_modules/core-js/modules/es6.typed.int8-array.js":[function(require,module,exports) {
require('./_typed-array')('Int8', 1, function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":"node_modules/core-js/modules/_typed-array.js"}],"node_modules/core-js/modules/es6.typed.uint8-array.js":[function(require,module,exports) {
require('./_typed-array')('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":"node_modules/core-js/modules/_typed-array.js"}],"node_modules/core-js/modules/es6.typed.uint8-clamped-array.js":[function(require,module,exports) {
require('./_typed-array')('Uint8', 1, function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);

},{"./_typed-array":"node_modules/core-js/modules/_typed-array.js"}],"node_modules/core-js/modules/es6.typed.int16-array.js":[function(require,module,exports) {
require('./_typed-array')('Int16', 2, function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":"node_modules/core-js/modules/_typed-array.js"}],"node_modules/core-js/modules/es6.typed.uint16-array.js":[function(require,module,exports) {
require('./_typed-array')('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":"node_modules/core-js/modules/_typed-array.js"}],"node_modules/core-js/modules/es6.typed.int32-array.js":[function(require,module,exports) {
require('./_typed-array')('Int32', 4, function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":"node_modules/core-js/modules/_typed-array.js"}],"node_modules/core-js/modules/es6.typed.uint32-array.js":[function(require,module,exports) {
require('./_typed-array')('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":"node_modules/core-js/modules/_typed-array.js"}],"node_modules/core-js/modules/es6.typed.float32-array.js":[function(require,module,exports) {
require('./_typed-array')('Float32', 4, function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":"node_modules/core-js/modules/_typed-array.js"}],"node_modules/core-js/modules/es6.typed.float64-array.js":[function(require,module,exports) {
require('./_typed-array')('Float64', 8, function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":"node_modules/core-js/modules/_typed-array.js"}],"node_modules/core-js/modules/es6.reflect.apply.js":[function(require,module,exports) {
// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export = require('./_export');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var rApply = (require('./_global').Reflect || {}).apply;
var fApply = Function.apply;
// MS Edge argumentsList argument is optional
$export($export.S + $export.F * !require('./_fails')(function () {
  rApply(function () { /* empty */ });
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList) {
    var T = aFunction(target);
    var L = anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_a-function":"node_modules/core-js/modules/_a-function.js","./_an-object":"node_modules/core-js/modules/_an-object.js","./_global":"node_modules/core-js/modules/_global.js","./_fails":"node_modules/core-js/modules/_fails.js"}],"node_modules/core-js/modules/es6.reflect.construct.js":[function(require,module,exports) {
// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export = require('./_export');
var create = require('./_object-create');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var fails = require('./_fails');
var bind = require('./_bind');
var rConstruct = (require('./_global').Reflect || {}).construct;

// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(rConstruct(function () { /* empty */ }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  rConstruct(function () { /* empty */ });
});

$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args /* , newTarget */) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_object-create":"node_modules/core-js/modules/_object-create.js","./_a-function":"node_modules/core-js/modules/_a-function.js","./_an-object":"node_modules/core-js/modules/_an-object.js","./_is-object":"node_modules/core-js/modules/_is-object.js","./_fails":"node_modules/core-js/modules/_fails.js","./_bind":"node_modules/core-js/modules/_bind.js","./_global":"node_modules/core-js/modules/_global.js"}],"node_modules/core-js/modules/es6.reflect.define-property.js":[function(require,module,exports) {
// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP = require('./_object-dp');
var $export = require('./_export');
var anObject = require('./_an-object');
var toPrimitive = require('./_to-primitive');

// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
$export($export.S + $export.F * require('./_fails')(function () {
  // eslint-disable-next-line no-undef
  Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 });
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes) {
    anObject(target);
    propertyKey = toPrimitive(propertyKey, true);
    anObject(attributes);
    try {
      dP.f(target, propertyKey, attributes);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_object-dp":"node_modules/core-js/modules/_object-dp.js","./_export":"node_modules/core-js/modules/_export.js","./_an-object":"node_modules/core-js/modules/_an-object.js","./_to-primitive":"node_modules/core-js/modules/_to-primitive.js","./_fails":"node_modules/core-js/modules/_fails.js"}],"node_modules/core-js/modules/es6.reflect.delete-property.js":[function(require,module,exports) {
// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export = require('./_export');
var gOPD = require('./_object-gopd').f;
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey) {
    var desc = gOPD(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_object-gopd":"node_modules/core-js/modules/_object-gopd.js","./_an-object":"node_modules/core-js/modules/_an-object.js"}],"node_modules/core-js/modules/es6.reflect.enumerate.js":[function(require,module,exports) {
'use strict';
// 26.1.5 Reflect.enumerate(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var Enumerate = function (iterated) {
  this._t = anObject(iterated); // target
  this._i = 0;                  // next index
  var keys = this._k = [];      // keys
  var key;
  for (key in iterated) keys.push(key);
};
require('./_iter-create')(Enumerate, 'Object', function () {
  var that = this;
  var keys = that._k;
  var key;
  do {
    if (that._i >= keys.length) return { value: undefined, done: true };
  } while (!((key = keys[that._i++]) in that._t));
  return { value: key, done: false };
});

$export($export.S, 'Reflect', {
  enumerate: function enumerate(target) {
    return new Enumerate(target);
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_an-object":"node_modules/core-js/modules/_an-object.js","./_iter-create":"node_modules/core-js/modules/_iter-create.js"}],"node_modules/core-js/modules/es6.reflect.get.js":[function(require,module,exports) {
// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD = require('./_object-gopd');
var getPrototypeOf = require('./_object-gpo');
var has = require('./_has');
var $export = require('./_export');
var isObject = require('./_is-object');
var anObject = require('./_an-object');

function get(target, propertyKey /* , receiver */) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var desc, proto;
  if (anObject(target) === receiver) return target[propertyKey];
  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value')
    ? desc.value
    : desc.get !== undefined
      ? desc.get.call(receiver)
      : undefined;
  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', { get: get });

},{"./_object-gopd":"node_modules/core-js/modules/_object-gopd.js","./_object-gpo":"node_modules/core-js/modules/_object-gpo.js","./_has":"node_modules/core-js/modules/_has.js","./_export":"node_modules/core-js/modules/_export.js","./_is-object":"node_modules/core-js/modules/_is-object.js","./_an-object":"node_modules/core-js/modules/_an-object.js"}],"node_modules/core-js/modules/es6.reflect.get-own-property-descriptor.js":[function(require,module,exports) {
// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD = require('./_object-gopd');
var $export = require('./_export');
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
    return gOPD.f(anObject(target), propertyKey);
  }
});

},{"./_object-gopd":"node_modules/core-js/modules/_object-gopd.js","./_export":"node_modules/core-js/modules/_export.js","./_an-object":"node_modules/core-js/modules/_an-object.js"}],"node_modules/core-js/modules/es6.reflect.get-prototype-of.js":[function(require,module,exports) {
// 26.1.8 Reflect.getPrototypeOf(target)
var $export = require('./_export');
var getProto = require('./_object-gpo');
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target) {
    return getProto(anObject(target));
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_object-gpo":"node_modules/core-js/modules/_object-gpo.js","./_an-object":"node_modules/core-js/modules/_an-object.js"}],"node_modules/core-js/modules/es6.reflect.has.js":[function(require,module,exports) {
// 26.1.9 Reflect.has(target, propertyKey)
var $export = require('./_export');

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey) {
    return propertyKey in target;
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js"}],"node_modules/core-js/modules/es6.reflect.is-extensible.js":[function(require,module,exports) {
// 26.1.10 Reflect.isExtensible(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var $isExtensible = Object.isExtensible;

$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target) {
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_an-object":"node_modules/core-js/modules/_an-object.js"}],"node_modules/core-js/modules/_own-keys.js":[function(require,module,exports) {
// all object keys, includes non-enumerable and symbols
var gOPN = require('./_object-gopn');
var gOPS = require('./_object-gops');
var anObject = require('./_an-object');
var Reflect = require('./_global').Reflect;
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = gOPN.f(anObject(it));
  var getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};

},{"./_object-gopn":"node_modules/core-js/modules/_object-gopn.js","./_object-gops":"node_modules/core-js/modules/_object-gops.js","./_an-object":"node_modules/core-js/modules/_an-object.js","./_global":"node_modules/core-js/modules/_global.js"}],"node_modules/core-js/modules/es6.reflect.own-keys.js":[function(require,module,exports) {
// 26.1.11 Reflect.ownKeys(target)
var $export = require('./_export');

$export($export.S, 'Reflect', { ownKeys: require('./_own-keys') });

},{"./_export":"node_modules/core-js/modules/_export.js","./_own-keys":"node_modules/core-js/modules/_own-keys.js"}],"node_modules/core-js/modules/es6.reflect.prevent-extensions.js":[function(require,module,exports) {
// 26.1.12 Reflect.preventExtensions(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var $preventExtensions = Object.preventExtensions;

$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target) {
    anObject(target);
    try {
      if ($preventExtensions) $preventExtensions(target);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_an-object":"node_modules/core-js/modules/_an-object.js"}],"node_modules/core-js/modules/es6.reflect.set.js":[function(require,module,exports) {
// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP = require('./_object-dp');
var gOPD = require('./_object-gopd');
var getPrototypeOf = require('./_object-gpo');
var has = require('./_has');
var $export = require('./_export');
var createDesc = require('./_property-desc');
var anObject = require('./_an-object');
var isObject = require('./_is-object');

function set(target, propertyKey, V /* , receiver */) {
  var receiver = arguments.length < 4 ? target : arguments[3];
  var ownDesc = gOPD.f(anObject(target), propertyKey);
  var existingDescriptor, proto;
  if (!ownDesc) {
    if (isObject(proto = getPrototypeOf(target))) {
      return set(proto, propertyKey, V, receiver);
    }
    ownDesc = createDesc(0);
  }
  if (has(ownDesc, 'value')) {
    if (ownDesc.writable === false || !isObject(receiver)) return false;
    if (existingDescriptor = gOPD.f(receiver, propertyKey)) {
      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
      existingDescriptor.value = V;
      dP.f(receiver, propertyKey, existingDescriptor);
    } else dP.f(receiver, propertyKey, createDesc(0, V));
    return true;
  }
  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', { set: set });

},{"./_object-dp":"node_modules/core-js/modules/_object-dp.js","./_object-gopd":"node_modules/core-js/modules/_object-gopd.js","./_object-gpo":"node_modules/core-js/modules/_object-gpo.js","./_has":"node_modules/core-js/modules/_has.js","./_export":"node_modules/core-js/modules/_export.js","./_property-desc":"node_modules/core-js/modules/_property-desc.js","./_an-object":"node_modules/core-js/modules/_an-object.js","./_is-object":"node_modules/core-js/modules/_is-object.js"}],"node_modules/core-js/modules/es6.reflect.set-prototype-of.js":[function(require,module,exports) {
// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export = require('./_export');
var setProto = require('./_set-proto');

if (setProto) $export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto) {
    setProto.check(target, proto);
    try {
      setProto.set(target, proto);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_set-proto":"node_modules/core-js/modules/_set-proto.js"}],"node_modules/core-js/modules/es7.array.includes.js":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/Array.prototype.includes
var $export = require('./_export');
var $includes = require('./_array-includes')(true);

$export($export.P, 'Array', {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

require('./_add-to-unscopables')('includes');

},{"./_export":"node_modules/core-js/modules/_export.js","./_array-includes":"node_modules/core-js/modules/_array-includes.js","./_add-to-unscopables":"node_modules/core-js/modules/_add-to-unscopables.js"}],"node_modules/core-js/modules/_flatten-into-array.js":[function(require,module,exports) {
'use strict';
// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
var isArray = require('./_is-array');
var isObject = require('./_is-object');
var toLength = require('./_to-length');
var ctx = require('./_ctx');
var IS_CONCAT_SPREADABLE = require('./_wks')('isConcatSpreadable');

function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;
  var element, spreadable;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

      spreadable = false;
      if (isObject(element)) {
        spreadable = element[IS_CONCAT_SPREADABLE];
        spreadable = spreadable !== undefined ? !!spreadable : isArray(element);
      }

      if (spreadable && depth > 0) {
        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1fffffffffffff) throw TypeError();
        target[targetIndex] = element;
      }

      targetIndex++;
    }
    sourceIndex++;
  }
  return targetIndex;
}

module.exports = flattenIntoArray;

},{"./_is-array":"node_modules/core-js/modules/_is-array.js","./_is-object":"node_modules/core-js/modules/_is-object.js","./_to-length":"node_modules/core-js/modules/_to-length.js","./_ctx":"node_modules/core-js/modules/_ctx.js","./_wks":"node_modules/core-js/modules/_wks.js"}],"node_modules/core-js/modules/es7.array.flat-map.js":[function(require,module,exports) {
'use strict';
// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap
var $export = require('./_export');
var flattenIntoArray = require('./_flatten-into-array');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var aFunction = require('./_a-function');
var arraySpeciesCreate = require('./_array-species-create');

$export($export.P, 'Array', {
  flatMap: function flatMap(callbackfn /* , thisArg */) {
    var O = toObject(this);
    var sourceLen, A;
    aFunction(callbackfn);
    sourceLen = toLength(O.length);
    A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
    return A;
  }
});

require('./_add-to-unscopables')('flatMap');

},{"./_export":"node_modules/core-js/modules/_export.js","./_flatten-into-array":"node_modules/core-js/modules/_flatten-into-array.js","./_to-object":"node_modules/core-js/modules/_to-object.js","./_to-length":"node_modules/core-js/modules/_to-length.js","./_a-function":"node_modules/core-js/modules/_a-function.js","./_array-species-create":"node_modules/core-js/modules/_array-species-create.js","./_add-to-unscopables":"node_modules/core-js/modules/_add-to-unscopables.js"}],"node_modules/core-js/modules/es7.array.flatten.js":[function(require,module,exports) {
'use strict';
// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatten
var $export = require('./_export');
var flattenIntoArray = require('./_flatten-into-array');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var toInteger = require('./_to-integer');
var arraySpeciesCreate = require('./_array-species-create');

$export($export.P, 'Array', {
  flatten: function flatten(/* depthArg = 1 */) {
    var depthArg = arguments[0];
    var O = toObject(this);
    var sourceLen = toLength(O.length);
    var A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
    return A;
  }
});

require('./_add-to-unscopables')('flatten');

},{"./_export":"node_modules/core-js/modules/_export.js","./_flatten-into-array":"node_modules/core-js/modules/_flatten-into-array.js","./_to-object":"node_modules/core-js/modules/_to-object.js","./_to-length":"node_modules/core-js/modules/_to-length.js","./_to-integer":"node_modules/core-js/modules/_to-integer.js","./_array-species-create":"node_modules/core-js/modules/_array-species-create.js","./_add-to-unscopables":"node_modules/core-js/modules/_add-to-unscopables.js"}],"node_modules/core-js/modules/es7.string.at.js":[function(require,module,exports) {
'use strict';
// https://github.com/mathiasbynens/String.prototype.at
var $export = require('./_export');
var $at = require('./_string-at')(true);

$export($export.P, 'String', {
  at: function at(pos) {
    return $at(this, pos);
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_string-at":"node_modules/core-js/modules/_string-at.js"}],"node_modules/core-js/modules/_string-pad.js":[function(require,module,exports) {
// https://github.com/tc39/proposal-string-pad-start-end
var toLength = require('./_to-length');
var repeat = require('./_string-repeat');
var defined = require('./_defined');

module.exports = function (that, maxLength, fillString, left) {
  var S = String(defined(that));
  var stringLength = S.length;
  var fillStr = fillString === undefined ? ' ' : String(fillString);
  var intMaxLength = toLength(maxLength);
  if (intMaxLength <= stringLength || fillStr == '') return S;
  var fillLen = intMaxLength - stringLength;
  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};

},{"./_to-length":"node_modules/core-js/modules/_to-length.js","./_string-repeat":"node_modules/core-js/modules/_string-repeat.js","./_defined":"node_modules/core-js/modules/_defined.js"}],"node_modules/core-js/modules/es7.string.pad-start.js":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/proposal-string-pad-start-end
var $export = require('./_export');
var $pad = require('./_string-pad');
var userAgent = require('./_user-agent');

// https://github.com/zloirock/core-js/issues/280
var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);

$export($export.P + $export.F * WEBKIT_BUG, 'String', {
  padStart: function padStart(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_string-pad":"node_modules/core-js/modules/_string-pad.js","./_user-agent":"node_modules/core-js/modules/_user-agent.js"}],"node_modules/core-js/modules/es7.string.pad-end.js":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/proposal-string-pad-start-end
var $export = require('./_export');
var $pad = require('./_string-pad');
var userAgent = require('./_user-agent');

// https://github.com/zloirock/core-js/issues/280
var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);

$export($export.P + $export.F * WEBKIT_BUG, 'String', {
  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_string-pad":"node_modules/core-js/modules/_string-pad.js","./_user-agent":"node_modules/core-js/modules/_user-agent.js"}],"node_modules/core-js/modules/es7.string.trim-left.js":[function(require,module,exports) {
'use strict';
// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
require('./_string-trim')('trimLeft', function ($trim) {
  return function trimLeft() {
    return $trim(this, 1);
  };
}, 'trimStart');

},{"./_string-trim":"node_modules/core-js/modules/_string-trim.js"}],"node_modules/core-js/modules/es7.string.trim-right.js":[function(require,module,exports) {
'use strict';
// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
require('./_string-trim')('trimRight', function ($trim) {
  return function trimRight() {
    return $trim(this, 2);
  };
}, 'trimEnd');

},{"./_string-trim":"node_modules/core-js/modules/_string-trim.js"}],"node_modules/core-js/modules/es7.string.match-all.js":[function(require,module,exports) {
'use strict';
// https://tc39.github.io/String.prototype.matchAll/
var $export = require('./_export');
var defined = require('./_defined');
var toLength = require('./_to-length');
var isRegExp = require('./_is-regexp');
var getFlags = require('./_flags');
var RegExpProto = RegExp.prototype;

var $RegExpStringIterator = function (regexp, string) {
  this._r = regexp;
  this._s = string;
};

require('./_iter-create')($RegExpStringIterator, 'RegExp String', function next() {
  var match = this._r.exec(this._s);
  return { value: match, done: match === null };
});

$export($export.P, 'String', {
  matchAll: function matchAll(regexp) {
    defined(this);
    if (!isRegExp(regexp)) throw TypeError(regexp + ' is not a regexp!');
    var S = String(this);
    var flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp);
    var rx = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
    rx.lastIndex = toLength(regexp.lastIndex);
    return new $RegExpStringIterator(rx, S);
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_defined":"node_modules/core-js/modules/_defined.js","./_to-length":"node_modules/core-js/modules/_to-length.js","./_is-regexp":"node_modules/core-js/modules/_is-regexp.js","./_flags":"node_modules/core-js/modules/_flags.js","./_iter-create":"node_modules/core-js/modules/_iter-create.js"}],"node_modules/core-js/modules/es7.symbol.async-iterator.js":[function(require,module,exports) {
require('./_wks-define')('asyncIterator');

},{"./_wks-define":"node_modules/core-js/modules/_wks-define.js"}],"node_modules/core-js/modules/es7.symbol.observable.js":[function(require,module,exports) {
require('./_wks-define')('observable');

},{"./_wks-define":"node_modules/core-js/modules/_wks-define.js"}],"node_modules/core-js/modules/es7.object.get-own-property-descriptors.js":[function(require,module,exports) {
// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export = require('./_export');
var ownKeys = require('./_own-keys');
var toIObject = require('./_to-iobject');
var gOPD = require('./_object-gopd');
var createProperty = require('./_create-property');

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIObject(object);
    var getDesc = gOPD.f;
    var keys = ownKeys(O);
    var result = {};
    var i = 0;
    var key, desc;
    while (keys.length > i) {
      desc = getDesc(O, key = keys[i++]);
      if (desc !== undefined) createProperty(result, key, desc);
    }
    return result;
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_own-keys":"node_modules/core-js/modules/_own-keys.js","./_to-iobject":"node_modules/core-js/modules/_to-iobject.js","./_object-gopd":"node_modules/core-js/modules/_object-gopd.js","./_create-property":"node_modules/core-js/modules/_create-property.js"}],"node_modules/core-js/modules/_object-to-array.js":[function(require,module,exports) {
var DESCRIPTORS = require('./_descriptors');
var getKeys = require('./_object-keys');
var toIObject = require('./_to-iobject');
var isEnum = require('./_object-pie').f;
module.exports = function (isEntries) {
  return function (it) {
    var O = toIObject(it);
    var keys = getKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) {
      key = keys[i++];
      if (!DESCRIPTORS || isEnum.call(O, key)) {
        result.push(isEntries ? [key, O[key]] : O[key]);
      }
    }
    return result;
  };
};

},{"./_descriptors":"node_modules/core-js/modules/_descriptors.js","./_object-keys":"node_modules/core-js/modules/_object-keys.js","./_to-iobject":"node_modules/core-js/modules/_to-iobject.js","./_object-pie":"node_modules/core-js/modules/_object-pie.js"}],"node_modules/core-js/modules/es7.object.values.js":[function(require,module,exports) {
// https://github.com/tc39/proposal-object-values-entries
var $export = require('./_export');
var $values = require('./_object-to-array')(false);

$export($export.S, 'Object', {
  values: function values(it) {
    return $values(it);
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_object-to-array":"node_modules/core-js/modules/_object-to-array.js"}],"node_modules/core-js/modules/es7.object.entries.js":[function(require,module,exports) {
// https://github.com/tc39/proposal-object-values-entries
var $export = require('./_export');
var $entries = require('./_object-to-array')(true);

$export($export.S, 'Object', {
  entries: function entries(it) {
    return $entries(it);
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_object-to-array":"node_modules/core-js/modules/_object-to-array.js"}],"node_modules/core-js/modules/_object-forced-pam.js":[function(require,module,exports) {
'use strict';
// Forced replacement prototype accessors methods
module.exports = require('./_library') || !require('./_fails')(function () {
  var K = Math.random();
  // In FF throws only define methods
  // eslint-disable-next-line no-undef, no-useless-call
  __defineSetter__.call(null, K, function () { /* empty */ });
  delete require('./_global')[K];
});

},{"./_library":"node_modules/core-js/modules/_library.js","./_fails":"node_modules/core-js/modules/_fails.js","./_global":"node_modules/core-js/modules/_global.js"}],"node_modules/core-js/modules/es7.object.define-getter.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var aFunction = require('./_a-function');
var $defineProperty = require('./_object-dp');

// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __defineGetter__: function __defineGetter__(P, getter) {
    $defineProperty.f(toObject(this), P, { get: aFunction(getter), enumerable: true, configurable: true });
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_to-object":"node_modules/core-js/modules/_to-object.js","./_a-function":"node_modules/core-js/modules/_a-function.js","./_object-dp":"node_modules/core-js/modules/_object-dp.js","./_descriptors":"node_modules/core-js/modules/_descriptors.js","./_object-forced-pam":"node_modules/core-js/modules/_object-forced-pam.js"}],"node_modules/core-js/modules/es7.object.define-setter.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var aFunction = require('./_a-function');
var $defineProperty = require('./_object-dp');

// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __defineSetter__: function __defineSetter__(P, setter) {
    $defineProperty.f(toObject(this), P, { set: aFunction(setter), enumerable: true, configurable: true });
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_to-object":"node_modules/core-js/modules/_to-object.js","./_a-function":"node_modules/core-js/modules/_a-function.js","./_object-dp":"node_modules/core-js/modules/_object-dp.js","./_descriptors":"node_modules/core-js/modules/_descriptors.js","./_object-forced-pam":"node_modules/core-js/modules/_object-forced-pam.js"}],"node_modules/core-js/modules/es7.object.lookup-getter.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var toPrimitive = require('./_to-primitive');
var getPrototypeOf = require('./_object-gpo');
var getOwnPropertyDescriptor = require('./_object-gopd').f;

// B.2.2.4 Object.prototype.__lookupGetter__(P)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __lookupGetter__: function __lookupGetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;
    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.get;
    } while (O = getPrototypeOf(O));
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_to-object":"node_modules/core-js/modules/_to-object.js","./_to-primitive":"node_modules/core-js/modules/_to-primitive.js","./_object-gpo":"node_modules/core-js/modules/_object-gpo.js","./_object-gopd":"node_modules/core-js/modules/_object-gopd.js","./_descriptors":"node_modules/core-js/modules/_descriptors.js","./_object-forced-pam":"node_modules/core-js/modules/_object-forced-pam.js"}],"node_modules/core-js/modules/es7.object.lookup-setter.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var toPrimitive = require('./_to-primitive');
var getPrototypeOf = require('./_object-gpo');
var getOwnPropertyDescriptor = require('./_object-gopd').f;

// B.2.2.5 Object.prototype.__lookupSetter__(P)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __lookupSetter__: function __lookupSetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;
    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.set;
    } while (O = getPrototypeOf(O));
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_to-object":"node_modules/core-js/modules/_to-object.js","./_to-primitive":"node_modules/core-js/modules/_to-primitive.js","./_object-gpo":"node_modules/core-js/modules/_object-gpo.js","./_object-gopd":"node_modules/core-js/modules/_object-gopd.js","./_descriptors":"node_modules/core-js/modules/_descriptors.js","./_object-forced-pam":"node_modules/core-js/modules/_object-forced-pam.js"}],"node_modules/core-js/modules/_array-from-iterable.js":[function(require,module,exports) {
var forOf = require('./_for-of');

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};

},{"./_for-of":"node_modules/core-js/modules/_for-of.js"}],"node_modules/core-js/modules/_collection-to-json.js":[function(require,module,exports) {
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = require('./_classof');
var from = require('./_array-from-iterable');
module.exports = function (NAME) {
  return function toJSON() {
    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};

},{"./_classof":"node_modules/core-js/modules/_classof.js","./_array-from-iterable":"node_modules/core-js/modules/_array-from-iterable.js"}],"node_modules/core-js/modules/es7.map.to-json.js":[function(require,module,exports) {
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = require('./_export');

$export($export.P + $export.R, 'Map', { toJSON: require('./_collection-to-json')('Map') });

},{"./_export":"node_modules/core-js/modules/_export.js","./_collection-to-json":"node_modules/core-js/modules/_collection-to-json.js"}],"node_modules/core-js/modules/es7.set.to-json.js":[function(require,module,exports) {
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = require('./_export');

$export($export.P + $export.R, 'Set', { toJSON: require('./_collection-to-json')('Set') });

},{"./_export":"node_modules/core-js/modules/_export.js","./_collection-to-json":"node_modules/core-js/modules/_collection-to-json.js"}],"node_modules/core-js/modules/_set-collection-of.js":[function(require,module,exports) {
'use strict';
// https://tc39.github.io/proposal-setmap-offrom/
var $export = require('./_export');

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { of: function of() {
    var length = arguments.length;
    var A = new Array(length);
    while (length--) A[length] = arguments[length];
    return new this(A);
  } });
};

},{"./_export":"node_modules/core-js/modules/_export.js"}],"node_modules/core-js/modules/es7.map.of.js":[function(require,module,exports) {
// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
require('./_set-collection-of')('Map');

},{"./_set-collection-of":"node_modules/core-js/modules/_set-collection-of.js"}],"node_modules/core-js/modules/es7.set.of.js":[function(require,module,exports) {
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
require('./_set-collection-of')('Set');

},{"./_set-collection-of":"node_modules/core-js/modules/_set-collection-of.js"}],"node_modules/core-js/modules/es7.weak-map.of.js":[function(require,module,exports) {
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
require('./_set-collection-of')('WeakMap');

},{"./_set-collection-of":"node_modules/core-js/modules/_set-collection-of.js"}],"node_modules/core-js/modules/es7.weak-set.of.js":[function(require,module,exports) {
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.of
require('./_set-collection-of')('WeakSet');

},{"./_set-collection-of":"node_modules/core-js/modules/_set-collection-of.js"}],"node_modules/core-js/modules/_set-collection-from.js":[function(require,module,exports) {
'use strict';
// https://tc39.github.io/proposal-setmap-offrom/
var $export = require('./_export');
var aFunction = require('./_a-function');
var ctx = require('./_ctx');
var forOf = require('./_for-of');

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
    var mapFn = arguments[1];
    var mapping, A, n, cb;
    aFunction(this);
    mapping = mapFn !== undefined;
    if (mapping) aFunction(mapFn);
    if (source == undefined) return new this();
    A = [];
    if (mapping) {
      n = 0;
      cb = ctx(mapFn, arguments[2], 2);
      forOf(source, false, function (nextItem) {
        A.push(cb(nextItem, n++));
      });
    } else {
      forOf(source, false, A.push, A);
    }
    return new this(A);
  } });
};

},{"./_export":"node_modules/core-js/modules/_export.js","./_a-function":"node_modules/core-js/modules/_a-function.js","./_ctx":"node_modules/core-js/modules/_ctx.js","./_for-of":"node_modules/core-js/modules/_for-of.js"}],"node_modules/core-js/modules/es7.map.from.js":[function(require,module,exports) {
// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
require('./_set-collection-from')('Map');

},{"./_set-collection-from":"node_modules/core-js/modules/_set-collection-from.js"}],"node_modules/core-js/modules/es7.set.from.js":[function(require,module,exports) {
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
require('./_set-collection-from')('Set');

},{"./_set-collection-from":"node_modules/core-js/modules/_set-collection-from.js"}],"node_modules/core-js/modules/es7.weak-map.from.js":[function(require,module,exports) {
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
require('./_set-collection-from')('WeakMap');

},{"./_set-collection-from":"node_modules/core-js/modules/_set-collection-from.js"}],"node_modules/core-js/modules/es7.weak-set.from.js":[function(require,module,exports) {
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.from
require('./_set-collection-from')('WeakSet');

},{"./_set-collection-from":"node_modules/core-js/modules/_set-collection-from.js"}],"node_modules/core-js/modules/es7.global.js":[function(require,module,exports) {
// https://github.com/tc39/proposal-global
var $export = require('./_export');

$export($export.G, { global: require('./_global') });

},{"./_export":"node_modules/core-js/modules/_export.js","./_global":"node_modules/core-js/modules/_global.js"}],"node_modules/core-js/modules/es7.system.global.js":[function(require,module,exports) {
// https://github.com/tc39/proposal-global
var $export = require('./_export');

$export($export.S, 'System', { global: require('./_global') });

},{"./_export":"node_modules/core-js/modules/_export.js","./_global":"node_modules/core-js/modules/_global.js"}],"node_modules/core-js/modules/es7.error.is-error.js":[function(require,module,exports) {
// https://github.com/ljharb/proposal-is-error
var $export = require('./_export');
var cof = require('./_cof');

$export($export.S, 'Error', {
  isError: function isError(it) {
    return cof(it) === 'Error';
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_cof":"node_modules/core-js/modules/_cof.js"}],"node_modules/core-js/modules/es7.math.clamp.js":[function(require,module,exports) {
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', {
  clamp: function clamp(x, lower, upper) {
    return Math.min(upper, Math.max(lower, x));
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js"}],"node_modules/core-js/modules/es7.math.deg-per-rad.js":[function(require,module,exports) {
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', { DEG_PER_RAD: Math.PI / 180 });

},{"./_export":"node_modules/core-js/modules/_export.js"}],"node_modules/core-js/modules/es7.math.degrees.js":[function(require,module,exports) {
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');
var RAD_PER_DEG = 180 / Math.PI;

$export($export.S, 'Math', {
  degrees: function degrees(radians) {
    return radians * RAD_PER_DEG;
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js"}],"node_modules/core-js/modules/_math-scale.js":[function(require,module,exports) {
// https://rwaldron.github.io/proposal-math-extensions/
module.exports = Math.scale || function scale(x, inLow, inHigh, outLow, outHigh) {
  if (
    arguments.length === 0
      // eslint-disable-next-line no-self-compare
      || x != x
      // eslint-disable-next-line no-self-compare
      || inLow != inLow
      // eslint-disable-next-line no-self-compare
      || inHigh != inHigh
      // eslint-disable-next-line no-self-compare
      || outLow != outLow
      // eslint-disable-next-line no-self-compare
      || outHigh != outHigh
  ) return NaN;
  if (x === Infinity || x === -Infinity) return x;
  return (x - inLow) * (outHigh - outLow) / (inHigh - inLow) + outLow;
};

},{}],"node_modules/core-js/modules/es7.math.fscale.js":[function(require,module,exports) {
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');
var scale = require('./_math-scale');
var fround = require('./_math-fround');

$export($export.S, 'Math', {
  fscale: function fscale(x, inLow, inHigh, outLow, outHigh) {
    return fround(scale(x, inLow, inHigh, outLow, outHigh));
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_math-scale":"node_modules/core-js/modules/_math-scale.js","./_math-fround":"node_modules/core-js/modules/_math-fround.js"}],"node_modules/core-js/modules/es7.math.iaddh.js":[function(require,module,exports) {
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  iaddh: function iaddh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js"}],"node_modules/core-js/modules/es7.math.isubh.js":[function(require,module,exports) {
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  isubh: function isubh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js"}],"node_modules/core-js/modules/es7.math.imulh.js":[function(require,module,exports) {
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  imulh: function imulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >> 16;
    var v1 = $v >> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js"}],"node_modules/core-js/modules/es7.math.rad-per-deg.js":[function(require,module,exports) {
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', { RAD_PER_DEG: 180 / Math.PI });

},{"./_export":"node_modules/core-js/modules/_export.js"}],"node_modules/core-js/modules/es7.math.radians.js":[function(require,module,exports) {
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');
var DEG_PER_RAD = Math.PI / 180;

$export($export.S, 'Math', {
  radians: function radians(degrees) {
    return degrees * DEG_PER_RAD;
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js"}],"node_modules/core-js/modules/es7.math.scale.js":[function(require,module,exports) {
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', { scale: require('./_math-scale') });

},{"./_export":"node_modules/core-js/modules/_export.js","./_math-scale":"node_modules/core-js/modules/_math-scale.js"}],"node_modules/core-js/modules/es7.math.umulh.js":[function(require,module,exports) {
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  umulh: function umulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >>> 16;
    var v1 = $v >>> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js"}],"node_modules/core-js/modules/es7.math.signbit.js":[function(require,module,exports) {
// http://jfbastien.github.io/papers/Math.signbit.html
var $export = require('./_export');

$export($export.S, 'Math', { signbit: function signbit(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) != x ? x : x == 0 ? 1 / x == Infinity : x > 0;
} });

},{"./_export":"node_modules/core-js/modules/_export.js"}],"node_modules/core-js/modules/es7.promise.finally.js":[function(require,module,exports) {

// https://github.com/tc39/proposal-promise-finally
'use strict';
var $export = require('./_export');
var core = require('./_core');
var global = require('./_global');
var speciesConstructor = require('./_species-constructor');
var promiseResolve = require('./_promise-resolve');

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });

},{"./_export":"node_modules/core-js/modules/_export.js","./_core":"node_modules/core-js/modules/_core.js","./_global":"node_modules/core-js/modules/_global.js","./_species-constructor":"node_modules/core-js/modules/_species-constructor.js","./_promise-resolve":"node_modules/core-js/modules/_promise-resolve.js"}],"node_modules/core-js/modules/es7.promise.try.js":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/proposal-promise-try
var $export = require('./_export');
var newPromiseCapability = require('./_new-promise-capability');
var perform = require('./_perform');

$export($export.S, 'Promise', { 'try': function (callbackfn) {
  var promiseCapability = newPromiseCapability.f(this);
  var result = perform(callbackfn);
  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
  return promiseCapability.promise;
} });

},{"./_export":"node_modules/core-js/modules/_export.js","./_new-promise-capability":"node_modules/core-js/modules/_new-promise-capability.js","./_perform":"node_modules/core-js/modules/_perform.js"}],"node_modules/core-js/modules/_metadata.js":[function(require,module,exports) {
var Map = require('./es6.map');
var $export = require('./_export');
var shared = require('./_shared')('metadata');
var store = shared.store || (shared.store = new (require('./es6.weak-map'))());

var getOrCreateMetadataMap = function (target, targetKey, create) {
  var targetMetadata = store.get(target);
  if (!targetMetadata) {
    if (!create) return undefined;
    store.set(target, targetMetadata = new Map());
  }
  var keyMetadata = targetMetadata.get(targetKey);
  if (!keyMetadata) {
    if (!create) return undefined;
    targetMetadata.set(targetKey, keyMetadata = new Map());
  } return keyMetadata;
};
var ordinaryHasOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
};
var ordinaryGetOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
};
var ordinaryDefineOwnMetadata = function (MetadataKey, MetadataValue, O, P) {
  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
};
var ordinaryOwnMetadataKeys = function (target, targetKey) {
  var metadataMap = getOrCreateMetadataMap(target, targetKey, false);
  var keys = [];
  if (metadataMap) metadataMap.forEach(function (_, key) { keys.push(key); });
  return keys;
};
var toMetaKey = function (it) {
  return it === undefined || typeof it == 'symbol' ? it : String(it);
};
var exp = function (O) {
  $export($export.S, 'Reflect', O);
};

module.exports = {
  store: store,
  map: getOrCreateMetadataMap,
  has: ordinaryHasOwnMetadata,
  get: ordinaryGetOwnMetadata,
  set: ordinaryDefineOwnMetadata,
  keys: ordinaryOwnMetadataKeys,
  key: toMetaKey,
  exp: exp
};

},{"./es6.map":"node_modules/core-js/modules/es6.map.js","./_export":"node_modules/core-js/modules/_export.js","./_shared":"node_modules/core-js/modules/_shared.js","./es6.weak-map":"node_modules/core-js/modules/es6.weak-map.js"}],"node_modules/core-js/modules/es7.reflect.define-metadata.js":[function(require,module,exports) {
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var toMetaKey = metadata.key;
var ordinaryDefineOwnMetadata = metadata.set;

metadata.exp({ defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) {
  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
} });

},{"./_metadata":"node_modules/core-js/modules/_metadata.js","./_an-object":"node_modules/core-js/modules/_an-object.js"}],"node_modules/core-js/modules/es7.reflect.delete-metadata.js":[function(require,module,exports) {
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var toMetaKey = metadata.key;
var getOrCreateMetadataMap = metadata.map;
var store = metadata.store;

metadata.exp({ deleteMetadata: function deleteMetadata(metadataKey, target /* , targetKey */) {
  var targetKey = arguments.length < 3 ? undefined : toMetaKey(arguments[2]);
  var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
  if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;
  if (metadataMap.size) return true;
  var targetMetadata = store.get(target);
  targetMetadata['delete'](targetKey);
  return !!targetMetadata.size || store['delete'](target);
} });

},{"./_metadata":"node_modules/core-js/modules/_metadata.js","./_an-object":"node_modules/core-js/modules/_an-object.js"}],"node_modules/core-js/modules/es7.reflect.get-metadata.js":[function(require,module,exports) {
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var getPrototypeOf = require('./_object-gpo');
var ordinaryHasOwnMetadata = metadata.has;
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;

var ordinaryGetMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P);
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
};

metadata.exp({ getMetadata: function getMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_metadata":"node_modules/core-js/modules/_metadata.js","./_an-object":"node_modules/core-js/modules/_an-object.js","./_object-gpo":"node_modules/core-js/modules/_object-gpo.js"}],"node_modules/core-js/modules/es7.reflect.get-metadata-keys.js":[function(require,module,exports) {
var Set = require('./es6.set');
var from = require('./_array-from-iterable');
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var getPrototypeOf = require('./_object-gpo');
var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;

var ordinaryMetadataKeys = function (O, P) {
  var oKeys = ordinaryOwnMetadataKeys(O, P);
  var parent = getPrototypeOf(O);
  if (parent === null) return oKeys;
  var pKeys = ordinaryMetadataKeys(parent, P);
  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
};

metadata.exp({ getMetadataKeys: function getMetadataKeys(target /* , targetKey */) {
  return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
} });

},{"./es6.set":"node_modules/core-js/modules/es6.set.js","./_array-from-iterable":"node_modules/core-js/modules/_array-from-iterable.js","./_metadata":"node_modules/core-js/modules/_metadata.js","./_an-object":"node_modules/core-js/modules/_an-object.js","./_object-gpo":"node_modules/core-js/modules/_object-gpo.js"}],"node_modules/core-js/modules/es7.reflect.get-own-metadata.js":[function(require,module,exports) {
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;

metadata.exp({ getOwnMetadata: function getOwnMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryGetOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_metadata":"node_modules/core-js/modules/_metadata.js","./_an-object":"node_modules/core-js/modules/_an-object.js"}],"node_modules/core-js/modules/es7.reflect.get-own-metadata-keys.js":[function(require,module,exports) {
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;

metadata.exp({ getOwnMetadataKeys: function getOwnMetadataKeys(target /* , targetKey */) {
  return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
} });

},{"./_metadata":"node_modules/core-js/modules/_metadata.js","./_an-object":"node_modules/core-js/modules/_an-object.js"}],"node_modules/core-js/modules/es7.reflect.has-metadata.js":[function(require,module,exports) {
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var getPrototypeOf = require('./_object-gpo');
var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;

var ordinaryHasMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return true;
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
};

metadata.exp({ hasMetadata: function hasMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_metadata":"node_modules/core-js/modules/_metadata.js","./_an-object":"node_modules/core-js/modules/_an-object.js","./_object-gpo":"node_modules/core-js/modules/_object-gpo.js"}],"node_modules/core-js/modules/es7.reflect.has-own-metadata.js":[function(require,module,exports) {
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;

metadata.exp({ hasOwnMetadata: function hasOwnMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryHasOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_metadata":"node_modules/core-js/modules/_metadata.js","./_an-object":"node_modules/core-js/modules/_an-object.js"}],"node_modules/core-js/modules/es7.reflect.metadata.js":[function(require,module,exports) {
var $metadata = require('./_metadata');
var anObject = require('./_an-object');
var aFunction = require('./_a-function');
var toMetaKey = $metadata.key;
var ordinaryDefineOwnMetadata = $metadata.set;

$metadata.exp({ metadata: function metadata(metadataKey, metadataValue) {
  return function decorator(target, targetKey) {
    ordinaryDefineOwnMetadata(
      metadataKey, metadataValue,
      (targetKey !== undefined ? anObject : aFunction)(target),
      toMetaKey(targetKey)
    );
  };
} });

},{"./_metadata":"node_modules/core-js/modules/_metadata.js","./_an-object":"node_modules/core-js/modules/_an-object.js","./_a-function":"node_modules/core-js/modules/_a-function.js"}],"node_modules/core-js/modules/es7.asap.js":[function(require,module,exports) {

// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
var $export = require('./_export');
var microtask = require('./_microtask')();
var process = require('./_global').process;
var isNode = require('./_cof')(process) == 'process';

$export($export.G, {
  asap: function asap(fn) {
    var domain = isNode && process.domain;
    microtask(domain ? domain.bind(fn) : fn);
  }
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_microtask":"node_modules/core-js/modules/_microtask.js","./_global":"node_modules/core-js/modules/_global.js","./_cof":"node_modules/core-js/modules/_cof.js"}],"node_modules/core-js/modules/es7.observable.js":[function(require,module,exports) {

'use strict';
// https://github.com/zenparsing/es-observable
var $export = require('./_export');
var global = require('./_global');
var core = require('./_core');
var microtask = require('./_microtask')();
var OBSERVABLE = require('./_wks')('observable');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var anInstance = require('./_an-instance');
var redefineAll = require('./_redefine-all');
var hide = require('./_hide');
var forOf = require('./_for-of');
var RETURN = forOf.RETURN;

var getMethod = function (fn) {
  return fn == null ? undefined : aFunction(fn);
};

var cleanupSubscription = function (subscription) {
  var cleanup = subscription._c;
  if (cleanup) {
    subscription._c = undefined;
    cleanup();
  }
};

var subscriptionClosed = function (subscription) {
  return subscription._o === undefined;
};

var closeSubscription = function (subscription) {
  if (!subscriptionClosed(subscription)) {
    subscription._o = undefined;
    cleanupSubscription(subscription);
  }
};

var Subscription = function (observer, subscriber) {
  anObject(observer);
  this._c = undefined;
  this._o = observer;
  observer = new SubscriptionObserver(this);
  try {
    var cleanup = subscriber(observer);
    var subscription = cleanup;
    if (cleanup != null) {
      if (typeof cleanup.unsubscribe === 'function') cleanup = function () { subscription.unsubscribe(); };
      else aFunction(cleanup);
      this._c = cleanup;
    }
  } catch (e) {
    observer.error(e);
    return;
  } if (subscriptionClosed(this)) cleanupSubscription(this);
};

Subscription.prototype = redefineAll({}, {
  unsubscribe: function unsubscribe() { closeSubscription(this); }
});

var SubscriptionObserver = function (subscription) {
  this._s = subscription;
};

SubscriptionObserver.prototype = redefineAll({}, {
  next: function next(value) {
    var subscription = this._s;
    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;
      try {
        var m = getMethod(observer.next);
        if (m) return m.call(observer, value);
      } catch (e) {
        try {
          closeSubscription(subscription);
        } finally {
          throw e;
        }
      }
    }
  },
  error: function error(value) {
    var subscription = this._s;
    if (subscriptionClosed(subscription)) throw value;
    var observer = subscription._o;
    subscription._o = undefined;
    try {
      var m = getMethod(observer.error);
      if (!m) throw value;
      value = m.call(observer, value);
    } catch (e) {
      try {
        cleanupSubscription(subscription);
      } finally {
        throw e;
      }
    } cleanupSubscription(subscription);
    return value;
  },
  complete: function complete(value) {
    var subscription = this._s;
    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;
      subscription._o = undefined;
      try {
        var m = getMethod(observer.complete);
        value = m ? m.call(observer, value) : undefined;
      } catch (e) {
        try {
          cleanupSubscription(subscription);
        } finally {
          throw e;
        }
      } cleanupSubscription(subscription);
      return value;
    }
  }
});

var $Observable = function Observable(subscriber) {
  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
};

redefineAll($Observable.prototype, {
  subscribe: function subscribe(observer) {
    return new Subscription(observer, this._f);
  },
  forEach: function forEach(fn) {
    var that = this;
    return new (core.Promise || global.Promise)(function (resolve, reject) {
      aFunction(fn);
      var subscription = that.subscribe({
        next: function (value) {
          try {
            return fn(value);
          } catch (e) {
            reject(e);
            subscription.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
    });
  }
});

redefineAll($Observable, {
  from: function from(x) {
    var C = typeof this === 'function' ? this : $Observable;
    var method = getMethod(anObject(x)[OBSERVABLE]);
    if (method) {
      var observable = anObject(method.call(x));
      return observable.constructor === C ? observable : new C(function (observer) {
        return observable.subscribe(observer);
      });
    }
    return new C(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          try {
            if (forOf(x, false, function (it) {
              observer.next(it);
              if (done) return RETURN;
            }) === RETURN) return;
          } catch (e) {
            if (done) throw e;
            observer.error(e);
            return;
          } observer.complete();
        }
      });
      return function () { done = true; };
    });
  },
  of: function of() {
    for (var i = 0, l = arguments.length, items = new Array(l); i < l;) items[i] = arguments[i++];
    return new (typeof this === 'function' ? this : $Observable)(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          for (var j = 0; j < items.length; ++j) {
            observer.next(items[j]);
            if (done) return;
          } observer.complete();
        }
      });
      return function () { done = true; };
    });
  }
});

hide($Observable.prototype, OBSERVABLE, function () { return this; });

$export($export.G, { Observable: $Observable });

require('./_set-species')('Observable');

},{"./_export":"node_modules/core-js/modules/_export.js","./_global":"node_modules/core-js/modules/_global.js","./_core":"node_modules/core-js/modules/_core.js","./_microtask":"node_modules/core-js/modules/_microtask.js","./_wks":"node_modules/core-js/modules/_wks.js","./_a-function":"node_modules/core-js/modules/_a-function.js","./_an-object":"node_modules/core-js/modules/_an-object.js","./_an-instance":"node_modules/core-js/modules/_an-instance.js","./_redefine-all":"node_modules/core-js/modules/_redefine-all.js","./_hide":"node_modules/core-js/modules/_hide.js","./_for-of":"node_modules/core-js/modules/_for-of.js","./_set-species":"node_modules/core-js/modules/_set-species.js"}],"node_modules/core-js/modules/web.timers.js":[function(require,module,exports) {

// ie9- setTimeout & setInterval additional parameters fix
var global = require('./_global');
var $export = require('./_export');
var userAgent = require('./_user-agent');
var slice = [].slice;
var MSIE = /MSIE .\./.test(userAgent); // <- dirty ie9- check
var wrap = function (set) {
  return function (fn, time /* , ...args */) {
    var boundArgs = arguments.length > 2;
    var args = boundArgs ? slice.call(arguments, 2) : false;
    return set(boundArgs ? function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
    } : fn, time);
  };
};
$export($export.G + $export.B + $export.F * MSIE, {
  setTimeout: wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});

},{"./_global":"node_modules/core-js/modules/_global.js","./_export":"node_modules/core-js/modules/_export.js","./_user-agent":"node_modules/core-js/modules/_user-agent.js"}],"node_modules/core-js/modules/web.immediate.js":[function(require,module,exports) {
var $export = require('./_export');
var $task = require('./_task');
$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});

},{"./_export":"node_modules/core-js/modules/_export.js","./_task":"node_modules/core-js/modules/_task.js"}],"node_modules/core-js/modules/web.dom.iterable.js":[function(require,module,exports) {

var $iterators = require('./es6.array.iterator');
var getKeys = require('./_object-keys');
var redefine = require('./_redefine');
var global = require('./_global');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var wks = require('./_wks');
var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}

},{"./es6.array.iterator":"node_modules/core-js/modules/es6.array.iterator.js","./_object-keys":"node_modules/core-js/modules/_object-keys.js","./_redefine":"node_modules/core-js/modules/_redefine.js","./_global":"node_modules/core-js/modules/_global.js","./_hide":"node_modules/core-js/modules/_hide.js","./_iterators":"node_modules/core-js/modules/_iterators.js","./_wks":"node_modules/core-js/modules/_wks.js"}],"node_modules/core-js/shim.js":[function(require,module,exports) {
require('./modules/es6.symbol');
require('./modules/es6.object.create');
require('./modules/es6.object.define-property');
require('./modules/es6.object.define-properties');
require('./modules/es6.object.get-own-property-descriptor');
require('./modules/es6.object.get-prototype-of');
require('./modules/es6.object.keys');
require('./modules/es6.object.get-own-property-names');
require('./modules/es6.object.freeze');
require('./modules/es6.object.seal');
require('./modules/es6.object.prevent-extensions');
require('./modules/es6.object.is-frozen');
require('./modules/es6.object.is-sealed');
require('./modules/es6.object.is-extensible');
require('./modules/es6.object.assign');
require('./modules/es6.object.is');
require('./modules/es6.object.set-prototype-of');
require('./modules/es6.object.to-string');
require('./modules/es6.function.bind');
require('./modules/es6.function.name');
require('./modules/es6.function.has-instance');
require('./modules/es6.parse-int');
require('./modules/es6.parse-float');
require('./modules/es6.number.constructor');
require('./modules/es6.number.to-fixed');
require('./modules/es6.number.to-precision');
require('./modules/es6.number.epsilon');
require('./modules/es6.number.is-finite');
require('./modules/es6.number.is-integer');
require('./modules/es6.number.is-nan');
require('./modules/es6.number.is-safe-integer');
require('./modules/es6.number.max-safe-integer');
require('./modules/es6.number.min-safe-integer');
require('./modules/es6.number.parse-float');
require('./modules/es6.number.parse-int');
require('./modules/es6.math.acosh');
require('./modules/es6.math.asinh');
require('./modules/es6.math.atanh');
require('./modules/es6.math.cbrt');
require('./modules/es6.math.clz32');
require('./modules/es6.math.cosh');
require('./modules/es6.math.expm1');
require('./modules/es6.math.fround');
require('./modules/es6.math.hypot');
require('./modules/es6.math.imul');
require('./modules/es6.math.log10');
require('./modules/es6.math.log1p');
require('./modules/es6.math.log2');
require('./modules/es6.math.sign');
require('./modules/es6.math.sinh');
require('./modules/es6.math.tanh');
require('./modules/es6.math.trunc');
require('./modules/es6.string.from-code-point');
require('./modules/es6.string.raw');
require('./modules/es6.string.trim');
require('./modules/es6.string.iterator');
require('./modules/es6.string.code-point-at');
require('./modules/es6.string.ends-with');
require('./modules/es6.string.includes');
require('./modules/es6.string.repeat');
require('./modules/es6.string.starts-with');
require('./modules/es6.string.anchor');
require('./modules/es6.string.big');
require('./modules/es6.string.blink');
require('./modules/es6.string.bold');
require('./modules/es6.string.fixed');
require('./modules/es6.string.fontcolor');
require('./modules/es6.string.fontsize');
require('./modules/es6.string.italics');
require('./modules/es6.string.link');
require('./modules/es6.string.small');
require('./modules/es6.string.strike');
require('./modules/es6.string.sub');
require('./modules/es6.string.sup');
require('./modules/es6.date.now');
require('./modules/es6.date.to-json');
require('./modules/es6.date.to-iso-string');
require('./modules/es6.date.to-string');
require('./modules/es6.date.to-primitive');
require('./modules/es6.array.is-array');
require('./modules/es6.array.from');
require('./modules/es6.array.of');
require('./modules/es6.array.join');
require('./modules/es6.array.slice');
require('./modules/es6.array.sort');
require('./modules/es6.array.for-each');
require('./modules/es6.array.map');
require('./modules/es6.array.filter');
require('./modules/es6.array.some');
require('./modules/es6.array.every');
require('./modules/es6.array.reduce');
require('./modules/es6.array.reduce-right');
require('./modules/es6.array.index-of');
require('./modules/es6.array.last-index-of');
require('./modules/es6.array.copy-within');
require('./modules/es6.array.fill');
require('./modules/es6.array.find');
require('./modules/es6.array.find-index');
require('./modules/es6.array.species');
require('./modules/es6.array.iterator');
require('./modules/es6.regexp.constructor');
require('./modules/es6.regexp.exec');
require('./modules/es6.regexp.to-string');
require('./modules/es6.regexp.flags');
require('./modules/es6.regexp.match');
require('./modules/es6.regexp.replace');
require('./modules/es6.regexp.search');
require('./modules/es6.regexp.split');
require('./modules/es6.promise');
require('./modules/es6.map');
require('./modules/es6.set');
require('./modules/es6.weak-map');
require('./modules/es6.weak-set');
require('./modules/es6.typed.array-buffer');
require('./modules/es6.typed.data-view');
require('./modules/es6.typed.int8-array');
require('./modules/es6.typed.uint8-array');
require('./modules/es6.typed.uint8-clamped-array');
require('./modules/es6.typed.int16-array');
require('./modules/es6.typed.uint16-array');
require('./modules/es6.typed.int32-array');
require('./modules/es6.typed.uint32-array');
require('./modules/es6.typed.float32-array');
require('./modules/es6.typed.float64-array');
require('./modules/es6.reflect.apply');
require('./modules/es6.reflect.construct');
require('./modules/es6.reflect.define-property');
require('./modules/es6.reflect.delete-property');
require('./modules/es6.reflect.enumerate');
require('./modules/es6.reflect.get');
require('./modules/es6.reflect.get-own-property-descriptor');
require('./modules/es6.reflect.get-prototype-of');
require('./modules/es6.reflect.has');
require('./modules/es6.reflect.is-extensible');
require('./modules/es6.reflect.own-keys');
require('./modules/es6.reflect.prevent-extensions');
require('./modules/es6.reflect.set');
require('./modules/es6.reflect.set-prototype-of');
require('./modules/es7.array.includes');
require('./modules/es7.array.flat-map');
require('./modules/es7.array.flatten');
require('./modules/es7.string.at');
require('./modules/es7.string.pad-start');
require('./modules/es7.string.pad-end');
require('./modules/es7.string.trim-left');
require('./modules/es7.string.trim-right');
require('./modules/es7.string.match-all');
require('./modules/es7.symbol.async-iterator');
require('./modules/es7.symbol.observable');
require('./modules/es7.object.get-own-property-descriptors');
require('./modules/es7.object.values');
require('./modules/es7.object.entries');
require('./modules/es7.object.define-getter');
require('./modules/es7.object.define-setter');
require('./modules/es7.object.lookup-getter');
require('./modules/es7.object.lookup-setter');
require('./modules/es7.map.to-json');
require('./modules/es7.set.to-json');
require('./modules/es7.map.of');
require('./modules/es7.set.of');
require('./modules/es7.weak-map.of');
require('./modules/es7.weak-set.of');
require('./modules/es7.map.from');
require('./modules/es7.set.from');
require('./modules/es7.weak-map.from');
require('./modules/es7.weak-set.from');
require('./modules/es7.global');
require('./modules/es7.system.global');
require('./modules/es7.error.is-error');
require('./modules/es7.math.clamp');
require('./modules/es7.math.deg-per-rad');
require('./modules/es7.math.degrees');
require('./modules/es7.math.fscale');
require('./modules/es7.math.iaddh');
require('./modules/es7.math.isubh');
require('./modules/es7.math.imulh');
require('./modules/es7.math.rad-per-deg');
require('./modules/es7.math.radians');
require('./modules/es7.math.scale');
require('./modules/es7.math.umulh');
require('./modules/es7.math.signbit');
require('./modules/es7.promise.finally');
require('./modules/es7.promise.try');
require('./modules/es7.reflect.define-metadata');
require('./modules/es7.reflect.delete-metadata');
require('./modules/es7.reflect.get-metadata');
require('./modules/es7.reflect.get-metadata-keys');
require('./modules/es7.reflect.get-own-metadata');
require('./modules/es7.reflect.get-own-metadata-keys');
require('./modules/es7.reflect.has-metadata');
require('./modules/es7.reflect.has-own-metadata');
require('./modules/es7.reflect.metadata');
require('./modules/es7.asap');
require('./modules/es7.observable');
require('./modules/web.timers');
require('./modules/web.immediate');
require('./modules/web.dom.iterable');
module.exports = require('./modules/_core');

},{"./modules/es6.symbol":"node_modules/core-js/modules/es6.symbol.js","./modules/es6.object.create":"node_modules/core-js/modules/es6.object.create.js","./modules/es6.object.define-property":"node_modules/core-js/modules/es6.object.define-property.js","./modules/es6.object.define-properties":"node_modules/core-js/modules/es6.object.define-properties.js","./modules/es6.object.get-own-property-descriptor":"node_modules/core-js/modules/es6.object.get-own-property-descriptor.js","./modules/es6.object.get-prototype-of":"node_modules/core-js/modules/es6.object.get-prototype-of.js","./modules/es6.object.keys":"node_modules/core-js/modules/es6.object.keys.js","./modules/es6.object.get-own-property-names":"node_modules/core-js/modules/es6.object.get-own-property-names.js","./modules/es6.object.freeze":"node_modules/core-js/modules/es6.object.freeze.js","./modules/es6.object.seal":"node_modules/core-js/modules/es6.object.seal.js","./modules/es6.object.prevent-extensions":"node_modules/core-js/modules/es6.object.prevent-extensions.js","./modules/es6.object.is-frozen":"node_modules/core-js/modules/es6.object.is-frozen.js","./modules/es6.object.is-sealed":"node_modules/core-js/modules/es6.object.is-sealed.js","./modules/es6.object.is-extensible":"node_modules/core-js/modules/es6.object.is-extensible.js","./modules/es6.object.assign":"node_modules/core-js/modules/es6.object.assign.js","./modules/es6.object.is":"node_modules/core-js/modules/es6.object.is.js","./modules/es6.object.set-prototype-of":"node_modules/core-js/modules/es6.object.set-prototype-of.js","./modules/es6.object.to-string":"node_modules/core-js/modules/es6.object.to-string.js","./modules/es6.function.bind":"node_modules/core-js/modules/es6.function.bind.js","./modules/es6.function.name":"node_modules/core-js/modules/es6.function.name.js","./modules/es6.function.has-instance":"node_modules/core-js/modules/es6.function.has-instance.js","./modules/es6.parse-int":"node_modules/core-js/modules/es6.parse-int.js","./modules/es6.parse-float":"node_modules/core-js/modules/es6.parse-float.js","./modules/es6.number.constructor":"node_modules/core-js/modules/es6.number.constructor.js","./modules/es6.number.to-fixed":"node_modules/core-js/modules/es6.number.to-fixed.js","./modules/es6.number.to-precision":"node_modules/core-js/modules/es6.number.to-precision.js","./modules/es6.number.epsilon":"node_modules/core-js/modules/es6.number.epsilon.js","./modules/es6.number.is-finite":"node_modules/core-js/modules/es6.number.is-finite.js","./modules/es6.number.is-integer":"node_modules/core-js/modules/es6.number.is-integer.js","./modules/es6.number.is-nan":"node_modules/core-js/modules/es6.number.is-nan.js","./modules/es6.number.is-safe-integer":"node_modules/core-js/modules/es6.number.is-safe-integer.js","./modules/es6.number.max-safe-integer":"node_modules/core-js/modules/es6.number.max-safe-integer.js","./modules/es6.number.min-safe-integer":"node_modules/core-js/modules/es6.number.min-safe-integer.js","./modules/es6.number.parse-float":"node_modules/core-js/modules/es6.number.parse-float.js","./modules/es6.number.parse-int":"node_modules/core-js/modules/es6.number.parse-int.js","./modules/es6.math.acosh":"node_modules/core-js/modules/es6.math.acosh.js","./modules/es6.math.asinh":"node_modules/core-js/modules/es6.math.asinh.js","./modules/es6.math.atanh":"node_modules/core-js/modules/es6.math.atanh.js","./modules/es6.math.cbrt":"node_modules/core-js/modules/es6.math.cbrt.js","./modules/es6.math.clz32":"node_modules/core-js/modules/es6.math.clz32.js","./modules/es6.math.cosh":"node_modules/core-js/modules/es6.math.cosh.js","./modules/es6.math.expm1":"node_modules/core-js/modules/es6.math.expm1.js","./modules/es6.math.fround":"node_modules/core-js/modules/es6.math.fround.js","./modules/es6.math.hypot":"node_modules/core-js/modules/es6.math.hypot.js","./modules/es6.math.imul":"node_modules/core-js/modules/es6.math.imul.js","./modules/es6.math.log10":"node_modules/core-js/modules/es6.math.log10.js","./modules/es6.math.log1p":"node_modules/core-js/modules/es6.math.log1p.js","./modules/es6.math.log2":"node_modules/core-js/modules/es6.math.log2.js","./modules/es6.math.sign":"node_modules/core-js/modules/es6.math.sign.js","./modules/es6.math.sinh":"node_modules/core-js/modules/es6.math.sinh.js","./modules/es6.math.tanh":"node_modules/core-js/modules/es6.math.tanh.js","./modules/es6.math.trunc":"node_modules/core-js/modules/es6.math.trunc.js","./modules/es6.string.from-code-point":"node_modules/core-js/modules/es6.string.from-code-point.js","./modules/es6.string.raw":"node_modules/core-js/modules/es6.string.raw.js","./modules/es6.string.trim":"node_modules/core-js/modules/es6.string.trim.js","./modules/es6.string.iterator":"node_modules/core-js/modules/es6.string.iterator.js","./modules/es6.string.code-point-at":"node_modules/core-js/modules/es6.string.code-point-at.js","./modules/es6.string.ends-with":"node_modules/core-js/modules/es6.string.ends-with.js","./modules/es6.string.includes":"node_modules/core-js/modules/es6.string.includes.js","./modules/es6.string.repeat":"node_modules/core-js/modules/es6.string.repeat.js","./modules/es6.string.starts-with":"node_modules/core-js/modules/es6.string.starts-with.js","./modules/es6.string.anchor":"node_modules/core-js/modules/es6.string.anchor.js","./modules/es6.string.big":"node_modules/core-js/modules/es6.string.big.js","./modules/es6.string.blink":"node_modules/core-js/modules/es6.string.blink.js","./modules/es6.string.bold":"node_modules/core-js/modules/es6.string.bold.js","./modules/es6.string.fixed":"node_modules/core-js/modules/es6.string.fixed.js","./modules/es6.string.fontcolor":"node_modules/core-js/modules/es6.string.fontcolor.js","./modules/es6.string.fontsize":"node_modules/core-js/modules/es6.string.fontsize.js","./modules/es6.string.italics":"node_modules/core-js/modules/es6.string.italics.js","./modules/es6.string.link":"node_modules/core-js/modules/es6.string.link.js","./modules/es6.string.small":"node_modules/core-js/modules/es6.string.small.js","./modules/es6.string.strike":"node_modules/core-js/modules/es6.string.strike.js","./modules/es6.string.sub":"node_modules/core-js/modules/es6.string.sub.js","./modules/es6.string.sup":"node_modules/core-js/modules/es6.string.sup.js","./modules/es6.date.now":"node_modules/core-js/modules/es6.date.now.js","./modules/es6.date.to-json":"node_modules/core-js/modules/es6.date.to-json.js","./modules/es6.date.to-iso-string":"node_modules/core-js/modules/es6.date.to-iso-string.js","./modules/es6.date.to-string":"node_modules/core-js/modules/es6.date.to-string.js","./modules/es6.date.to-primitive":"node_modules/core-js/modules/es6.date.to-primitive.js","./modules/es6.array.is-array":"node_modules/core-js/modules/es6.array.is-array.js","./modules/es6.array.from":"node_modules/core-js/modules/es6.array.from.js","./modules/es6.array.of":"node_modules/core-js/modules/es6.array.of.js","./modules/es6.array.join":"node_modules/core-js/modules/es6.array.join.js","./modules/es6.array.slice":"node_modules/core-js/modules/es6.array.slice.js","./modules/es6.array.sort":"node_modules/core-js/modules/es6.array.sort.js","./modules/es6.array.for-each":"node_modules/core-js/modules/es6.array.for-each.js","./modules/es6.array.map":"node_modules/core-js/modules/es6.array.map.js","./modules/es6.array.filter":"node_modules/core-js/modules/es6.array.filter.js","./modules/es6.array.some":"node_modules/core-js/modules/es6.array.some.js","./modules/es6.array.every":"node_modules/core-js/modules/es6.array.every.js","./modules/es6.array.reduce":"node_modules/core-js/modules/es6.array.reduce.js","./modules/es6.array.reduce-right":"node_modules/core-js/modules/es6.array.reduce-right.js","./modules/es6.array.index-of":"node_modules/core-js/modules/es6.array.index-of.js","./modules/es6.array.last-index-of":"node_modules/core-js/modules/es6.array.last-index-of.js","./modules/es6.array.copy-within":"node_modules/core-js/modules/es6.array.copy-within.js","./modules/es6.array.fill":"node_modules/core-js/modules/es6.array.fill.js","./modules/es6.array.find":"node_modules/core-js/modules/es6.array.find.js","./modules/es6.array.find-index":"node_modules/core-js/modules/es6.array.find-index.js","./modules/es6.array.species":"node_modules/core-js/modules/es6.array.species.js","./modules/es6.array.iterator":"node_modules/core-js/modules/es6.array.iterator.js","./modules/es6.regexp.constructor":"node_modules/core-js/modules/es6.regexp.constructor.js","./modules/es6.regexp.exec":"node_modules/core-js/modules/es6.regexp.exec.js","./modules/es6.regexp.to-string":"node_modules/core-js/modules/es6.regexp.to-string.js","./modules/es6.regexp.flags":"node_modules/core-js/modules/es6.regexp.flags.js","./modules/es6.regexp.match":"node_modules/core-js/modules/es6.regexp.match.js","./modules/es6.regexp.replace":"node_modules/core-js/modules/es6.regexp.replace.js","./modules/es6.regexp.search":"node_modules/core-js/modules/es6.regexp.search.js","./modules/es6.regexp.split":"node_modules/core-js/modules/es6.regexp.split.js","./modules/es6.promise":"node_modules/core-js/modules/es6.promise.js","./modules/es6.map":"node_modules/core-js/modules/es6.map.js","./modules/es6.set":"node_modules/core-js/modules/es6.set.js","./modules/es6.weak-map":"node_modules/core-js/modules/es6.weak-map.js","./modules/es6.weak-set":"node_modules/core-js/modules/es6.weak-set.js","./modules/es6.typed.array-buffer":"node_modules/core-js/modules/es6.typed.array-buffer.js","./modules/es6.typed.data-view":"node_modules/core-js/modules/es6.typed.data-view.js","./modules/es6.typed.int8-array":"node_modules/core-js/modules/es6.typed.int8-array.js","./modules/es6.typed.uint8-array":"node_modules/core-js/modules/es6.typed.uint8-array.js","./modules/es6.typed.uint8-clamped-array":"node_modules/core-js/modules/es6.typed.uint8-clamped-array.js","./modules/es6.typed.int16-array":"node_modules/core-js/modules/es6.typed.int16-array.js","./modules/es6.typed.uint16-array":"node_modules/core-js/modules/es6.typed.uint16-array.js","./modules/es6.typed.int32-array":"node_modules/core-js/modules/es6.typed.int32-array.js","./modules/es6.typed.uint32-array":"node_modules/core-js/modules/es6.typed.uint32-array.js","./modules/es6.typed.float32-array":"node_modules/core-js/modules/es6.typed.float32-array.js","./modules/es6.typed.float64-array":"node_modules/core-js/modules/es6.typed.float64-array.js","./modules/es6.reflect.apply":"node_modules/core-js/modules/es6.reflect.apply.js","./modules/es6.reflect.construct":"node_modules/core-js/modules/es6.reflect.construct.js","./modules/es6.reflect.define-property":"node_modules/core-js/modules/es6.reflect.define-property.js","./modules/es6.reflect.delete-property":"node_modules/core-js/modules/es6.reflect.delete-property.js","./modules/es6.reflect.enumerate":"node_modules/core-js/modules/es6.reflect.enumerate.js","./modules/es6.reflect.get":"node_modules/core-js/modules/es6.reflect.get.js","./modules/es6.reflect.get-own-property-descriptor":"node_modules/core-js/modules/es6.reflect.get-own-property-descriptor.js","./modules/es6.reflect.get-prototype-of":"node_modules/core-js/modules/es6.reflect.get-prototype-of.js","./modules/es6.reflect.has":"node_modules/core-js/modules/es6.reflect.has.js","./modules/es6.reflect.is-extensible":"node_modules/core-js/modules/es6.reflect.is-extensible.js","./modules/es6.reflect.own-keys":"node_modules/core-js/modules/es6.reflect.own-keys.js","./modules/es6.reflect.prevent-extensions":"node_modules/core-js/modules/es6.reflect.prevent-extensions.js","./modules/es6.reflect.set":"node_modules/core-js/modules/es6.reflect.set.js","./modules/es6.reflect.set-prototype-of":"node_modules/core-js/modules/es6.reflect.set-prototype-of.js","./modules/es7.array.includes":"node_modules/core-js/modules/es7.array.includes.js","./modules/es7.array.flat-map":"node_modules/core-js/modules/es7.array.flat-map.js","./modules/es7.array.flatten":"node_modules/core-js/modules/es7.array.flatten.js","./modules/es7.string.at":"node_modules/core-js/modules/es7.string.at.js","./modules/es7.string.pad-start":"node_modules/core-js/modules/es7.string.pad-start.js","./modules/es7.string.pad-end":"node_modules/core-js/modules/es7.string.pad-end.js","./modules/es7.string.trim-left":"node_modules/core-js/modules/es7.string.trim-left.js","./modules/es7.string.trim-right":"node_modules/core-js/modules/es7.string.trim-right.js","./modules/es7.string.match-all":"node_modules/core-js/modules/es7.string.match-all.js","./modules/es7.symbol.async-iterator":"node_modules/core-js/modules/es7.symbol.async-iterator.js","./modules/es7.symbol.observable":"node_modules/core-js/modules/es7.symbol.observable.js","./modules/es7.object.get-own-property-descriptors":"node_modules/core-js/modules/es7.object.get-own-property-descriptors.js","./modules/es7.object.values":"node_modules/core-js/modules/es7.object.values.js","./modules/es7.object.entries":"node_modules/core-js/modules/es7.object.entries.js","./modules/es7.object.define-getter":"node_modules/core-js/modules/es7.object.define-getter.js","./modules/es7.object.define-setter":"node_modules/core-js/modules/es7.object.define-setter.js","./modules/es7.object.lookup-getter":"node_modules/core-js/modules/es7.object.lookup-getter.js","./modules/es7.object.lookup-setter":"node_modules/core-js/modules/es7.object.lookup-setter.js","./modules/es7.map.to-json":"node_modules/core-js/modules/es7.map.to-json.js","./modules/es7.set.to-json":"node_modules/core-js/modules/es7.set.to-json.js","./modules/es7.map.of":"node_modules/core-js/modules/es7.map.of.js","./modules/es7.set.of":"node_modules/core-js/modules/es7.set.of.js","./modules/es7.weak-map.of":"node_modules/core-js/modules/es7.weak-map.of.js","./modules/es7.weak-set.of":"node_modules/core-js/modules/es7.weak-set.of.js","./modules/es7.map.from":"node_modules/core-js/modules/es7.map.from.js","./modules/es7.set.from":"node_modules/core-js/modules/es7.set.from.js","./modules/es7.weak-map.from":"node_modules/core-js/modules/es7.weak-map.from.js","./modules/es7.weak-set.from":"node_modules/core-js/modules/es7.weak-set.from.js","./modules/es7.global":"node_modules/core-js/modules/es7.global.js","./modules/es7.system.global":"node_modules/core-js/modules/es7.system.global.js","./modules/es7.error.is-error":"node_modules/core-js/modules/es7.error.is-error.js","./modules/es7.math.clamp":"node_modules/core-js/modules/es7.math.clamp.js","./modules/es7.math.deg-per-rad":"node_modules/core-js/modules/es7.math.deg-per-rad.js","./modules/es7.math.degrees":"node_modules/core-js/modules/es7.math.degrees.js","./modules/es7.math.fscale":"node_modules/core-js/modules/es7.math.fscale.js","./modules/es7.math.iaddh":"node_modules/core-js/modules/es7.math.iaddh.js","./modules/es7.math.isubh":"node_modules/core-js/modules/es7.math.isubh.js","./modules/es7.math.imulh":"node_modules/core-js/modules/es7.math.imulh.js","./modules/es7.math.rad-per-deg":"node_modules/core-js/modules/es7.math.rad-per-deg.js","./modules/es7.math.radians":"node_modules/core-js/modules/es7.math.radians.js","./modules/es7.math.scale":"node_modules/core-js/modules/es7.math.scale.js","./modules/es7.math.umulh":"node_modules/core-js/modules/es7.math.umulh.js","./modules/es7.math.signbit":"node_modules/core-js/modules/es7.math.signbit.js","./modules/es7.promise.finally":"node_modules/core-js/modules/es7.promise.finally.js","./modules/es7.promise.try":"node_modules/core-js/modules/es7.promise.try.js","./modules/es7.reflect.define-metadata":"node_modules/core-js/modules/es7.reflect.define-metadata.js","./modules/es7.reflect.delete-metadata":"node_modules/core-js/modules/es7.reflect.delete-metadata.js","./modules/es7.reflect.get-metadata":"node_modules/core-js/modules/es7.reflect.get-metadata.js","./modules/es7.reflect.get-metadata-keys":"node_modules/core-js/modules/es7.reflect.get-metadata-keys.js","./modules/es7.reflect.get-own-metadata":"node_modules/core-js/modules/es7.reflect.get-own-metadata.js","./modules/es7.reflect.get-own-metadata-keys":"node_modules/core-js/modules/es7.reflect.get-own-metadata-keys.js","./modules/es7.reflect.has-metadata":"node_modules/core-js/modules/es7.reflect.has-metadata.js","./modules/es7.reflect.has-own-metadata":"node_modules/core-js/modules/es7.reflect.has-own-metadata.js","./modules/es7.reflect.metadata":"node_modules/core-js/modules/es7.reflect.metadata.js","./modules/es7.asap":"node_modules/core-js/modules/es7.asap.js","./modules/es7.observable":"node_modules/core-js/modules/es7.observable.js","./modules/web.timers":"node_modules/core-js/modules/web.timers.js","./modules/web.immediate":"node_modules/core-js/modules/web.immediate.js","./modules/web.dom.iterable":"node_modules/core-js/modules/web.dom.iterable.js","./modules/_core":"node_modules/core-js/modules/_core.js"}],"node_modules/babel-polyfill/node_modules/regenerator-runtime/runtime.js":[function(require,module,exports) {
var global = arguments[3];
var process = require("process");
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var hasOwn = Object.prototype.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `value instanceof AwaitArgument` to determine if the yielded value is
  // meant to be awaited. Some may consider the name of this method too
  // cutesy, but they are curmudgeons.
  runtime.awrap = function(arg) {
    return new AwaitArgument(arg);
  };

  function AwaitArgument(arg) {
    this.arg = arg;
  }

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value instanceof AwaitArgument) {
          return Promise.resolve(value.arg).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    if (typeof process === "object" && process.domain) {
      invoke = process.domain.bind(invoke);
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          if (method === "return" ||
              (method === "throw" && delegate.iterator[method] === undefined)) {
            // A return or throw (when the delegate iterator has no throw
            // method) always terminates the yield* loop.
            context.delegate = null;

            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            var returnMethod = delegate.iterator["return"];
            if (returnMethod) {
              var record = tryCatch(returnMethod, delegate.iterator, arg);
              if (record.type === "throw") {
                // If the return method threw an exception, let that
                // exception prevail over the original return or throw.
                method = "throw";
                arg = record.arg;
                continue;
              }
            }

            if (method === "return") {
              // Continue with the outer return, now that the delegate
              // iterator has been terminated.
              continue;
            }
          }

          var record = tryCatch(
            delegate.iterator[method],
            delegate.iterator,
            arg
          );

          if (record.type === "throw") {
            context.delegate = null;

            // Like returning generator.throw(uncaught), but without the
            // overhead of an extra function call.
            method = "throw";
            arg = record.arg;
            continue;
          }

          // Delegate generator ran and handled its own exceptions so
          // regardless of what the method was, we continue as if it is
          // "next" with an undefined arg.
          method = "next";
          arg = undefined;

          var info = record.arg;
          if (info.done) {
            context[delegate.resultName] = info.value;
            context.next = delegate.nextLoc;
          } else {
            state = GenStateSuspendedYield;
            return info;
          }

          context.delegate = null;
        }

        if (method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = arg;

        } else if (method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw arg;
          }

          if (context.dispatchException(arg)) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            method = "next";
            arg = undefined;
          }

        } else if (method === "return") {
          context.abrupt("return", arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          var info = {
            value: record.arg,
            done: context.done
          };

          if (record.arg === ContinueSentinel) {
            if (context.delegate && method === "next") {
              // Deliberately forget the last sent value so that we don't
              // accidentally pass it on to the delegate.
              arg = undefined;
            }
          } else {
            return info;
          }

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(arg) call above.
          method = "throw";
          arg = record.arg;
        }
      }
    };
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp[toStringTagSymbol] = "Generator";

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;
        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.next = finallyEntry.finallyLoc;
      } else {
        this.complete(record);
      }

      return ContinueSentinel;
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = record.arg;
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      return ContinueSentinel;
    }
  };
})(
  // Among the various tricks for obtaining a reference to the global
  // object, this seems to be the most reliable technique that does not
  // use indirect eval (which violates Content Security Policy).
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this
);

},{"process":"../../../../.nvm/versions/node/v12.18.3/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"node_modules/core-js/modules/_replacer.js":[function(require,module,exports) {
module.exports = function (regExp, replace) {
  var replacer = replace === Object(replace) ? function (part) {
    return replace[part];
  } : replace;
  return function (it) {
    return String(it).replace(regExp, replacer);
  };
};

},{}],"node_modules/core-js/modules/core.regexp.escape.js":[function(require,module,exports) {
// https://github.com/benjamingr/RexExp.escape
var $export = require('./_export');
var $re = require('./_replacer')(/[\\^$*+?.()|[\]{}]/g, '\\$&');

$export($export.S, 'RegExp', { escape: function escape(it) { return $re(it); } });

},{"./_export":"node_modules/core-js/modules/_export.js","./_replacer":"node_modules/core-js/modules/_replacer.js"}],"node_modules/core-js/fn/regexp/escape.js":[function(require,module,exports) {
require('../../modules/core.regexp.escape');
module.exports = require('../../modules/_core').RegExp.escape;

},{"../../modules/core.regexp.escape":"node_modules/core-js/modules/core.regexp.escape.js","../../modules/_core":"node_modules/core-js/modules/_core.js"}],"node_modules/babel-polyfill/lib/index.js":[function(require,module,exports) {
var global = arguments[3];

"use strict";

require("core-js/shim");

require("regenerator-runtime/runtime");

require("core-js/fn/regexp/escape");

if (global._babelPolyfill) {
  throw new Error("only one instance of babel-polyfill is allowed");
}
global._babelPolyfill = true;

var DEFINE_PROPERTY = "defineProperty";
function define(O, key, value) {
  O[key] || Object[DEFINE_PROPERTY](O, key, {
    writable: true,
    configurable: true,
    value: value
  });
}

define(String.prototype, "padLeft", "".padStart);
define(String.prototype, "padRight", "".padEnd);

"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {
  [][key] && define(Array, key, Function.call.bind([][key]));
});
},{"core-js/shim":"node_modules/core-js/shim.js","regenerator-runtime/runtime":"node_modules/babel-polyfill/node_modules/regenerator-runtime/runtime.js","core-js/fn/regexp/escape":"node_modules/core-js/fn/regexp/escape.js"}],"node_modules/babel-register/lib/browser.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;

exports.default = function () {};

module.exports = exports["default"];
},{}],"node_modules/useless/babel.js":[function(require,module,exports) {
var process = require("process");
/*  !!!
    avoid ES6 in this file
    !!!                                         */
var path = require('path');

var moduleLocator = require('./server/base/module-locator');

if (process.argv.indexOf('spawned-by-supervisor') < 0) {
  console.log("\x1B[2m" + 'Loading ES6+ transpiler...' + "\x1B[22m");
}

var fs = require('fs');

var babelRc = path.resolve('./.babelrc');

var pluginPaths = function () {
  var pluginNames = JSON.parse(fs.readFileSync(babelRc)).plugins; // our .babelrc has es2015 preset (for browsers), but it kills server code, so fetch only the "plugins" part from it

  return pluginNames.map(function (name) {
    return path.resolve('./node_modules/babel-plugin-' + name);
  }); // resolve full paths, otherwise it will fail to locate plugins in symlinked folders
};

var config = fs.existsSync(babelRc) ? {
  babelrc: false,
  plugins: pluginPaths()
} : {};

config.ignore = function (file) {
  return !moduleLocator.hasBabelrc(file);
}; // do not transpile irrelevant things


require('babel-polyfill');

require('babel-register')(config); // replaces default 'require' implementation with ES7 transpiling one
},{"path":"../../../../.nvm/versions/node/v12.18.3/lib/node_modules/parcel-bundler/node_modules/path-browserify/index.js","./server/base/module-locator":"node_modules/useless/server/base/module-locator.js","fs":"../../../../.nvm/versions/node/v12.18.3/lib/node_modules/parcel-bundler/src/builtins/_empty.js","babel-polyfill":"node_modules/babel-polyfill/lib/index.js","babel-register":"node_modules/babel-register/lib/browser.js","process":"../../../../.nvm/versions/node/v12.18.3/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"node_modules/useless/base/3rd/underscore-fix.js":[function(require,module,exports) {
var _ = module.exports = require('underscore');

_.fromPairs = _.object; // was trying to migrate to lodash, but had no luck, these ones had left as an migration artifact...

_.mapValues = _.mapObject;

_.zipWith = function (rows, zippo) {
  return _.reduce(rows.slice(1), function (memo, row) {
    return _.times(Math.max(memo && memo.length || 0, row && row.length || 0), function (i) {
      return zippo(memo && memo[i], row && row[i]);
    });
  }, rows[0]);
};

if ('a1 b2 c3' !== _.zipWith([['a', 'b', 'c'], [1, 2, 3]], function (a, b) {
  return a + b;
}).join(' ')) {
  throw new Error('_.zipWith broken');
}
},{"underscore":"node_modules/underscore/underscore.js"}],"node_modules/useless/base/tier0/platform.js":[function(require,module,exports) {
var global = arguments[3];
"use strict";

var _ = require('underscore')
/*  $platform / $global
    ======================================================================== */
;

(function () {
  var p = function () {
    if (typeof window !== 'undefined' && window.window === window && window.navigator !== undefined) {
      var platform = navigator.platform,
          userAgent = navigator.userAgent,
          platformOrUserAgent = platform + '\n' + userAgent;
      return _.extend({
        engine: 'browser',
        browserEngine: userAgent.indexOf('AppleWebKit') >= 0 ? 'WebKit' : undefined,
        browser: userAgent.indexOf('Firefox') >= 0 ? 'Firefox' : userAgent.indexOf('Chrome') >= 0 ? 'Chrome' : userAgent.indexOf('Safari') >= 0 ? 'Safari' : userAgent.indexOf('Trident') >= 0 ? 'IE' : undefined
      }, platform.indexOf("Linux arm") >= 0 || platformOrUserAgent.indexOf("Android") >= 0 ? {
        touch: true,
        system: 'Android'
      } : platformOrUserAgent.indexOf("iPad") >= 0 ? {
        touch: true,
        system: 'iOS',
        device: 'iPad'
      } : platformOrUserAgent.indexOf("iPhone") >= 0 || platformOrUserAgent.indexOf("iPod") >= 0 ? {
        touch: true,
        system: 'iOS',
        device: 'iPhone'
      } : {});
    } else if (typeof global !== 'undefined' && global.global === global) {
      return {
        engine: 'node'
      };
    } else {
      return {};
    }
  }();

  if (p.system === 'iOS') {
    var match = navigator.userAgent.match(/OS (\d+)_(\d+)/);

    if (match) {
      p.systemVersion = {
        major: Number(match[1]),
        minor: Number(match[2])
      };
    }
  }

  var $global = p.engine === 'browser' ? window : p.engine === 'node' ? global : undefined;

  $global.property = function (name, v, cfg) {
    if (name in $global) {
      throw new Error('cannot redefine global ' + name);
    } else {
      var def = v instanceof Function ? {
        get: v,
        set: function () {
          throw new Error('cannot set global ' + name);
        }
      } : v;
      return Object.defineProperty($global, name, Object.assign({}, def, {
        enumerable: true
      }, cfg));
    }
  };

  $global.const = function (name, v, cfg) {
    return $global.property(name, {
      value: v,
      writable: false
    }, cfg);
  };

  $global.const('$global', $global);
  $global.const('$platform', {
    engine: p.engine,
    system: p.system,
    device: p.device,
    touch: p.touch || false,
    IE: p.browser === 'IE',
    Firefox: p.browser === 'Firefox',
    Safari: p.browser === 'Safari',
    Chrome: p.browser === 'Chrome',
    WebKit: p.browserEngine === 'WebKit',
    Browser: p.engine === 'browser',
    NodeJS: p.engine === 'node',
    iPad: p.device === 'iPad',
    iPhone: p.device === 'iPhone',
    iOS: p.system === 'iOS',
    iPhone4: p.device === 'iPhone' && window.screen.height === 480,
    systemVersion: p.systemVersion
  });
})();
},{"underscore":"node_modules/underscore/underscore.js"}],"node_modules/printable-characters/build/printable-characters.js":[function(require,module,exports) {
"use strict";

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

const ansiEscapeCode = '[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]',
      zeroWidthCharacterExceptNewline = '\u0000-\u0008\u000B-\u0019\u001b\u009b\u00ad\u200b\u2028\u2029\ufeff\ufe00-\ufe0f',
      zeroWidthCharacter = '\n' + zeroWidthCharacterExceptNewline,
      zeroWidthCharactersExceptNewline = new RegExp('(?:' + ansiEscapeCode + ')|[' + zeroWidthCharacterExceptNewline + ']', 'g'),
      zeroWidthCharacters = new RegExp('(?:' + ansiEscapeCode + ')|[' + zeroWidthCharacter + ']', 'g'),
      partition = new RegExp('((?:' + ansiEscapeCode + ')|[\t' + zeroWidthCharacter + '])?([^\t' + zeroWidthCharacter + ']*)', 'g');

module.exports = {

    zeroWidthCharacters,

    ansiEscapeCodes: new RegExp(ansiEscapeCode, 'g'),

    strlen: s => Array.from(s.replace(zeroWidthCharacters, '')).length, // Array.from solves the emoji problem as described here: http://blog.jonnew.com/posts/poo-dot-length-equals-two

    isBlank: s => s.replace(zeroWidthCharacters, '').replace(/\s/g, '').length === 0,

    blank: s => Array.from(s.replace(zeroWidthCharactersExceptNewline, '')) // Array.from solves the emoji problem as described here: http://blog.jonnew.com/posts/poo-dot-length-equals-two
    .map(x => x === '\t' || x === '\n' ? x : ' ').join(''),

    partition(s) {
        for (var m, spans = []; partition.lastIndex !== s.length && (m = partition.exec(s));) {
            spans.push([m[1] || '', m[2]]);
        }
        partition.lastIndex = 0; // reset
        return spans;
    },

    first(s, n) {

        let result = '',
            length = 0;

        for (const _ref of module.exports.partition(s)) {
            var _ref2 = _slicedToArray(_ref, 2);

            const nonPrintable = _ref2[0];
            const printable = _ref2[1];

            const text = Array.from(printable).slice(0, n - length); // Array.from solves the emoji problem as described here: http://blog.jonnew.com/posts/poo-dot-length-equals-two
            result += nonPrintable + text.join('');
            length += text.length;
        }

        return result;
    }
};


},{}],"node_modules/string.bullet/string.bullet.js":[function(require,module,exports) {
"use strict";

const { blank } = require ('printable-characters')

module.exports = (bullet, arg) => {

                    const isArray = Array.isArray (arg),
                          lines   = isArray ? arg : arg.split ('\n'),
                          indent  = blank (bullet),
                          result  = lines.map ((line, i) => (i === 0) ? (bullet + line) : (indent + line))
                    
                    return isArray ? result : result.join ('\n')
                }
},{"printable-characters":"node_modules/printable-characters/build/printable-characters.js"}],"node_modules/meta-fields/meta-fields.js":[function(require,module,exports) {
var global = arguments[3];
"use strict";

/*  ------------------------------------------------------------------------ */

    const O = Object

/*  ------------------------------------------------------------------------ */

    const pickFields = (obj, predicate) => {

        const result = {}

        for (let k of Object.getOwnPropertyNames (obj)) {
            const v = obj[k]
            if (predicate (k, v)) { result[k] = v }
        }

        return result
    }

/*  ------------------------------------------------------------------------ */

    class Meta {

        constructor (x) {

            this.assign (x)
        }

        assign (x) {

            if ('wrapped' in x) { this.wrapped = x.wrapped }

            this.__meta__ = x.__meta__ || {}

            return this
        }

        [Symbol.for ('String.ify')] (stringify) {

            if (stringify.json) {

                return stringify (this.wrapped)
            }

            let left = ''
            let numMeta = 0

            for (let tag in this.__meta__) {

                const name = '$' + tag
                const value = this.__meta__[tag]

                left = (typeof value === 'boolean')
                            ? (name + ' (' + left)
                            : (name + ' (' + stringify.configure ({ pretty: false }) (value) + ', ' + left)

                numMeta++
            }

            const bullet = require ('string.bullet')

            return bullet (left, stringify (this.wrapped)) + ')'.repeat (numMeta)
        }
    }

/*  ------------------------------------------------------------------------ */

    module.exports = O.assign (Meta, {

        new: x => new Meta (x),

        coerce: function (x) { return Meta.is (x) ? x : Meta.new ((arguments.length > 0) ? { wrapped: x } : {}) },

        assign: (x, fields) => (Meta.new (Meta.is (x) ? x : { wrapped: x })).assign (fields),

        is: x => (x && (x['__meta__'] !== undefined)) || false,

        hasValue: x => ('wrapped' in Meta.coerce (x)),

        unwrap: x => Meta.coerce (x).wrapped,

        hasTag: (obj, tag) => Meta.is (obj) && (tag in obj.__meta__),

        readTag: (obj, tag) => Meta.is (obj) ? obj.__meta__[tag] : undefined,

        tags: x => Meta.coerce (x).__meta__,

        eachTag: (x, fn) => {
            const tags = Meta.tags (x)
            for (let i in tags) { fn (i, tags[i]) }
        },

        replaceTags: (x, tags) => Meta.assign (x, { __meta__: tags }),

        setTags: (x, tags) => Meta.replaceTags (x, O.assign ({}, Meta.tags (x), tags)),

        setTag: (name, data, ...toWhat) => Meta.setTags (Meta.coerce (...toWhat), { [name]: data }),

        merge: (a, b) => (Meta.is (a) || Meta.is (b))
                            ? Meta.replaceTags (b, O.assign ({}, Meta.tags (a), Meta.tags (b)))
                            : b,

        omitTags (x, ...names) {

            if (!Meta.is (x)) { return x }

            const $names = new Set (names)

            return Meta.replaceTags (x, pickFields (x.__meta__, k => !$names.has (k)))
        },

        modify: (x, fn) => Meta.merge (x, fn (Meta.unwrap (x))),

        tag: (k, impl) => {

            const defaultImpl = (...args) => (args.length < 2)
                                                ? Meta.setTag (k, true, ...args) // $tag (value)
                                                : Meta.setTag (k,       ...args) // $tag (data, value)

            return O.assign ((typeof impl === 'function') ? impl.bind (null, k) : defaultImpl, {

               tagName: k,
                  read: x =>  Meta.readTag (x, k),
                    is: x =>  Meta.hasTag  (x, k),
                 isNot: x => !Meta.hasTag  (x, k),
            })
        },

        globalTag: (name, ...args) => {

            const isBrowser = (typeof window !== 'undefined') && (window.window === window) && window.navigator,
                  globalNamespace = isBrowser ? window : global

            return globalNamespace['$' + name] || (globalNamespace['$' + name] = Meta.tag (name, ...args))
        },
    })

/*  ------------------------------------------------------------------------ */



},{"string.bullet":"node_modules/string.bullet/string.bullet.js"}],"node_modules/useless/base/tier0/meta-tags.js":[function(require,module,exports) {
// This is temporary (until refactoring done)
$global.Meta = require('meta-fields');
Meta.$definition = {}; // to make it recognizeable by OOP.js

$global.$untag = Meta.unwrap;

Meta.unwrapAll = function (x) {
  return _.map2(Meta.unwrap(x), Meta.unwrap);
};

['constant', 'get', 'once', 'async', 'atom'].forEach(Meta.globalTag); // TODO: get rid of this

$atom.unwrap = function (x) {
  // WTF? get rid of this
  return $atom.read(x) === true ? Meta.unwrap(x) : x;
};
},{"meta-fields":"node_modules/meta-fields/meta-fields.js"}],"node_modules/useless/base/tier0/assert.js":[function(require,module,exports) {
var define;
"use strict";
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
------------------------------------------------------------------------

Unit tests (bootstrap code)

------------------------------------------------------------------------
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

_.hasAsserts = true;

_.extend(_, {
  /*  a namespace where you put tests (for enumeration purposes)
      ======================================================================== */
  tests: _.tests || {},

  /*  A degenerate case of a test shell. We use it to bootstrap most critical
      useless.js internals, where real shell (Testosterone.js) is not available,
      as it itself depends on these utility. It takes test and test's subject as
      arguments (test before code, embodying test-driven philosophy) and executes
      test immediately, throwing exception if anything fails - which is simply
      the default behavior of $assert. So expect no advanced error reporting
      and no controlled execution by using this API.
      ======================================================================== */
  withTest: function (name, test, defineSubject) {
    defineSubject();

    _.runTest(name, test);

    _.publishToTestsNamespace(name, test);
  },

  /*  Publishes to _.tests namespace, but does not run
      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
  deferTest: function (name, test, defineSubject) {
    defineSubject();

    _.publishToTestsNamespace(name, test);
  },

  /*  INTERNALS (you won't need that)
      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
  runTest: function (name, test) {
    try {
      if (_.isFunction(test)) {
        test();
      } else {
        _.each(test, function (fn) {
          fn();
        });
      }
    } catch (e) {
      if (_.isAssertionError(e)) {
        var printedName = (_.isArray(name) && name || [name]).join('.');
        console.log(printedName + ':', e.message, '\n' + _.times(printedName.length, _.constant('~')).join('') + '\n');

        _.each(e.notMatching, function (x) {
          console.log('  ', x);
        });
      }

      throw e;
    }
  },
  publishToTestsNamespace: function (name, test) {
    if (_.isArray(name)) {
      // [suite, name] case
      (_.tests[name[0]] || (_.tests[name[0]] = {}))[name[1]] = test;
    } else {
      _.tests[name] = test;
    }
  }
});
/*  TEST ITSELF
    ======================================================================== */


_.withTest('assert.js bootstrap', function () {
  /*  One-argument $assert (requires its argument to be strictly 'true')
      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
  $assert(true);
  $assert( // public front end, may be replaced by environment)
  _.assert === // member of _ namespace (original implementation, do not mess with that)
  _.assertions.assert); // member of _.assertions (for enumeration purposes)

  $assertNot(false);
  $assertNot(5); // NB: assertNot means 'assert not true', hence this will pass

  /*  Multi-argument assert (requires its arguments be strictly equal to each other)
      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

  $assert(2 + 2, 2 * 2, 4); // any number of arguments

  $assert({
    foo: [1, 2, 3]
  }, {
    foo: [1, 2, 3]
  }); // compares objects (deep match)

  $assert({
    foo: {
      bar: 1
    },
    baz: 2
  }, // ignores order of properties
  {
    baz: 2,
    foo: {
      bar: 1
    }
  });
  $assertNot(2 + 2, 5);
  /*  Nonstrict matching (a wrapup over _.matches)
      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

  $assertMatches({
    foo: 1,
    bar: 2
  }, {
    foo: 1
  });
  /*  Nonstrict matching against complex objects (stdlib.js feature)
      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

  if (_.hasStdlib) {
    $assertMatches({
      foo: [1, 2],
      bar: 3
    }, {
      foo: [1]
    });
  }
  /*  Regex matching (stdlib.js feature)
      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */


  if (_.hasStdlib) {
    $assertMatches('123', /[0-9]+/);
  }
  /*  Type matching (plain)
      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */


  if (_.hasStdlib) {
    $assertTypeMatches(42, 'number');
    $assertFails(function () {
      $assertTypeMatches('foo', 'number');
    });
  }
  /*  Type matching (array type)
      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */


  if (_.hasStdlib) {
    $assertTypeMatches([1, 2], []);
    $assertTypeMatches([], []);
    $assertTypeMatches([1, 2, 3], ['number']);
    $assertTypeMatches([], ['number']);
    $assertFails(function () {
      $assertTypeMatches([1, 2, 3], ['string']);
      $assertTypeMatches([1, 2, 'foo'], ['number']);
    });
  }
  /*  Type matching (deep)
      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */


  if (_.hasStdlib) {
    $assertTypeMatches({
      /*  Input object */
      foo: 42,
      bar: {
        even: 4,
        many: ['foo', 'bar']
      }
    }, {
      /*  Type contract */
      foo: 'number',
      // simple type check
      qux: 'undefined',
      // nonexisting match 'undefined' 
      bar: {
        // breakdown of complex object 
        even: function (n) {
          return n % 2 === 0;
        },
        // custom contract predicate    
        many: ['string']
      }
    });
  } // array contract (here, 'array of strings')

  /*  Type matching ($prototype)
      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */


  if (_.hasOOP) {
    var Foo = $prototype(),
        Bar = $prototype();
    $assertTypeMatches({
      foo: new Foo(),
      bar: new Bar()
    }, {
      foo: Foo,
      bar: Bar
    });
    $assertFails(function () {
      $assertTypeMatches(new Bar(), Foo);
    });
  }

  ;
  /*  Ensuring throw (and no throw)
      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

  $assertThrows(function () {
    throw 42;
  });
  $assertNotThrows(function () {});
  /*  Ensuring throw (strict version)
      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

  $assertThrows(function () {
    throw 42;
  }, 42); // accepts either plain value or predicate

  $assertThrows(function () {
    throw new Error('42');
  }, _.matches({
    message: '42'
  }));
  $assertFails(function () {
    $assertThrows(function () {
      throw 42;
    }, 24);
    $assertThrows(function () {
      throw new Error('42');
    }, _.matches({
      message: '24'
    }));
  });
  /*  Ensuring execution
      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

  $assertEveryCalled(function (a, b, c) {
    a();
    a();
    b();
    c();
  });
  $assertEveryCalledOnce(function (a, b, c) {
    a();
    b();
    c();
  });
  $assertEveryCalled(function (x__3) {
    x__3();
    x__3();
    x__3();
  });
  /*$assertFails (function () {
      $assertEveryCalled     (function (a, b, c) { a (); b () })
      $assertEveryCalledOnce (function (a, b, c) { a (); b (); b (); c (); })
      $assertEveryCalled     (function (x__3) { x__3 (); x__3 (); }) })*/

  /*  TODO:   1) add CPS support
              2) replace $assertCPS with this
      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

  if (_.hasStdlib) {
    $assertCalledWithArguments(['foo', ['foo', 'bar']], function (fn) {
      fn('foo');
      fn('foo', 'bar');
    });
  }
  /*  Ensuring CPS routine result (DEPRECATED)
      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */


  $assertCPS(function (then) {
    then('foo', 'bar');
  }, ['foo', 'bar']);
  $assertCPS(function (then) {
    then('foo');
  }, 'foo');
  $assertCPS(function (then) {
    then();
  });
  /*  Ensuring assertion failure
      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

  $assertFails(function () {
    $fail; // simplest way to generate assertion

    $stub; // to mark code stubs (throws error)

    $assert('not true'); // remember that assert is more strict than JavaScript if clauses

    $assert({
      foo: 1,
      bar: 2
    }, {
      foo: 1
    }); // not be confused with _.matches behavior (use $assertMatches for that)

    $assert([1, 2, 3, 4], [1, 2, 3]); // same for arrays

    $assert(['foo'], {
      0: 'foo',
      length: 1
    }); // array-like objects not gonna pass (regression test)

    $assertFails(function () {});
  }); // $assertFails fails if passed code don't

  /*  Default fail behavior (never depend on that, as it's environment-dependent)
      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

  if ($assert === _.assertions.assert) {
    $assertThrows(function () {
      $fail;
    });
  }
  /*  IMPLEMENTATION
      ======================================================================== */

}, function () {
  var assertImpl = function (positive) {
    return function (__) {
      var args = [].splice.call(arguments, 0);

      if (args.length === 1) {
        if (positive && args[0] !== true) {
          _.assertionFailed({
            notMatching: args
          });
        }
      } else if (positive && _.allEqual(args) !== true) {
        _.assertionFailed({
          notMatching: args
        });
      }

      return true;
    };
  }
  /*  Fix for _.matches semantics (should not be true for _.matches (42) (24))
   */
  ;

  (function () {
    var _matches = _.matches;

    _.matches = function (a) {
      return _.isObject(a) ? _matches(a) : function (b) {
        return a === b;
      };
    };
  })();

  _.extend(_, _.assertions = {
    assert: assertImpl(true),
    assertNot: assertImpl(false),
    assertCPS: function (fn, args, then) {
      var requiredResult = args && (_.isArray(args) ? args : [args]) || [];
      fn(function () {
        $assert([].splice.call(arguments, 0), requiredResult);

        if (then) {
          then();
          return true;
        }
      });
    },
    assertNotCalled: function (context) {
      var inContext = true;
      context(function () {
        if (inContext) {
          $fail;
        }
      });
      inContext = false;
    },
    assertEveryCalledOnce: function (fn, then) {
      return _.assertEveryCalled($once(fn), then);
    },
    assertEveryCalled: function (fn_, then) {
      var fn = $untag(fn_),
          async = $async.is(fn_),
          once = $once.is(fn_);
      var match = once ? null : fn.toString().match(/.*function[^\(]\(([^\)]+)\)/);
      var contracts = once ? _.times(fn.length, _.constant(1)) : _.map(match[1].split(','), function (arg) {
        var parts = arg.trim().match(/^(.+)__(\d+)$/);
        var num = parts && parseInt(parts[2], 10);
        return _.isFinite(num) ? num || false : true;
      });

      var status = _.times(fn.length, _.constant(false));

      var callbacks = _.times(fn.length, function (i) {
        return function () {
          status[i] = _.isNumber(contracts[i]) ? (status[i] || 0) + 1 : true;
          if (async && _.isEqual(status, contracts)) then();
        };
      });

      fn.apply(null, callbacks);

      if (!async) {
        _.assert(status, contracts);

        if (then) {
          then();
        }
      }
    },
    assertCalledWithArguments: function (argsPattern, generateCalls) {
      return _.assert(_.arr(generateCalls), argsPattern);
    },
    assertCallOrder: function (fn) {
      var callIndex = 0;

      var callbacks = _.times(fn.length, function (i) {
        return function callee() {
          callee.callIndex = callIndex++;
        };
      });

      fn.apply(null, callbacks);
      return _.assert(_.pluck(callbacks, 'callIndex'), _.times(callbacks.length, _.identity.arity1));
    },
    assertMatches: function (value) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var pattern = args[0];

      try {
        return _.assert(_.matches.apply(null, args)(value));
      } catch (e) {
        throw _.isAssertionError(e) ? _.extend(e, {
          notMatching: [value, pattern]
        }) : e;
      }
    },
    assertNotMatches: function (value) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      var pattern = args[0];

      try {
        return _.assert(!_.matches.apply(null, args)(value));
      } catch (e) {
        throw _.isAssertionError(e) ? _.extend(e, {
          notMatching: [value, pattern]
        }) : e;
      }
    },
    assertType: function (value, contract) {
      return _.assert(_.decideType(value), contract);
    },
    assertTypeMatches: function (value, contract) {
      var mismatches = _.typeMismatches(contract, value);

      return _.isEmpty(mismatches) ? true : _.assertionFailed({
        message: 'provided value type not matches required contract',
        asColumns: true,
        notMatching: [{
          provided: value
        }, {
          required: contract
        }, {
          mismatches: mismatches
        }]
      });
    },
    assertFails: function (what) {
      return _.assertThrows.call(this, what, _.isAssertionError);
    },
    assertThrows: function (what, errorPattern) {
      var e = undefined,
          thrown = false;

      try {
        what.call(this);
      } catch (__) {
        e = __;
        thrown = true;
      }

      _.assert.call(this, thrown);

      if (arguments.length > 1) {
        _.assertMatches.call(this, e, errorPattern);
      }
    },
    assertNotThrows: function (what) {
      return _.assertEveryCalled(function (ok) {
        what();
        ok();
      });
    },
    fail: function () {
      _.assertionFailed();
    },
    fails: _.constant(function () {
      // higher order version
      _.assertionFailed();
    }),
    stub: function () {
      _.assertionFailed();
    }
  });
  /*  DEFAULT FAILURE IMPL.
      ---------------------
      We do not subclass Error, because _.isTypeOf currently does not support
      inhertitance (UPDATE: now does) and it would cause troubles in test shell
      and logging facility. Thus a subclass is defined that way.
      ======================================================================== */


  _.extend(_, {
    assertionError: function (additionalInfo) {
      return _.extend(new Error(additionalInfo && additionalInfo.message || 'assertion failed'), additionalInfo, {
        assertion: true
      });
    },
    assertionFailed: function (additionalInfo) {
      throw _.extend(_.assertionError(additionalInfo), {
        stack: new Error().stack.split('\n').slice(3).join('\n')
      });
    },
    isAssertionError: function (e) {
      return e && e.assertion === true;
    }
  });
  /*  $assert helper
      ======================================================================== */


  _.allEqual = function (values) {
    return _.reduce(values, function (prevEqual, x) {
      return prevEqual && _.isEqual(values[0], x);
    }, true);
  };
  /*  Publish asserts as $-things (will be replaced by Testosterone.js onwards,
      thus configurable=true)
      ======================================================================== */


  _.each(_.keys(_.assertions), function (name) {
    var define = _[name].length === 0 ? $global.property : $global.const;
    define('$' + name, _[name], {
      configurable: true
    });
  });
});
},{}],"node_modules/useless/base/tier0/arguments.js":[function(require,module,exports) {
"use strict";

var _ = require('underscore');
/*  converts 'arguments' (and any other array mimick) to real Array
    ======================================================================== */


_.withTest(['stdlib', 'asArray'], function () {
  (function (a, b) {
    var args = _.asArray(arguments);

    $assert(_.isArray(args));
    $assert(args.length === 2);
    $assert(args[0] === a);
    $assert(args[1] === b);
  })(42, 43);

  $assert(_.asArray(42), [42]);
  /*  Should not mutate its argument (regression)
   */

  var foo = {
    0: 'foo',
    length: 1
  };
  $assert(_.asArray(foo), ['foo']);
  $assert(foo, {
    0: 'foo',
    length: 1
  });
}, function () {
  _.extend(_, {
    asArray: function (x) {
      return x.length !== undefined ? [].slice.call(x, 0) : [x];
    }
  });
});
/*  Argument count tracking module (provides hinting to several metaprogramming
    utilities, like property definitions)
    ======================================================================== */


_.withTest('argcount tracking', function () {
  var none = function () {};

  var one = function (a) {};

  var three = function (a, b, c) {};

  var many = $restArg(function () {});
  $assert(_.noArgs(none) === true);
  $assert(_.hasArgs(none) === false);
  $assert(_.numArgs(three) === 3);
  $assert(_.hasArgs(three) === true);
  $assert(_.restArg(many) === true);
  $assert(_.noArgs(many) === false);
  $assert(_.oneArg(one) === true);

  var sameAsThree = _.withSameArgs(three, function () {});

  var oneArgLess = _.withArgs(_.numArgs(three) - 1, _.restArg(three), function () {});

  $assert([_.numArgs(sameAsThree), _.restArg(sameAsThree)], [3, false]);
  $assert([_.numArgs(oneArgLess), _.restArg(oneArgLess)], [2, false]);
}, function () {
  _.extend(_, {
    /*  Querying
     */
    numArgs: function (fn) {
      return fn._ac === undefined ? fn.length : fn._ac;
    },
    // short name for speed
    restArg: function (fn) {
      return fn._ra || false;
    },
    // short name for speed
    noArgs: function (fn) {
      return _.numArgs(fn) === 0 && !fn._ra;
    },
    hasArgs: function (fn) {
      return _.numArgs(fn) > 0 && !fn._ra;
    },
    oneArg: function (fn) {
      return _.numArgs(fn) === 1 && !fn._ra;
    },

    /*  Setting
     */
    withRestArg: $global.$restArg = function (fn) {
      Object.defineProperty(fn, '_ra', {
        enumerable: false,
        writable: true,
        value: true
      });
      return fn;
    },
    withArgs: function (numArgs, restArg, fn) {
      if (numArgs !== undefined) {
        Object.defineProperty(fn, '_ac', {
          enumerable: false,
          writable: true,
          value: numArgs
        });
      }

      if (restArg !== undefined) {
        Object.defineProperty(fn, '_ra', {
          enumerable: false,
          writable: true,
          value: restArg
        });
      }

      return fn;
    },
    withSameArgs: function (other, fn) {
      return _.withArgs(_.numArgs(other), _.restArg(other), fn);
    }
  });
})
/*  Adds argcount tracking to some underscore functions.
    Will test it for speed in future, and if slow in app code,
    will be de-mounted, thus sacrificing clarity in some places.
    ======================================================================== */
;

(function () {
  var override = function (name, genImpl) {
    return _[name] = genImpl(_[name]);
  };

  override('memoize', function (memoize) {
    return function (fn) {
      return _.withSameArgs(fn, memoize(fn));
    };
  });
  override('partial', function (partial) {
    return $restArg(function (fn) {
      return _.withArgs(Math.max(0, _.numArgs(fn) - (arguments.length - 1)), fn._ra, partial.apply(this, arguments));
    });
  });
  override('bind', function (bind) {
    return $restArg(function (fn, this_) {
      return _.withArgs(Math.max(0, _.numArgs(fn) - (arguments.length - 2)), fn._ra, bind.apply(this, arguments));
    });
  });
})();
},{"underscore":"node_modules/underscore/underscore.js"}],"node_modules/useless/base/tier0/function.js":[function(require,module,exports) {
"use strict";

var _ = require('underscore');
/*  Useful for debugging and tests
    ======================================================================== */


_.debugEcho = function () {
  return [this].concat(_.asArray(arguments));
};
/*  Context-free version of fn.call (for consistency)
    ======================================================================== */


_.call = function (fn, this_) {
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }

  return fn.apply(this_, args);
};
/*  Limits function to given number of arguments
    ======================================================================== */


_.arity = function (N, fn) {
  return function () {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return fn.apply(this, args.slice(0, N));
  };
};

_.arity0 = function (fn) {
  return function () {
    return fn.call(this);
  };
};

_.arity1 = function (fn) {
  return function (a) {
    return fn.call(this, a);
  };
};

_.arity2 = function (fn) {
  return function (a, b) {
    return fn.call(this, a, b);
  };
};

_.arity3 = function (fn) {
  return function (a, b, c) {
    return fn.call(this, a, b, c);
  };
};

_.arityFn = function (N) {
  return _['arity' + N];
};
/*  A version of _.partial that binds to tail of argument list
    ======================================================================== */


_.tails = $restArg(function (fn) {
  for (var _len3 = arguments.length, tailArgs = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    tailArgs[_key3 - 1] = arguments[_key3];
  }

  return function () {
    return fn.apply(this, _.asArray(arguments).concat(tailArgs));
  };
});
_.tails2 = $restArg(function (fn) {
  for (var _len4 = arguments.length, tailArgs = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
    tailArgs[_key4 - 1] = arguments[_key4];
  }

  return function (a) {
    return fn.apply(this, [a].concat(tailArgs));
  };
});
_.tails3 = $restArg(function (fn) {
  for (var _len5 = arguments.length, tailArgs = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
    tailArgs[_key5 - 1] = arguments[_key5];
  }

  return function (a, b) {
    return fn.apply(this, [a, b].concat(tailArgs));
  };
});
/*  Userful for higher order operations
    ======================================================================== */

_.withTest(['function', 'calls / tails'], function () {
  var fn = _.debugEcho;

  var foo42_ = _.callsWith('foo', 42);

  var _foo42 = _.tailsWith('foo', 42);

  var foo42_fn = foo42_(fn);

  var fn_foo42 = _foo42(fn);

  var _fn = _.callsTo(fn);

  var fn_ = _.tailsTo(fn);

  var fn_bar24 = fn_('bar', 24);

  var bar24_fn = _fn('bar', 24);

  $assert(foo42_fn.call('lol', 777), ['lol', 'foo', 42, 777]);
  $assert(bar24_fn.call('lol', 777), ['lol', 'bar', 24, 777]);
  $assert(fn_foo42.call('lol', 777), ['lol', 777, 'foo', 42]);
  $assert(fn_bar24.call('lol', 777), ['lol', 777, 'bar', 24]);
  $assertEveryCalledOnce(function (mkay) {
    _.argumentPrependingWrapper(fn, function (fn) {
      $assert(fn(777), ['lol', 777, 'foo', 42]);
      mkay();
    }).call('lol', 'foo', 42);
  });
}, function () {
  _.callsTo = function (fn) {
    return $restArg(function () {
      return _.callsWith.apply(null, arguments)(fn);
    });
  };

  _.tailsTo = function (fn, then) {
    return $restArg(function () {
      return _.tailsWith.apply(null, arguments)(fn);
    });
  };

  _.callsWith = $restArg(function ()
  /* args */
  {
    var args = _.asArray(arguments);

    return function (fn) {
      return _.withSameArgs(fn, function () {
        return fn.apply(this, args.concat(_.asArray(arguments)));
      });
    };
  }); // @hide

  _.tailsWith = $restArg(function ()
  /* args */
  {
    var args = _.asArray(arguments);

    return function (fn) {
      return _.withSameArgs(fn, function () {
        return fn.apply(this, _.asArray(arguments).concat(args));
      });
    };
  }); // @hide

  _.argumentAppendingWrapper = function (fn, then) {
    return _.withSameArgs(fn, function () {
      var this_ = this,
          args = _.asArray(arguments);

      return then(function () {
        return fn.apply(this_, args.concat(_.asArray(arguments)));
      });
    });
  }; // @hide


  _.argumentPrependingWrapper = function (fn, then) {
    return _.withSameArgs(fn, function () {
      var this_ = this,
          args = _.asArray(arguments);

      return then(function () {
        return fn.apply(this_, _.asArray(arguments).concat(args));
      });
    });
  };
}); // @hide

/*  binding to constructor arguments (cannot do this with bind/partial)
    ======================================================================== */


_.new = $restArg(function (Constructor, a, b, c, d) {
  switch (arguments.length) {
    case 1:
      return new Constructor();

    case 2:
      return new Constructor(a);

    case 3:
      return new Constructor(a, b);

    case 4:
      return new Constructor(a, b, c);

    case 5:
      return new Constructor(a, b, c, d);

    default:
      _.notImplemented();

  }
});
/*  Flips function signature (argument order)
    ======================================================================== */

_.flipN = function (fn) {
  return $restArg(function () {
    return fn.apply(this, _.asArray(arguments).reverse());
  });
};

_.flip = function (fn) {
  if (_.restArg(fn)) {
    return _.flipN(fn);
  } else {
    switch (_.numArgs(fn)) {
      case 0:
      case 1:
        return fn;

      case 2:
        return _.flip2(fn);

      case 3:
        return _.flip3(fn);

      default:
        throw new Error('flip: unsupported arity');
    }
  }
};

_.flip2 = function (fn) {
  return function (a, b) {
    return fn.call(this, b, a);
  };
};

_.flip3 = function (fn) {
  return function (a, b, c) {
    return fn.call(this, c, b, a);
  };
};
/*  Logical composition operators
    ======================================================================== */


_.or = function (a, b) {
  return function () {
    return a.apply(this, arguments) || b.apply(this, arguments);
  };
}, _.and = function (a, b) {
  return function () {
    return a.apply(this, arguments) && b.apply(this, arguments);
  };
}, _.not = function (x) {
  return function () {
    return !x.apply(this, arguments);
  };
};
/*  Y combinator (for anonymous recursive functions)
    ======================================================================== */

_.withTest(['function', 'Y combinator'], function () {
  var countTo5 = _.Y(function (self) {
    return function (n) {
      return n >= 5 ? n : self(n + 1);
    };
  });

  $assert(countTo5(0), 5);
}, function () {
  _.extend(_, {
    Y: function (eatSelf) {
      var self = eatSelf(function () {
        return self.apply(this, arguments);
      });
      return self;
    }
  });
});
/*  converts regular things like map/zip to hyper versions, that traverse
    deep structures (tested later, via its derivatives: zipZip/mapMap etc)
    ======================================================================== */

/*  Operator argument is the thing that walks down the tree and transforms it.
    But its predicate gets called only on the leaves of a tree (end values).

    Essentially, it abstracts you from structure, making it 'transparent'
    for any kind of previously defined one-dimensional operators like
    map/filter/zip/reduce/etc.

    Example:    hyperMap = _.hyperOperator (_.unary,  _.map2)
                hyperZip = _.hyperOperator (_.binary, _.zip2)
 */


(function () {
  /*  N number denotes how many arguments underlying operation accepts
   */
  _.hyperOperator = function (N, operator, diCaprioPredicate, nonTrivial) {
    var arity = _.arityFn(N) || _.identity;

    var weNeedToGoDeeper = (diCaprioPredicate || _.goDeeperWhenFirstArgumentIsGood)(N, nonTrivial || _.isNonTrivial);

    return function () {
      var subOperator = _.last(arguments);

      return _.Y(function (hyperOperator_) {
        var hyperOperator = _.tails(operator, arity(hyperOperator_));

        return function () {
          return (weNeedToGoDeeper(arguments) ? hyperOperator : subOperator).apply(this, arguments);
        };
      }).apply(this, _.initial(arguments));
    };
  };
  /*  Combinatoric complexity classifiers for exact configuration of hyperOperator behavior
   */


  _.goDeeperWhenFirstArgumentIsGood = function (N, canGoDeeper) {
    return function (args) {
      return args.length > 0 ? canGoDeeper(args[0]) : false;
    };
  };

  _.goDeeperAlwaysIfPossible = function (N, canGoDeeper) {
    if (N === 0) {
      return _.constant(false);
    } else if (N === 1) {
      return function (args) {
        return canGoDeeper(args[0]);
      };
    } else if (N === 2) {
      return function (args) {
        return canGoDeeper(args[0]) || canGoDeeper(args[1]);
      };
    } else {
      return function (args) {
        return _.some(_.asArray(args), canGoDeeper);
      };
    }
  };

  _.goDeeperOnlyWhenNessesary = function (N, canGoDeeper) {
    if (N === 0) {
      return _.constant(false);
    } else if (N === 1) {
      return function (args) {
        return canGoDeeper(args[0]);
      };
    } else if (N === 2) {
      return function (args) {
        return canGoDeeper(args[0]) && canGoDeeper(args[1]);
      };
    } else {
      return function (args) {
        return _.every(_.asArray(args), canGoDeeper);
      };
    }
  };

  _.isTrivial = function (x) {
    return _.isEmpty(x) || _.isString(x) || _.isNumber(x) || x instanceof RegExp || x instanceof Date || !(_.isStrictlyObject(x) || _.isArray(x)) || _.isPrototypeInstance(x) || _.isMeta(x);
  };

  _.isMeta = _.constant(false);
  _.isNonTrivial = _.not(_.isTrivial);
  /*  Self-descriptive constants (for clarity)
   */

  _.binary = 2;
  _.unary = 1;
})();
/*  Generates higher order stuff from regular routine
    ======================================================================== */


_.withTest(['function', 'higherOrder'], function () {
  var file = [];

  var write = function (x) {
    file.push(x);
  };

  var writes = _.higherOrder(write);

  _.times(3, writes('foo'));

  $assert(file, ['foo', 'foo', 'foo']);
}, function () {
  _.higherOrder = _.callsTo;
});
/*  coerces x|fn()x to x (useful for configuration parameters)
    ======================================================================== */


_.deferTest(['function', 'eval/evals'], function () {
  var cfg = {
    value1: 42,
    value2: function () {
      return 42;
    },
    value3: _.property('number')
  };

  var evl = _.evals({
    number: 42
  }); // higher order


  $assert(_.eval(cfg.value1), _.eval(cfg.value2), evl(cfg.value3), 42);
}, function () {
  _.eval = function (x) {
    return _.isFunction(x) ? x.call(this) : x;
  };

  _.evals = function (__args__) {
    var arguments_ = arguments;
    return function (x) {
      return _.isFunction(x) ? x.apply(this, arguments_) : x;
    };
  };
});
/*  in rhyme with _.property, this one calls a method
    ======================================================================== */


_.method = function (name) {
  for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
    args[_key6 - 1] = arguments[_key6];
  }

  return function (obj) {
    return obj[name].apply(obj, args);
  };
};
/*  Converts between calling conventions
    ======================================================================== */


_.asFreeFunction = function (fn) {
  return function (this_) {
    for (var _len7 = arguments.length, args = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {
      args[_key7 - 1] = arguments[_key7];
    }

    return fn.apply(this_, args);
  };
};

_.asMethod = function (fn) {
  return function () {
    return fn.apply(undefined, [this].concat(_.asArray(arguments)));
  };
}; // @hide

/*  _.once
    ======================================================================== */


_.withTest(['function', 'once'], function () {
  $assertEveryCalledOnce(function (mkay) {
    var f = _.once(function () {
      mkay();
    });

    f();
    f();
  });
}, function () {
  _.once = function (fn) {
    var called = false;
    return function () {
      if (!called) {
        called = true;
        return fn.apply(this, arguments);
      }
    };
  };
});
/*  _.withTimeout
    ======================================================================== */


_.deferTest(['function', 'withTimeout'], function (testDone) {
  _.withTimeout({
    maxTime: 10,
    expired: function () {
      $fail;
    }
  }, function (done) {
    done();
  });

  _.withTimeout({
    maxTime: 10,
    expired: function (then) {
      testDone();
    }
  }, function (done) {
    _.delay(done, 20);
  }, function () {
    // 'then' should not be called if expired (though you may call it explicitly at expired() callback)
    $fail;
  });
}, function () {
  _.withTimeout = function (cfg, what, then) {
    var expired = false;
    var timeout = setTimeout(function () {
      expired = true;

      if (cfg.expired) {
        cfg.expired(then);
      }
    }, cfg.maxTime);
    what(function () {
      if (!expired) {
        clearTimeout(timeout);

        if (then) {
          then.apply(this, arguments);
        }
      }
    });
  };
});
/*  Sequential composition operator (inverted _.compose, basically)
    ======================================================================== */


_.withTest(['function', 'sequence / then'], function () {
  var context = {
    foo: 'bar'
  };

  var makeCookies = function (from) {
    $assert(this === context);
    return 'cookies from ' + from;
  };

  var eatCookies = function (cookies) {
    $assert(this === context);
    return 'nice ' + cookies;
  };

  var lifeProcess = makeCookies.then ? // available in both notations
  makeCookies.then(eatCookies) : _.then(makeCookies, eatCookies);

  var anotherWay = _.sequence(makeCookies, eatCookies);

  var wayAnother = _.sequence([makeCookies, eatCookies]);

  $assert(lifeProcess.call(context, 'shit'), 'nice cookies from shit');
  $assert(anotherWay.call(context, 'shit'), 'nice cookies from shit');
  $assert(wayAnother.call(context, 'shit'), 'nice cookies from shit');
  $assert(_.sequence([]).call(context, 'foo'), 'foo');

  var plusBar = _.then(function (x) {
    return Promise.resolve(x);
  }, function (x) {
    return x + 'bar';
  });

  return plusBar('foo').then(function (x) {
    $assert(x, 'foobar');
  });
}, function () {
  _.sequence = function (arg) {
    // was _.flip (_.compose) before... but it needs performance
    var chain = _.isArray(arg) ? arg : _.asArray(arguments);
    var length = chain.length;
    return length === 0 ? _.identity : function (x) {
      for (var i = 0; i < length; i++) {
        x = chain[i].call(this, x);
      }

      return x;
    };
  };

  _.seq = _.sequence;

  _.then = function (fn1, fn2) {
    return function (args) {
      var r = fn1.apply(this, arguments);
      return r instanceof Promise ? r.then(fn2.bind(this)) : fn2.call(this, r);
    };
  };
});
},{"underscore":"node_modules/underscore/underscore.js"}],"node_modules/useless/base/tier0/busybox.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var _ = require('underscore');
/*  Basic utility for writing data-crunching functional expressions.
    ======================================================================== */


_.typeOf = function (what) {
  return _typeof(what);
};

_.instanceOf = function (what) {
  return function (x) {
    return x instanceof what;
  };
};

_.count = function (what) {
  // cannot override _.length
  return what.length;
};

_.array = _.tuple = function () {
  return _.asArray(arguments);
};

_.cons = function (head, tail) {
  return [head].concat(tail || []);
};

_.atIndex = function (n) {
  return function (arr) {
    return arr[n];
  };
};

_.takesFirst = _.higherOrder(_.first);
_.takesLast = _.higherOrder(_.last);

_.applies = function (fn, this_, args) {
  return function () {
    return fn.apply(this_, args);
  };
};

_.prepends = function (what) {
  return function (to) {
    return what + to;
  };
};

_.appends = function (what) {
  return function (to) {
    return to + what;
  };
};

_.join = function (arr, s) {
  return arr.join(s);
};

_.joinWith = _.flip2(_.join);
_.joinsWith = _.higherOrder(_.joinWith);

_.split = function (s, del) {
  return s.split(del);
};

_.splitWith = _.flip2(_.split);
_.splitsWith = _.higherOrder(_.splitWith);

_.sum = function (a, b) {
  return (a || 0) + (b || 0);
};

_.subtract = function (a, b) {
  return (a || 0) - (b || 0);
};

_.mul = function (a, b) {
  return (a || 0) * (b || 0);
};

_.equal = function (a, b) {
  return a === b;
};

_.sums = _.plus = _.higherOrder(_.sum);
_.subtracts = _.minus = _.higherOrder(_.subtract);
_.muls = _.higherOrder(_.mul);
_.equals = _.higherOrder(_.equal);

_.less = function (a, b) {
  return a < b;
};

_.lessOrEqual = function (a, b) {
  return a <= b;
};

_.greater = function (a, b) {
  return a > b;
};

_.greaterOrEqual = function (a, b) {
  return a >= b;
};

_.isNegative = function (a) {
  return a < 0;
};

_.largest = function (a, b) {
  // FFFFUUUU: underscore already taken _.max for its dirty needs.
  if (isNaN(a) && isNaN(b)) {
    return NaN;
  } else if (isNaN(a)) {
    return b;
  } else if (isNaN(b)) {
    return a;
  } else {
    return Math.max(a, b);
  }
};

_.notZero = function (x) {
  return x !== 0;
};

_.propertyOf = function (obj) {
  return function (prop) {
    // inverted version of _.property
    return obj[prop];
  };
};

_.oneOf = $restArg(function () {
  return _.propertyOf(_.index(_.asArray(arguments)));
});
},{"underscore":"node_modules/underscore/underscore.js"}],"node_modules/reflect.ownkeys/index.js":[function(require,module,exports) {
if (typeof Reflect === 'object' && typeof Reflect.ownKeys === 'function') {
  module.exports = Reflect.ownKeys;
} else if (typeof Object.getOwnPropertySymbols === 'function') {
  module.exports = function Reflect_ownKeys(o) {
    return (
      Object.getOwnPropertyNames(o).concat(Object.getOwnPropertySymbols(o))
    );
  }
} else {
  module.exports = Object.getOwnPropertyNames;
}

},{}],"node_modules/es7-object-polyfill/es7-object-polyfill.js":[function(require,module,exports) {
module.exports = (function () {
	"use strict";

	var ownKeys      = require ('reflect.ownkeys')
	var reduce       = Function.bind.call(Function.call, Array.prototype.reduce);
	var isEnumerable = Function.bind.call(Function.call, Object.prototype.propertyIsEnumerable);
	var concat       = Function.bind.call(Function.call, Array.prototype.concat);

	if (!Object.values) {
		 Object.values = function values(O) {
			return reduce(ownKeys(O), (v, k) => concat(v, typeof k === 'string' && isEnumerable(O, k) ? [O[k]] : []), []) } }

	if (!Object.entries) {
		 Object.entries = function entries(O) {
			return reduce(ownKeys(O), (e, k) => concat(e, typeof k === 'string' && isEnumerable(O, k) ? [[k, O[k]]] : []), []) } }

	return Object

}) ();
},{"reflect.ownkeys":"node_modules/reflect.ownkeys/index.js"}],"node_modules/useless/base/tier0/type.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var _ = require('underscore');

var O = require('es7-object-polyfill');
/*  isTypeOf
    ======================================================================== */


_.isTypeOf = function (constructor, what) {
  return what instanceof constructor;
};

_.isPrototypeInstance = function (x) {
  return x && x.constructor && _.isPrototypeConstructor(x.constructor);
};

_.isPrototypeConstructor = function (x) {
  return x && x.$definition !== undefined || false;
};
/*  NaN has interesting property: Number.NaN !== Number.NaN, this makes it
    more preferable than undefined/null in some cases. This function converts
    anything that is not a number to NaN.
    ======================================================================== */


_.coerceToNaN = function (x) {
  return _.isFinite(x) ? x : Number.NaN;
};
/*  Useful for defining functions that accept either [x] or x as argument
    ======================================================================== */


_.coerceToArray = function (x) {
  return x === undefined ? [] : _.isArray(x) ? x : [x];
};
/*  Useful for defining flow control parameterization
    ======================================================================== */


_.coerceToFunction = function (x) {
  return _.isFunction(x) ? x : _.constant(x);
};
/*  Use to determine whether an object could be enumerated like an Array
    TODO: it may be more reasonable to check for 'length' property presence
    ======================================================================== */


_.isArrayLike = function (x) {
  return x instanceof Array || $platform.Browser && x instanceof NodeList;
};
/*  Fixes _.isArray to account objects that derive from Array prototype
    ======================================================================== */


_.deferTest(['type', 'isArray'], function () {
  var CustomArray = $extends(Array, {
    method: function () {
      return 42;
    }
  });
  $assert(_.isArray(new CustomArray()));
}, function () {
  _.isArray = function (x) {
    return x instanceof Array;
  };
});
/*  Better _.matches / $assertMatches: +regexp feature, +deep matching
    ======================================================================== */


_.deferTest(['type', 'matches(regex)'], function () {
  var test = function (a, pattern) {
    $assert(_.match(a, pattern));
    $assert(_.matches(pattern)(a));
    $assertMatches(a, pattern);
  };

  $assertFails(function () {
    test({
      foo: [1, 2],
      bar: 2
    }, {
      foo: [3],
      bar: 2
    });
    test({
      bar: {
        foo: 'foo'
      }
    }, {
      bar: {
        foo: /[0-9]+/
      }
    });
    test({}, {
      foo: 1
    });
  });
  $assertFails(function () {
    test({
      foo: 1
    }, undefined); // differs from original impl in that

    test('.DS_Store', /.+\.js/);
  }); // regression

  test({
    foo: [1, 2],
    bar: 2
  }, {
    foo: [2]
  });
  test({
    bar: {
      foo: '123',
      qux: 1
    }
  }, {
    bar: {
      foo: /[0-9]+/
    }
  });
  test({
    foo: 1
  }, {});
}, function () {
  _.mixin({
    matches: function (pattern) {
      return arguments.length === 0 && _.constant(true) || _.tails2(_.match, pattern);
    },
    match: function (a, ptrn) {
      return a === ptrn || _.isArray(a) && _.isArray(ptrn) && _.arrayMatch(a, ptrn) || _.isObject(a) && _.isObject(ptrn) && _.objectMatch(a, ptrn) || _.isTypeOf(RegExp, ptrn) && _.isString(a) && a.match(ptrn) !== null;
    },
    arrayMatch: function (a, pattern) {
      return _.every(pattern, _.propertyOf(_.index(a)));
    },
    objectMatch: function (a, pattern) {
      return _.reduce(O.entries(pattern), function (result, kv) {
        return result && _.match(a[kv[0]], kv[1]);
      }, true);
    }
  });
});
/*  Scalar values
    ======================================================================== */


_.withTest(['type', 'isScalar'], function () {
  $assert(_.every([0, 42, 'foo', null, undefined, true, false], _.isScalar));
  $assert(_.every([/foo/, new Date(), {}, []], _.not(_.isScalar)));
}, function () {
  _.isScalar = function (v) {
    return v === undefined || v === null || v.constructor === String || v.constructor === Number || v.constructor === Boolean;
  };
});
/*  POD data types
    ======================================================================== */


_.withTest(['type', 'POD'], function () {
  $assert(_.every([[], {}, 42, 0, 'foo', null, undefined, true].map(_.isPOD)));
  $assert(_.every([/foo/, new Date()].map(_.isNonPOD)));
}, function () {
  _.isNonPOD = function (v) {
    return !_.isPOD(v);
  };

  _.isPOD = function (v) {
    return _.isScalar(v) || v && (v.constructor === Object || v.constructor === Array);
  };
});
/*  'empty' classifiers (fixes underscore shit)
    ======================================================================== */


_.withTest(['type', 'empty-centric routines'], function () {
  $assert(_.coerceToObject({
    foo: 42
  }), {
    foo: 42
  });
  $assert(_.coerceToObject([1, 2, 3]), [1, 2, 3]);
  $assert(_.coerceToObject(42), {});
  $assert(_.coerceToObject(undefined), {});
  $assert(_.coerceToEmpty(42), undefined);
  $assert(_.coerceToEmpty([42]), []);
  $assert(_.coerceToEmpty({
    foo: 42
  }), {});
  $assert([_.isNonemptyString('foo'), _.isNonemptyString(''), _.isNonemptyString([])], [true, false, false]);
  $assert(_.isEmptyArray([]), true);
  $assert(_.isEmptyArray([1, 2, 3]), false);
  $assert(_.isEmptyArray(undefined), false);
  $assert(_.isEmptyArray(null), false);
  $assert(_.isEmptyArray(''), false);
  $assert(_.isEmptyObject({}), true);
  $assert(_.isEmptyObject([]), false);
  $assert(_.isEmptyObject({
    foo: 1
  }), false);
  $assert(_.isEmptyObject(undefined), false);
  $assert(_.isEmptyObject(null), false);
  $assert(_.isEmptyObject(''), false);
  $assert(_.isEmptyObject(0), false);
  $assert(_.isEmptyObject(false), false);
  $assert(_.isEmpty(0), false);
  $assert(_.isEmpty(false), false);
  $assert(_.isEmpty(/.+\.js/), false); // regression

  $assert(_.isEmpty(null), true);
  $assert(_.isEmpty({}), true);
  $assert(_.isEmpty([]), true);
  $assert(_.isNonempty('foo'), true); // negated _.isEmpty

  $assert(_.coerceToUndefined(undefined), undefined);
  $assert(_.coerceToUndefined({}), undefined);
  $assert(_.coerceToUndefined([]), undefined);
  $assert(_.coerceToUndefined(''), undefined);
  $assert(_.coerceToUndefined(null), undefined);
  $assert(_.coerceToUndefined(0), 0);
  $assert(_.coerceToUndefined(Math.NaN), undefined);
  $assert(_.coerceToUndefined(false), false);
  $assert(_.coerceToUndefined({
    foo: 1
  }), {
    foo: 1
  });
  $assert(_.coerceToUndefined([1, 2]), [1, 2]);
}, function () {
  _.extend(_, {
    /*  These two override underscore's one, because the original stuff is semantically incorrect.
        A word needs to be spoken here, because it's not the first routine we override, and not
        the last. So what about semantics?
         For instance, 0 and false should NOT be treated as empty. But they are (in underscore).
        This is ridiculous. Can think of hundreds of applications of the correct impl., and
        just none of that for the creeped original version. Why would one ever need to treat 0
        as 'empty'? Shit, its just a regular number, no worse or better than 1 or 42. And 'false'?
        Keep hands off boolean logic. If someone states that something's false - it's false, not
        a 'void non-existing piece of nothing'. It's a value. It has value. And it's false. Oh,
        fock, just don't get me started...
     */
    isEmpty: function (obj) {
      return _.coerceToUndefined(obj) === undefined;
    },
    isNonempty: function (obj) {
      return _.coerceToUndefined(obj) !== undefined;
    },
    isEmptyObject: function (v) {
      return !_.isArray(v) && !_.isFunction(v) && _.isObject(v) && _.keys(v).length === 0;
    },
    isStrictlyObject: function (v) {
      return v && _typeof(v) === 'object' ? true : false;
    },
    isEmptyArray: function (v) {
      return _.isArray(v) && v.length === 0;
    },
    isNonemptyString: function (v) {
      return typeof v === 'string' && v.length > 0;
    },
    coerceToObject: function (x) {
      return _.isStrictlyObject(x) ? x : {};
    },
    coerceToEmpty: function (x) {
      if (_.isArray(x)) {
        return [];
      } else if (_.isStrictlyObject(x)) {
        return {};
      } else {
        return undefined;
      }
    },

    /*  Projects a variety of input values through 'undefined/non-undefined' dichotomy.
     */
    coerceToUndefined: function (v) {
      return v === undefined || v === null || v === Math.NaN || v === '' || _.isPOD(v) && (_.isEmptyObject(v) || v.length === 0) ? undefined : v;
    }
  });
});
},{"underscore":"node_modules/underscore/underscore.js","es7-object-polyfill":"node_modules/es7-object-polyfill/es7-object-polyfill.js"}],"node_modules/useless/base/tier0/stdlib.js":[function(require,module,exports) {
"use strict";

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var _ = require('underscore');

var O = require('es7-object-polyfill');

var Meta = require('meta-fields');

_.hasStdlib = true;
/*  _.throwsError
    ======================================================================== */

_.withTest(['stdlib', 'throwsError'], function () {
  $assertThrows(_.throws('foo'), 'foo');
  $assertThrows(_.throwsError(' '), _.matches({
    message: ' '
  }));
  $assertThrows(_.throwsError(new Error(' ')), _.matches({
    message: ' '
  }));
}, function () {
  _.throwsError = _.higherOrder(_.throwError = function (msg) {
    throw msg instanceof Error ? msg : new Error(msg);
  });
  _.throws = _.higherOrder(_.throw = function (msg) {
    throw msg;
  });
  _.overrideThis = _.throwsError('override this');
  _.notImplemented = _.throwsError('not implemented');
});
/*  Abstract _.values
    ======================================================================== */


_.withTest(['stdlib', 'values2'], function () {
  $assert(_.values2(undefined), []);
  $assert(_.values2(_.identity), [_.identity]);
  $assert(_.values2('foo'), ['foo']);
  $assert(_.values2(['foo', 'bar']), ['foo', 'bar']);
  $assert(_.values2({
    f: 'foo',
    b: 'bar'
  }), ['foo', 'bar']);
}, function () {
  _.mixin({
    values2: function (x) {
      if (_.isArrayLike(x)) {
        return x;
      } else if (_.isStrictlyObject(x)) {
        return _.values(x);
      } else if (_.isEmpty(x)) {
        return [];
      } else {
        return [x];
      }
    }
  });
});
/*  Map 2.0
    ======================================================================== */

/*  Semantically-correct abstract map (maps any type of value)
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */


_.withTest(['stdlib', 'map2'], function () {
  var plusBar = _.appends('bar');

  $assert(_.map2('foo', plusBar), 'foobar');
  $assert(_.map2(['foo'], plusBar), ['foobar']);
  $assert(_.map2({
    foo: 'foo'
  }, plusBar), {
    foo: 'foobar'
  });
  $assert(Array.from(_.map2(new Set(['foo', 'bar']), plusBar).values()), ['foobar', 'barbar']);
  /*  With flipped order of arguments (callback first)
   */

  $assert(_.mapWith(plusBar, {
    foo: 'foo'
  }), {
    foo: 'foobar'
  });
}, function () {
  _.mixin({
    map2: function (value, fn, context) {
      return _.isArrayLike(value) ? _.map(value, fn, context) : value instanceof Set ? _.mapSet(value, fn, context) : _.isStrictlyObject(value) ? _.mapValues(value, fn, context) : fn.call(context, value);
    }
  });

  _.mapSet = function (set, fn, ctx) {
    var out = new Set();

    for (var x of set) {
      out.add(fn.call(ctx, x));
    }

    return out;
  };

  _.mapsWith = _.higherOrder(_.mapWith = _.flip2(_.map2));
});
/*  Pluck 2.0
    ======================================================================== */


_.pluck2 = function (x, prop) {
  return _.map2(x, _.property(prop));
};
/*  Maps one-to-many
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */


_.withTest(['stdlib', 'scatter/obj/arr'], function () {
  $assert(undefined, _.scatter([], _.noop));
  $assert([1, 10, 2, 20, 3, 30], _.scatter([1, 2, 3], function (x, i, return_) {
    return_(x);
    return_(x * 10);
  }));
  $assert({
    'b': 0,
    'a': 1,
    'r': 2
  }, _.scatter('bar', function (x, i, return_) {
    _.each(x.split(''), _.flip(return_));
  }));
  $assert(_.obj(_.noop), _.arr(_.noop), undefined);
  $assert(_.obj(function (emit) {
    emit(42, 'foo');
    emit(43, 'bar');
  }), {
    foo: 42,
    bar: 43
  });
  $assert(_.arr(function (emit) {
    emit(42);
    emit(43, 44);
  }), [42, [43, 44]]);
}, function () {
  _.mixin({
    scatter: function (obj, elem) {
      var result = undefined;

      _.map2(obj, function (x, i) {
        elem(x, i, function (v, k) {
          if (arguments.length < 2) {
            (result = result || []).push(v);
          } else {
            (result = result || {})[k] = v;
          }
        });
      });

      return result;
    }
  });

  _.obj = function (emitItems) {
    var x = undefined;
    emitItems(function (v, k) {
      (x = x || {})[k] = v;
    });
    return x;
  };

  _.arr = function (emitItems) {
    var x = undefined;
    emitItems(function (v) {
      (x = x || []).push(arguments.length < 2 ? v : _.asArray(arguments));
    });
    return x;
  };
});
/*  Maps keys (instead of values)
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */


_.withTest(['stdlib', 'mapKeys'], function () {
  $assert(_.mapKeys({
    'foo': [1, 2, {
      'gay': 3
    }]
  }, _.appends('bar')), {
    'foobar': [1, 2, {
      'gaybar': 3
    }]
  });
}, function () {
  _.mapKeys = function (x, fn) {
    if (_.isArrayLike(x)) {
      return _.map(x, _.tails2(_.mapKeys, fn));
    } else if (_.isStrictlyObject(x)) {
      return _.fromPairs(_.map(O.entries(x), function (kv) {
        return [fn(kv[0]), _.mapKeys(kv[1], fn)];
      }));
    } else {
      return x;
    }
  };
});
/*  Hyper map (deep) #1  maps leafs
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */


_.withTest(['stdlib', 'mapMap'], function () {
  $assert(_.mapMap(7, _.typeOf), 'number'); // degenerate cases

  $assert(_.mapMap([7], _.typeOf), ['number']);
  $assert(_.mapMap({
    foo: 7,
    bar: ['foo', {
      bar: undefined
    }]
  }, _.typeOf), {
    foo: 'number',
    bar: ['string', {
      bar: 'undefined'
    }]
  });
}, function () {
  _.mapMap = _.hyperOperator(_.unary, _.map2);
});
/*  Hyper map (deep) #2  maps branches & leafs 
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */


_.withTest(['stdlib', 'hyperMap'], function () {
  var complexObject = {
    garply: {
      bar: {
        baz: 5
      }
    },
    frobni: {
      foo: [{
        bar: {
          baz: 5
        }
      }]
    }
  };
  /*                                         -----------------             */

  var barBazSubstructure = _.matches({
    bar: {
      baz: 5
    }
  });

  var transformedObject = _.hyperMap(complexObject, function (x) {
    if (barBazSubstructure(x)) {
      return 'pwned!';
    }
  });

  $assert(transformedObject, {
    garply: 'pwned!',
    frobni: {
      foo: ['pwned!']
    }
  });
}, function () {
  _.hyperMap = function (data, op) {
    return _.hyperOperator(_.unary, function (expr, f) {
      return op(expr) || _.map2(expr, f);
    })(data, _.identity);
  };
});
/*  Abstract _.pairs
    ======================================================================== */


_.withTest(['stdlib', 'pairs2'], function () {
  $assert(_.pairs2(undefined), [[undefined, undefined]]); // TODO: unify semantics with _.values2

  $assert(_.pairs2(_.identity), [[undefined, _.identity]]);
  $assert(_.pairs2('foo'), [[undefined, 'foo']]);
  $assert(_.pairs2(['foo', 'bar']), [[0, 'foo'], [1, 'bar']]);
  $assert(_.pairs2({
    0: 'foo',
    1: 'bar'
  }), [['0', 'foo'], ['1', 'bar']]);
}, function () {
  _.pairs2 = function (x) {
    return _.scatter(x, function (x, i, return_) {
      return_([i, x]);
    });
  };
});
/*  Filter 2.0
    ======================================================================== */


_.withTest(['stdlib', 'filter 2.0'], function () {
  var foo = _.equals('foo'); // generic filter behavior for any container type


  $assert(_.filter2('foo', foo), 'foo');
  $assert(_.filter2(['foo'], foo), ['foo']);
  $assert(_.filter2({
    f: 'foo'
  }, foo), {
    f: 'foo'
  });
  $assert(_.filter2('foo', _.not(foo)), undefined);
  $assert(_.filter2(['foo'], _.not(foo)), []);
  $assert(_.filter2({
    f: 'foo'
  }, _.not(foo)), {}); // map behavior, if predicate returns not boolean (mixed-behavior test not needed - although its the expected case of use)

  $assert(_.filter2('foo', _.constant('bar')), 'bar');
  $assert(_.filter2(['foo'], _.constant('bar')), ['bar']);
  $assert(_.filter2({
    f: 'foo'
  }, _.constant('bar')), {
    f: 'bar'
  }); // hyper-filter #1 (works on leafs)

  $assert(_.filterFilter({
    foo: 'foo',
    bar: [7, 'foo', {
      bar: 'foo'
    }]
  }, _.not(_.equals('foo'))), {
    bar: [7, {}]
  }); // there was a bug

  $assert(_.hyperFilter({
    foo: /regexp/
  }, _.constant(true)).foo instanceof RegExp);
}, function () {
  _.reject2 = function (value, op) {
    return _.filter2(value, _.not(op));
  };

  _.filter2 = function (value, op) {
    if (_.isArrayLike(value)) {
      var result = [];

      for (var i = 0, n = value.length; i < n; i++) {
        var v = value[i],
            opSays = op(v, i);

        if (opSays === true) {
          result.push(v);
        } else if (opSays !== false) {
          result.push(opSays);
        }
      }

      return result;
    } else if (_.isStrictlyObject(value)) {
      var result = {};

      _.each(Object.keys(value), function (key) {
        var v = value[key],
            opSays = op(v, key);

        if (opSays === true) {
          result[key] = v;
        } else if (opSays !== false) {
          result[key] = opSays;
        }
      });

      return result;
    } else {
      var opSays = op(value);

      if (opSays === true) {
        return value;
      } else if (opSays !== false) {
        return opSays;
      } else {
        return undefined;
      }
    }
  };

  _.filterFilter = _.hyperOperator(_.unary, _.filter2);

  _.hyperFilter = function (data, op) {
    return _.hyperOperator(_.unary, function (expr, f) {
      var x = op(expr);
      return x === true && _.filter2(expr, f) || x;
    })(data, _.identity);
  };

  _.hyperReject = function (data, op) {
    return _.hyperFilter(data, function (x) {
      var opa = op(x);
      return _.isBoolean(opa) ? !opa : opa;
    });
  };
});
/*  ------------------------------------------------------------------------ */


_.withTest(['stdlib', 'each 2.0'], function () {
  var test = function (input) {
    var output = [];

    _.each2(input, function (x, i, n) {
      output.push([x, i, n]);
    });

    return output;
  };

  $assert(test('foo'), [['foo', undefined, 1]]);
  $assert(test(['foo', 'bar']), [['foo', 0, 2], ['bar', 1, 2]]);
  $assert(test({
    'f': 'oo',
    'b': 'ar'
  }), [['oo', 'f', 2], ['ar', 'b', 2]]);
}, function () {
  _.each2 = function (x, f) {
    if (_.isArrayLike(x)) {
      for (var i = 0, n = x.length; i < n; i++) {
        f(x[i], i, n);
      }
    } // @hide
    else if (_.isStrictlyObject(x)) {
        var k = Object.keys(x);

        for (var ki, i = 0, n = k.length; i < n; i++) {
          f(x[ki = k[i]], ki, n);
        }
      } else {
        f(x, undefined, 1);
      }
  };
});
/*  Reduce on steroids
    ======================================================================== */


_.withTest(['stdlib', 'reduce 2.0'], function () {
  $assert(_.reduce2(3, [7, 9], _.sum), 19);
  $assert(_.reduce2([3, 7, 9], _.sum), 19);
  $assert(_.reduce2({
    a: 3,
    b: 7,
    c: 9
  }, _.sum), 19);
  $assert(_.reduce2(3 + 7 + 9, _.sum), 19);
  $assert(_.reduce2([1], _.sum), 1);
  $assert(_.reduce2([], _.sum), undefined);
  $assert(1 + 20 + 3 + 4 + 5, _.reduceReduce([[[1], 20], [3, [4, 5]]], function (a, b) {
    return _.isNumber(a) && _.isNumber(b) ? a + b : b;
  }));
}, function () {
  /*  Because hyperOperator is fractal thing, it is nessesary to define a compatible argument
      order for _.reduce and its functor operand, as they get melted together to form a generic
      self-similar routine of a higher order.
       And that becames kinda "Yodish" when applied to familiar 'reduce'. See how they dont match:
           1. _.reduce (value, op, memo)
          2.       op (memo, value)
  */
  _.reduce2 = function (_1, _2, _3) {
    var no_left = arguments.length < 3;
    var left = _1,
        rights = _2,
        op = _3;

    if (no_left) {
      left = undefined;
      rights = _1;
      op = _2;
    }

    _.each2(rights, function (right, i) {
      left = no_left ? right : op(left, right);
      no_left = false;
    });

    return left;
  }; // @hide


  _.reduceReduce = function (_1, _2, _3) {
    var initial = _1,
        value = _2,
        op = _3;

    if (arguments.length < 3) {
      initial = {};
      value = _1;
      op = _2;
    }

    return _.hyperOperator(_.binary, _.reduce2, _.goDeeperAlwaysIfPossible)(initial, value, op);
  };
});
/*  Abstract concat
    ======================================================================== */


_.withTest(['stdlib', 'concat2'], function () {
  $assert(_.concat([1, 2], [3], [4, 5]), [1, 2, 3, 4, 5]);
  $assert(_.concat({
    foo: 1
  }, {
    bar: 2
  }), {
    foo: 1,
    bar: 2
  });
  $assert(_.concat([{
    foo: 1
  }, {
    bar: 2
  }]), {
    foo: 1,
    bar: 2
  });
  $assert(_.concat(1, 2, 3), 6);
}, function () {
  _.concat = function (a, b) {
    var first, rest;

    if (arguments.length === 1) {
      first = a[0];
      rest = a.slice(1);
    } else {
      first = a;
      rest = [].slice.call(arguments, 1);
    }

    return _.isArrayLike(first) ? first.concat.apply(first, rest) : _.reduce2(first, rest, function (a, b) {
      if (_.isObject(a) && _.isObject(b)) {
        return _.extend({}, a, b);
      } else {
        return a + b;
      }
    });
  };
});
/*  Zip 2.0
    ======================================================================== */

/*  Abstract zip that reduces any types of matrices.
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */


_.deferTest(['stdlib', 'zip2'], function () {
  $assert(_.zip2(['f', 'o', 'o'], _.concat), 'foo');
  $assert(_.zip2([['f', 'b'], ['o', 'a'], ['o', 'r']], _.concat), ['foo', 'bar']);
  $assert(_.zip2([{
    foo: 'f',
    bar: 'b'
  }, {
    foo: 'o',
    bar: 'a'
  }, {
    foo: 'o',
    bar: 'r'
  }], _.concat), {
    foo: 'foo',
    bar: 'bar'
  });
  $assert(_.zip2({
    foo: 'f',
    bar: 'b'
  }, // passing rows as arguments
  {
    foo: 'o',
    bar: 'a'
  }, {
    foo: 'o',
    bar: 'r'
  }, _.concat), {
    foo: 'foo',
    bar: 'bar'
  });
  $assert(_.zip2(undefined, _.concat), undefined); // degenerate cases

  $assert(_.zip2(5, _.concat), 5);
  $assert(_.zip2([], _.concat), []);
  $assert(_.zip2(['foo'], _.concat), 'foo');
  $assert(_.zipObjectsWith([{
    name: 'string'
  }, {
    born: 123
  }], _.array), {
    name: ['string', undefined],
    born: [undefined, 123]
  });
  $assert([3], _.zipSetsWith([new Set([2, 3]), new Set([3, 4])], function (a, b) {
    return a && b;
  }).asArray);
}, function () {
  _.mixin({
    zipSetsWith: function (sets, fn) {
      return _.reduce(sets.slice(1), function (memo, obj) {
        _.each(_.union(obj && Array.from(obj.values()) || [], memo && Array.from(memo.values()) || []), function (k) {
          var zipped = fn(memo && memo.has(k) ? k : undefined, obj && obj.has(k) ? k : undefined);

          if (zipped === undefined) {
            memo.delete(k);
          } else {
            memo.add(zipped);
          }
        });

        return memo;
      }, new Set(sets[0]));
    },
    zipObjectsWith: function (objects, fn) {
      return _.reduce(objects.slice(1), function (memo, obj) {
        _.each(_.union(_.keys(obj), _.keys(memo)), function (k) {
          var zipped = fn(memo && memo[k], obj && obj[k]);

          if (zipped === undefined) {
            delete memo[k];
          } else {
            memo[k] = zipped;
          }
        });

        return memo;
      }, _.clone(objects[0]));
    },
    zip2: function (rows_, fn_) {
      var rows = arguments.length === 2 ? rows_ : _.initial(arguments);
      var fn = arguments.length === 2 ? fn_ : _.last(arguments);

      if (!_.isArrayLike(rows) || rows.length === 0) {
        return rows;
      } else {
        if (_.isArrayLike(rows[0])) {
          return _.zipWith(rows, fn);
        } else if (rows[0] instanceof Set) {
          return _.zipSetsWith(rows, fn);
        } else if (_.isStrictlyObject(rows[0])) {
          return _.zipObjectsWith(rows, fn);
        } else {
          return _.reduce2(rows, fn);
        }
      }
    }
  });
});
/*  Hyperzip (deep one).
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */


_.withTest(['stdlib', 'zipZip'], function () {
  $assert(_.zipZip({
    phones: [{
      number: 'number'
    }]
  }, {
    phones: [{
      number: 333
    }]
  }, _.array), {
    phones: [{
      number: ['number', 333]
    }]
  });
  $assert(_.zipZip([{
    foo: 7,
    bar: ['foo', {
      bar: undefined
    }]
  }, {
    foo: 'number',
    bar: ['string', {
      bar: 'undefined'
    }]
  }], _.array), {
    foo: [7, 'number'],
    bar: [['foo', 'string'], {
      bar: [undefined, 'undefined']
    }]
  });
}, function () {
  _.mixin({
    zipZip: _.hyperOperator(_.binary, _.zip2)
  });
});
/*  Most useful _.extend derivatives
    ======================================================================== */


_.withTest(['stdlib', 'extend 2.0'], function () {
  /*  Inverted version of _.extend, for humanized narration where it makes sense (not here,
      but see AOP impl for example of such one)
   */
  [function () {
    var input = {
      foo: 1,
      bar: 1
    };
    var plus = {
      foo: 42,
      qux: 1
    };
    var gives = {
      foo: 42,
      qux: 1,
      bar: 1
    };
    $assert(_.extendWith(plus, input), gives);
  }(),
  /*  Higher-order version of _.extend, allows to use it as _.map operator, which cuts
      shit in typical arrays-of-objects crunching routines
   */
  function () {
    var input = [{
      bar: 1
    }, {}];

    var plus = _.extendsWith({
      foo: 42
    });

    var gives = [{
      bar: 1,
      foo: 42
    }, {
      foo: 42
    }];
    $assert(_.map(input, _.arity1(plus)), gives);
  }(),
  /*  NOW DEPRECATED, USE _.extendedDeep
   */
  function () {
    var input = {
      foo: 1,
      bar: {
        qux: 1
      }
    };
    var plus = {
      foo: 42,
      bar: {
        baz: 1
      }
    };
    var gives = {
      foo: 42,
      bar: {
        baz: 1,
        qux: 1
      }
    };
    $assert(_.extend2(input, plus), gives);
  }(),
  /*  Deep version of _.extend, allowing to extend arbitrary levels deep (referentially transparent, so _.extendedDeep instead of _.extendDeep)
   */
  function () {
    var input = {
      foo: 1,
      bar: {
        qux: 1
      }
    };
    var plus = {
      foo: 42,
      bar: {
        baz: 1
      }
    };
    var gives = {
      foo: 42,
      bar: {
        baz: 1,
        qux: 1
      }
    };
    $assert(_.extendedDeep(input, plus), gives);
    $assert(_.extendedDeep({
      foo: new Set([7])
    }, {}).foo instanceof Set);
    $assert(Array.from(_.extendedDeep({
      foo: new Set([1, 2])
    }, {
      foo: new Set([2, 3])
    }).foo.values()), [1, 2, 3]);
    $assert(_.extendedDeep({
      foo: 4
    }, {
      bar: 5
    }, {
      qux: 6
    }), {
      foo: 4,
      bar: 5,
      qux: 6
    }); // >2 arguments

    $assert(_.extendedDeep({
      foo: ['a', 'b']
    }, {
      foo: ['c']
    }), {
      foo: ['c']
    }); // default array merge semantics (replace)

    $assert(_.extendedDeep({
      foo: ['a', 'b']
    }, {
      foo: $concat(['c'])
    }), {
      foo: ['a', 'b', 'c']
    }); // optional merge semantics (concats arrays)
  }(),
  /*  Referentially-transparent version (to be used in functional expressions)
   */
  function () {
    var x = {
      foo: 1
    };
    $assert(_.extended(x, {
      bar: 1
    }), {
      foo: 1,
      bar: 1
    });
    $assert(x, {
      foo: 1
    });
  }()];
}, function () {
  _.extend = $restArg(_.extend); // Mark as having rest argument (to make _.flip work on that shit)

  _.extended = $restArg(function () {
    return _.extend.apply(this, [{}].concat(_.asArray(arguments)));
  }); // referentially-transparent version

  _.extendWith = _.flip(_.extend);
  _.extendsWith = _.flip(_.partial(_.partial, _.flip(_.extend))); // higher order shit

  Meta.globalTag('concat');

  _.extendedDeep = function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _.reduce(args, function (a, b) {
      return _.extendedDeep.zipZip(a, b, function ($a, $b) {
        var a = $untag($a),
            b = $untag($b);
        return b === undefined ? a : _.isArray(a) && $concat.is($b) ? a.concat(b) : b;
      });
    });
  };

  _.extendedDeep.zipZip = _.hyperOperator(_.binary, _.zip2, _.goDeeperWhenFirstArgumentIsGood, function (x) {
    return !_.isArray(x) && _.isNonTrivial(x);
  });
  _.extend2 = $restArg(function (what) {
    return _.extend(what, _.reduceRight(arguments, function (right, left) {
      return _.fromPairs(_.map(_.union(_.keys(left), _.keys(right)), function (key) {
        var lvalue = left[key];
        return [key, key in right ? _typeof(lvalue) === 'object' ? _.extend(lvalue, right[key]) : right[key] : lvalue];
      }));
    }, {}));
  });
});
/*  Find 2.0 + Hyperfind
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */


_.withTest(['stdlib', 'findFind'], function () {
  var obj = {
    x: 1,
    y: {
      z: 2
    }
  };
  $assert(_.findFind({
    foo: 1,
    bar: [1, 2, 3]
  }, _.constant(false)), false);
  $assert(_.findFind({
    foo: 1,
    bar: [1, 2, 3]
  }, _.equals(2)), 2);
  $assert(_.findFind({
    foo: {
      bar: obj
    }
  }, _.equals(obj)), obj);
}, function () {
  _.find2 = function (value, pred) {
    if (_.isArrayLike(value)) {
      for (var i = 0, n = value.length; i < n; i++) {
        var x = pred(value[i], i, value);

        if (typeof x !== 'boolean') {
          return x;
        } else if (x === true) {
          return value[i];
        }
      }
    } else if (_.isStrictlyObject(value)) {
      for (var i = 0, ks = Object.keys(value), n = ks.length; i < n; i++) {
        var k = ks[i];
        var x = pred(value[k], k, value);

        if (typeof x !== 'boolean') {
          return x;
        } else if (x === true) {
          return value[k];
        }
      }
    }
  };

  _.findFind = function (obj, pred_) {
    return _.hyperOperator(_.unary, function (value, pred) {
      if (_.isArrayLike(value)) {
        for (var i = 0, n = value.length; i < n; i++) {
          var x = pred(value[i]);

          if (typeof x !== 'boolean') {
            return x;
          } else if (x === true) {
            return value[i];
          }
        }
      } else if (_.isStrictlyObject(value)) {
        for (var i = 0, ks = Object.keys(value), n = ks.length; i < n; i++) {
          var k = ks[i];
          var x = pred(value[k]);

          if (typeof x !== 'boolean') {
            return x;
          } else if (x === true) {
            return value[k];
          }
        }
      }

      var x = pred_(value);

      if (typeof x !== 'boolean') {
        return x;
      } else if (x === true) {
        return value;
      }

      return false;
    })(obj, pred_);
  };
});
/*  removes empty contents from any kinds of objects
    ======================================================================== */


_.withTest(['stdlib', 'nonempty'], function () {
  var obj = {
    blank: {},
    empty: [],
    one: 1,
    none: undefined,
    nil: null,
    clear: '',
    zero: 0,
    no: false
  };
  var arr = [{}, [], 1, undefined, null, '', 0, false];
  $assert(_.nonempty(obj), {
    one: 1,
    zero: 0,
    no: false
  });
  $assert(_.nonempty(arr), [1, 0, false]);
  $assert(_.nonempty(null), undefined);
  $assert(_.nonempty(''), undefined);
}, function () {
  _.nonempty = function (obj) {
    return _.filter2(obj, _.isNonempty);
  };
});
/*  deep cloning of objects (as _.clone is shallow)
    ======================================================================== */


_.deferTest(['stdlib', 'cloneDeep'], function () {
  var Proto = $prototype({});
  var obj = {
    a: [{
      b: {
        c: 'd'
      }
    }],
    b: {},
    c: new Proto(),
    e: new Date()
  };

  var copy = _.cloneDeep(obj);

  $assert(obj !== copy); // should be distinct references

  $assert(obj.a !== copy.a); //

  $assert(obj.b !== copy.b); //

  $assert(obj.c === copy.c); // should be same instance (should consider prototype instances as atomic value)

  $assert(obj.e === copy.e); // Date should not be cloned

  $assert(obj, copy); // structure should not change

  $assert(_.cloneDeep({
    foo: new Set()
  }).foo instanceof Set);
  $assert(Array.from(_.cloneDeep({
    foo: new Set([1, 2, 3])
  }).foo.values()), [1, 2, 3]);
}, function () {
  _.extend(_, {
    clone: function (x) {
      return x instanceof Set ? new Set(x) : x instanceof Date ? x : !_.isObject(x) ? x : _.isArray(x) ? x.slice() : _.extend({}, x);
    },
    cloneDeep: _.tails2(_.mapMap, function (value) {
      return _.isStrictlyObject(value) && !_.isPrototypeInstance(value) ? _.clone(value) : value;
    })
  });
});
/*  given objects A and B, _.diff subtracts A's structure from B,
    and returns difference in terms of B
    ======================================================================== */


_.deferTest(['stdlib', 'diff'], function () {
  $assert(_.diff('foo', 'foo'), undefined);
  $assert(_.diff('foo', 'bar'), 'bar');
  $assert(_.diff({
    a: 1,
    b: 2,
    c: 3
  }, {
    a: 1,
    b: 3,
    d: 4
  }), {
    b: 3,
    d: 4
  });
  $assert(_.diff([1, 2, 3], [1, 2, 3]), undefined);
  $assert(_.diff([1, 'foo', 2], [1, 2, 3]), [2, 3]);
}, function () {
  _.hyperMatch = _.hyperOperator(_.binary, function (a, b, pred) {
    return _.coerceToUndefined(_.nonempty(_.zip2(a, b, pred)));
  });
  _.diff = _.tails3(_.hyperMatch, function (a, b) {
    return $atom.unwrap(a) === $atom.unwrap(b) || a === $any || b === $any ? undefined : b;
  });
});
/*  inverse of _.diff (returns similarities)
    ======================================================================== */


_.deferTest(['stdlib', 'undiff'], function () {
  $assert(_.undiff('foo', 'foo'), 'foo');
  $assert(_.undiff('foo', 'bar'), undefined);
  $assert(_.undiff({
    a: 1,
    b: 2,
    c: 3
  }, {
    a: 1,
    b: 3,
    d: 4
  }), {
    a: 1
  });
  $assert(_.undiff([1, 2, 3], [1, 2, 3]), [1, 2, 3]);
  $assert(_.undiff([1, 2], [1, 3]), [1, undefined]);
  $assert(_.undiff([1, 2], [0, 2]), [undefined, 2]);
}, function () {
  _.hyperMatch = _.hyperOperator(_.binary, function (a, b, pred) {
    return _.coerceToUndefined(_.zip2(a, b, pred));
  });
  _.undiff = _.tails3(_.hyperMatch, function (a, b) {
    return $atom.unwrap(a) === $atom.unwrap(b) || a === $any || b === $any ? b : undefined;
  });
});
/*  Makes { foo: true, bar: true } from ['foo', 'bar']
    ======================================================================== */


_.withTest(['stdlib', 'index'], function () {
  $assert(_.index(['foo', 'bar']), {
    foo: true,
    bar: true
  });
}, function () {
  _.extend(_, {
    index: function (list) {
      var result = {};

      for (var i = 0, n = list.length; i < n; i++) {
        result[list[i]] = true;
      }

      return result;
    }
  });
});
/*  For string wrapping
    ======================================================================== */


_.withTest(['stdlib', 'quote'], function () {
  $assert(_.quote('qux'), 'qux');
  $assert(_.quote('qux', '[]'), '[qux]');
  $assert(_.quote('qux', '/'), '/qux/');
  $assert(_.quote('qux', '{  }'), '{ qux }');
  $assert(_.quote('qux', '</>'), '</qux>');
  $assert(_.quoteWith('[]', 'qux'), '[qux]');
}, function () {
  _.quote = function (s, pattern_) {
    var pattern = pattern_ || '';
    var splitAt = Math.floor(pattern.length / 2 + pattern.length % 2);
    var before = pattern.slice(0, splitAt);
    var after = pattern.slice(splitAt) || before;
    return before + s + after;
  };

  _.quoteWith = _.flip2(_.quote);
  _.quotesWith = _.higherOrder(_.quoteWith);
});
/*  _.partition 2.0
    ======================================================================== */


_.withTest(['stdlib', 'partition2'], function () {
  $assert(_.partition2(['a', 'b', 'c', undefined, undefined, 42], _.isNonempty), [['a', 'b', 'c'], [undefined, undefined], [42]]);
  $assert(_.partition3(['a', 'b', 'c', undefined, undefined, 42], _.typeOf), [{
    label: 'string',
    items: ['a', 'b', 'c']
  }, {
    label: 'undefined',
    items: [undefined, undefined]
  }, {
    label: 'number',
    items: [42]
  }]);
  $assert(_.partition3([{
    foo: 'a'
  }, {
    foo: 'a'
  }, {
    foo: 'b'
  }], 'foo'), [{
    foo: 'a',
    items: [{
      foo: 'a'
    }, {
      foo: 'a'
    }]
  }, {
    foo: 'b',
    items: [{
      foo: 'b'
    }]
  }]);
}, function () {
  _.partition2 = function (arr, pick) {
    return _.pluck(_.partition3(arr, pick), 'items');
  };

  _.partition3 = function (arr_, pick) {
    var arr = arr_ || [];
    var spans = [],
        span = {
      label: undefined,
      items: [arr.first]
    };
    var prop = _.isFunction(pick) ? 'label' : pick;
    var pickFn = _.isFunction(pick) ? pick : function (x) {
      return x[pick];
    };

    _.each(arr, function (x, i) {
      var value = pickFn(x, i);

      if (span[prop] != value && span.items.length) {
        var _span;

        spans.push(span = (_span = {}, _defineProperty(_span, prop, value), _defineProperty(_span, "items", [x]), _span));
      } else {
        span.items.push(x);
      }
    });

    return span.length && spans.push(span), spans;
  };
});
/*  Taken from  npmjs.com/package/longest-common-substring
    Props to    npmjs.com/~mirkok
    ======================================================================== */


_.withTest(['stdlib', 'longestCommonSubstring'], function () {
  $assert('foo', _.longestCommonSubstring('foo', 'ffooa'));
}, function () {
  var indexMap = function (list) {
    var map = {};

    _.each(list, function (each, i) {
      map[each] = map[each] || [];
      map[each].push(i);
    });

    return map;
  };

  _.longestCommonSubstring = function (a, b) {
    var where = _.indexOfLongestCommonSubstring(a, b);

    return where.length ? a.substr(where.a, where.length) : undefined;
  };

  _.indexOfLongestCommonSubstring = function (a, b) {
    var result = {
      a: 0,
      b: 0,
      length: 0
    };
    var indexMapBefore = indexMap(a);
    var previousOverlap = [];

    _.each(b, function (eachAfter, indexAfter) {
      var overlapLength;
      var overlap = [];
      var indexesBefore = indexMapBefore[eachAfter] || [];

      _.each(indexesBefore, function (indexBefore) {
        overlapLength = (indexBefore && previousOverlap[indexBefore - 1] || 0) + 1;

        if (overlapLength > result.length) {
          result.length = overlapLength;
          result.a = indexBefore - overlapLength + 1;
          result.b = indexAfter - overlapLength + 1;
        }

        overlap[indexBefore] = overlapLength;
      });

      previousOverlap = overlap;
    });

    return result;
  };
});
/*  experimental shit (subject to removal)
    ======================================================================== */


_.key = function (fn) {
  return function (value, key) {
    return fn(key);
  };
};

_.pickKeys = function (obj, predicate) {
  return _.pick(obj, function (v, k) {
    return predicate(k);
  });
};
},{"underscore":"node_modules/underscore/underscore.js","es7-object-polyfill":"node_modules/es7-object-polyfill/es7-object-polyfill.js","meta-fields":"node_modules/meta-fields/meta-fields.js"}],"node_modules/useless/base/tier0/properties.js":[function(require,module,exports) {
"use strict";

var _ = require('underscore');
/*  Properties
    ======================================================================== */


_.withTest('properties', function () {
  var obj = {};

  _.defineProperty(obj, 'fourtyTwo', 42);

  _.defineProperty(obj, 'fourtyTwo_too', function () {
    return 42;
  });

  _.defineProperty(obj, 'fourtyTwo_orDie', function (x) {
    $assert(x == 42);
    return 42;
  });

  _.defineProperty(obj, 'fourtyTwo_eitherWay', {
    configurable: true,
    get: function () {
      return 42;
    },
    set: function (x) {
      $assert(x == 42);
    }
  });

  $assert(42, obj.fourtyTwo, obj.fourtyTwo_too, obj.fourtyTwo_orDie(42), obj.fourtyTwo_eitherWay = 42);
  delete obj.fourtyTwo_eitherWay; // can be deleted if configurable:true

  $assert(obj.fourtyTwo_eitherWay === undefined);
  $assertThrows(function () {
    return delete obj.fourtyTwo;
  }); // cannot be deleted (as default behavior)

  _.defineHiddenProperty(obj, 'hiddenAndDangerous', 42); // shortut for enumerable:false


  $assert(_.keys(obj).indexOf('hiddenAndDangerous') < 0);
  $assertEveryCalledOnce(function (mkay) {
    // memoized property
    _.defineMemoizedProperty(obj, '_42', function () {
      mkay();
      return 42;
    });

    $assert(obj._42, obj._42, obj._42, 42);
  });
}, function () {
  _.extend(_, {
    defineProperty: function (targetObject, name, def, defaultCfg) {
      if (_.isObject(targetObject) && targetObject.hasOwnProperty(name)) {
        throw new Error('_.defineProperty: targetObject already has property ' + name);
      } else {
        Object.defineProperty(targetObject, name, _.extend({
          enumerable: true
        }, defaultCfg, _.coerceToPropertyDefinition(def, name)));
      }
    },
    defineHiddenProperty: function (targetObject, name, def, defaultCfg) {
      return _.defineProperty(targetObject, name, def, _.extend({
        enumerable: false
      }, defaultCfg));
    },
    defineMemoizedProperty: function (targetObject, name, def_, defaultCfg) {
      var def = _.coerceToPropertyDefinition(def_, name);

      return _.defineProperty(targetObject, name, _.extend({}, def, {
        get: _.memoizeToThis('_' + name, def.get)
      }), defaultCfg);
    },
    defineProperties: function (targetObject, properties) {
      _.each(properties, _.defineProperty.partial(targetObject).flip2);
    },
    memoizedState: function (obj) {
      return _.filter2(obj, function (v, k) {
        return k[0] === '_' && !_.isFunction(v);
      });
    },
    memoizeToThis: function (name, fn) {
      return function () {
        var memo = this[name];
        return memo !== undefined ? memo : this[name] = fn.call(this);
      };
    },
    coerceToPropertyDefinition: function (value_,
    /* optional */
    name) {
      var value = value_ || {};
      var actualValue = Meta.unwrap(value_);
      var tags = Meta.tags(value_); // property definition case (short circuit then)

      return !tags.constant && !tags.get && _.isPropertyDefinition(actualValue) && actualValue || // get-accessor-alone case
      (tags.get || !tags.constant && _.isFunction(actualValue) && _.noArgs(actualValue)) && {
        get: actualValue,
        set: _.throwsError('cannot change ' + (name || 'property') + ' (as it\'s an accessor function)')
      } || // constant value case
      !tags.get && {
        get: _.constant(actualValue),
        set: _.throwsError('cannot change ' + (name || 'property') + ' (as it\'s sealed to ' + actualValue + ')')
      } || // any other case (erroneous)
      _.throwsError('coerceToPropertyDefinition: crazy input, unable to match')();
    },
    isPropertyDefinition: function (obj) {
      return _.isObject(obj) && (_.isFunction(obj.get) || _.isFunction(obj.set));
    },
    ownProperties: function (obj) {
      return obj && _.pickKeys(obj, obj.hasOwnProperty.bind(obj)) || {};
    }
  });
});
},{"underscore":"node_modules/underscore/underscore.js"}],"node_modules/useless/base/tier0/typeMatch.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _ = require('underscore');

_.hasTypeMatch = true;
/*  Type matching for arbitrary complex structures (TODO: test)
    ======================================================================== */

Meta.globalTag('required');
Meta.globalTag('atom');
$global.const('$any', _.identity);

_.deferTest(['type', 'type matching'], function () {
  $assert(_.omitTypeMismatches({
    '*': $any,
    foo: $required('number'),
    bar: $required('number')
  }, {
    baz: 'x',
    foo: 42,
    bar: 'foo'
  }), {});
  $assert(_.omitTypeMismatches({
    foo: {
      '*': $any
    }
  }, {
    foo: {
      bar: 42,
      baz: 'qux'
    }
  }), {
    foo: {
      bar: 42,
      baz: 'qux'
    }
  });
  $assert(_.omitTypeMismatches({
    foo: {
      bar: $required(42),
      '*': $any
    }
  }, {
    foo: {
      bar: 'foo',
      baz: 'qux'
    }
  }), {});
  $assert(_.omitTypeMismatches([{
    foo: $required('number'),
    bar: 'number'
  }], [{
    foo: 42,
    bar: 42
  }, {
    foo: 24
  }, {
    bar: 42
  }]), [{
    foo: 42,
    bar: 42
  }, {
    foo: 24
  }]);
  $assert(_.omitTypeMismatches({
    '*': 'number'
  }, {
    foo: 42,
    bar: 42
  }), {
    foo: 42,
    bar: 42
  });
  $assert(_.omitTypeMismatches({
    foo: $any
  }, {
    foo: 0
  }), {
    foo: 0
  }); // there was a bug (any zero value was omitted)

  $assert(_.decideType([]), []);
  $assert(_.decideType(42), 'number');
  $assert(_.decideType(_.identity), 'function');
  $assert(_.decideType([{
    foo: 1
  }, {
    foo: 2
  }]), [{
    foo: 'number'
  }]);
  $assert(_.decideType([{
    foo: 1
  }, {
    bar: 2
  }]), []);
  $assert(_.decideType(_defineProperty({
    foo: {
      bar: 1
    }
  }, "foo", {
    baz: []
  })), _defineProperty({
    foo: {
      bar: 'number'
    }
  }, "foo", {
    baz: []
  }));
  $assert(_.decideType(_defineProperty({
    foo: {
      bar: 1
    }
  }, "foo", {
    bar: 2
  })), {
    foo: {
      bar: 'number'
    }
  });
  $assert(_.decideType({
    foo: {
      bar: 1
    },
    bar: {
      bar: 2
    }
  }), {
    '*': {
      bar: 'number'
    }
  });

  if (_.hasOOP) {
    var Type = $prototype();
    $assert(_.decideType({
      x: new Type()
    }), {
      x: Type
    });
  }
}, function () {
  _.isMeta = function (x) {
    return x === $any || $atom.is(x) || $required.is(x);
  };

  var zip = function (type, value, pred) {
    var required = Meta.unwrapAll(_.filter2(type, $required.is));

    var match = _.nonempty(_.zip2(Meta.unwrapAll(type), value, pred));

    if (_.isEmpty(required)) {
      return match;
    } else {
      var requiredMatch = _.nonempty(_.zip2(required, value, pred));

      var allSatisfied = _.values2(required).length === _.values2(requiredMatch).length;

      return allSatisfied ? match : _.coerceToEmpty(value);
    }
  };

  var hyperMatch = _.hyperOperator(_.binary, function (type_, value, pred) {
    var type = Meta.unwrap(type_);

    if (_.isArray(type)) {
      // matches [ItemType]  [item, item, ..., N]
      if (_.isArray(value)) {
        return zip(_.times(value.length, _.constant(type[0])), value, pred);
      } else {
        return undefined;
      }
    } else if (_.isStrictlyObject(type) && type['*']) {
      // matches { *: .. }  { a: .., b: .., c: .. }
      if (_.isStrictlyObject(value)) {
        return zip(_.extend(_.map2(value, _.constant(type['*'])), _.omit(type, '*')), value, pred);
      } else {
        return undefined;
      }
    } else {
      return zip(type_, value, pred);
    }
  });

  var typeMatchesValue = function (c, v) {
    var contract = Meta.unwrap(c);
    return contract === $any || contract === undefined && v === undefined || _.isFunction(contract) && (_.isPrototypeConstructor(contract) ? _.isTypeOf(contract, v) : // constructor type
    contract(v) === true) || // test predicate
    _typeof(v) === contract || // plain JS type
    v === contract;
  }; // constant match


  _.mismatches = function (op, contract, value) {
    return hyperMatch(contract, value, function (contract, v) {
      return op(contract, v) ? undefined : contract;
    });
  };

  _.omitMismatches = function (op, contract, value) {
    return hyperMatch(contract, value, function (contract, v) {
      return op(contract, v) ? v : undefined;
    });
  };

  _.typeMismatches = _.partial(_.mismatches, typeMatchesValue);
  _.omitTypeMismatches = _.partial(_.omitMismatches, typeMatchesValue);
  _.valueMismatches = _.partial(_.mismatches, function (a, b) {
    return a === $any || b === $any || a === b;
  });

  var unifyType = function (value) {
    if (_.isArray(value)) {
      return _.nonempty([_.reduce(value.slice(1), function (a, b) {
        return _.undiff(a, b);
      }, _.first(value) || undefined)]);
    } else if (_.isStrictlyObject(value)) {
      var pairs = _.pairs(value);

      var unite = _.map(_.reduce(pairs.slice(1), function (a, b) {
        return _.undiff(a, b);
      }, _.first(pairs) || [undefined, undefined]), _.nonempty);

      return _.isEmpty(unite) || _.isEmpty(unite[1]) ? value : _.fromPairs([[unite[0] || '*', unite[1]]]);
    } else {
      return value;
    }
  };

  _.decideType = function (value) {
    var operator = _.hyperOperator(_.unary, function (value, pred) {
      if (value && value.constructor && value.constructor.$definition) {
        return value.constructor;
      }

      return unifyType(_.map2(value, pred));
    });

    return operator(value, function (value) {
      if (_.isPrototypeInstance(value)) {
        return value.constructor;
      } else {
        return _.isEmptyArray(value) ? value : _typeof(value);
      }
    });
  };
}); // TODO: fix hyperOperator to remove additional check for []
},{"underscore":"node_modules/underscore/underscore.js"}],"node_modules/useless/base/CPS.js":[function(require,module,exports) {
"use strict";

var _ = require('underscore');
/*  CPS primitives module
    ======================================================================== */


_.cps = function () {
  return _.cps.sequence.apply(null, arguments);
};
/*  apply
    ======================================================================== */


_.withTest(['cps', 'apply'], function () {// TODO
}, function () {
  _.cps.apply = function (fn, this_, args_, then) {
    var args = _.asArray(args_);

    var lastArgN = _.numArgs(fn) - 1;
    var thenArg = args[lastArgN];

    args[lastArgN] = function () {
      then.call(this, arguments, thenArg);
    };

    return fn.apply(this_, args);
  };
});
/*  each
    ======================================================================== */


_.withTest(['cps', 'each'], function () {
  /*  Example array
   */
  var data = ['foo', 'bar', 'baz'];
  var currentIndex = 0;

  _.cps.each(data,
  /*  called for each item, in linear order
   */
  function (item, itemIndex, then, complete, arrayWeTraverse) {
    $assert(item === data[itemIndex]);
    $assert(itemIndex === currentIndex++);
    $assert(arrayWeTraverse === data);
    $assert(_.isFunction(then));
    $assert(_.isFunction(complete));
    then();
  },
  /*  called when all items enumerated
   */
  function () {
    $assert(currentIndex === data.length);
  });
  /*  You can omit 'index' argument for iterator function
   */


  var data2 = [];

  _.cps.each(data, function (item, then) {
    data2.push(item);
    then();
  }, function () {
    $assert(data, data2);
  });
  /*  You can stop iteration by calling fourth argument
   */


  var data3 = [];

  _.cps.each(data, function (item, i, then, break_) {
    data3.push(item);
    break_();
  }, function () {
    $assert(data3, ['foo']);
  });
  /*  Iterating over dictionary is legal
   */


  $assertEveryCalled(function (items__3, final__1) {
    var data2 = {
      'foo': 1,
      'bar': 2,
      'baz': 3
    };

    _.cps.each(data2, function (item, name, then) {
      $assert(item === data2[name]);
      items__3();
      then();
    }, function () {
      final__1();
    });
  });
  /*  Iterating over scalar is legal
   */

  $assertEveryCalled(function (items__1, final__1) {
    _.cps.each('foo', function (item, name, then) {
      $assert([item, name], ['foo', undefined]);
      items__1();
      then();
    }, function () {
      final__1();
    });
  });
  /*  Undefined/null are treated as empty (not scalars)
   */

  $assertEveryCalled(function (final__1) {
    _.cps.each(undefined, function () {
      $fail;
    }, function () {
      final__1();
    });
  });
}, function () {
  _.extend(_.cps, {
    each: function each(obj, elem_) {
      var _this = this;

      var complete_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _.noop;
      var index_ = arguments.length > 3 ? arguments[3] : undefined;
      var length_ = arguments.length > 4 ? arguments[4] : undefined;
      var keys_ = arguments.length > 5 ? arguments[5] : undefined;
      var completed = false;

      var complete = function () {
        return !completed && (completed = true, complete_.apply(void 0, arguments));
      };

      var elem = function (x, k, next) {
        if (_.numArgs(elem_) === 2) {
          elem_(x, next, complete, obj);
        } else {
          elem_(x, k, next, complete, obj);
        }
      };

      if (_.isEmpty(obj)) {
        complete();
      } else if (_.isScalar(obj)) {
        elem(obj, undefined, complete);
      } else {
        var index = index_ || 0;
        var keys = index === 0 ? obj.length === undefined ? _.keys(obj) : undefined : keys_;
        var length = index === 0 ? keys ? keys.length : obj.length : length_;

        if (index >= (length || 0)) {
          complete();
        } else {
          var key = keys ? keys[index] : index;
          elem(obj[key], key, function () {
            return !completed && each.call(_this, obj, elem_, complete_, index + 1, length, keys);
          });
        }
      }
    }
  });
});
/*  map
    ======================================================================== */


_.withTest(['cps', 'map'], function () {
  /*  2-argument iterator semantics
   */
  _.cps.map([7, 6, 5], function (x, then) {
    then(x + 1);
  }, function (result) {
    $assert(result, [8, 7, 6]);
  });
  /*  3-argument iterator semantics
   */


  _.cps.map([7, 6, 5], function (x, i, then) {
    then(x + 1);
  }, function (result) {
    $assert(result, [8, 7, 6]);
  });
}, function () {
  _.extend(_.cps, {
    map: function (obj, iter, complete) {
      var result = _.isArray(obj) ? [] : {};

      _.cps.each(obj, _.numArgs(iter) == 2 ? function (x, i, next) {
        iter(x, function (y) {
          result[i] = y;
          next();
        });
      } : function (x, i, next) {
        iter(x, i, function (y) {
          result[i] = y;
          next();
        });
      }, function () {
        complete(result);
      });
    }
  });
});
/*  find
    ======================================================================== */


_.withTest(['cps', 'find'], function () {
  /*  Basic use
   */
  _.cps.find([7, 6, 5], function (x, then) {
    then(x % 3 === 0);
  }, function (x, key) {
    $assert([x, key], [6, 1]);
  });
  /*  Over dictionary
   */


  _.cps.find({
    foo: 7,
    bar: 6,
    baz: 5
  }, function (x, key, then) {
    then(key === 'baz');
  }, function (x, key) {
    $assert([x, key], [5, 'baz']);
  });
  /*  Returning non-boolean
   */


  _.cps.find([7, 6, 5], function (x, then) {
    then(x % 3 === 0 ? 'yeah' : false);
  }, function (x, key) {
    $assert([x, key], ['yeah', 1]);
  });
  /*  Not found
   */


  _.cps.find([7, 6, 5], function (x, key, then) {
    then(false);
  }, function (x) {
    $assert(x, undefined);
  });
}, function () {
  _.extend(_.cps, {
    find: function (obj, pred, complete) {
      var passKey = _.numArgs(pred) !== 2;

      _.cps.each(obj, function (x, key, next, complete) {
        var take = function (match) {
          if (match === false) {
            next();
          } else {
            complete(match === true ? x : match, key);
          }
        };

        if (passKey) {
          pred(x, key, take);
        } else {
          pred(x, take);
        }
      }, complete);
    }
  });
});
/*  memoize
    ======================================================================== */


_.withTest(['cps', 'memoize'], function () {
  $assertEveryCalledOnce(function (noMoreThanOne) {
    var plusOne = _.cps.memoize(function (x, then) {
      noMoreThanOne();
      then(x + 1);
    });

    plusOne(2, function (x) {
      $assert(x === 3);
    });
    plusOne(2, function (x) {
      $assert(x === 3);
    });
  });
}, function () {
  _.extend(_.cps, {
    memoize: function (fn) {
      return _.barrier ? _.cps._betterMemoize(fn) : _.cps._poorMemoize(fn);
    },

    /*  This simplified version is used to bootstrap Useless.js code base (where _.barrier not available)
     */
    _poorMemoize: function (fn) {
      var cache = {};
      return function (value, then) {
        if (value in cache) {
          //  there's a flaw: cache updates after fetch completes, so while fetch is running,
          then(cache[value]);
        } //  any subsequent call (until cache is ready) will trigger fetch (as it doesnt know that result is already fetching)
        else {
            fn.call(this, value, function (result) {
              then(cache[value] = result);
            });
          }
      };
    },

    /*  UPD: added support for 0-arity semantics
     */
    _betterMemoize: function (fn) {
      var cache = {}; // barrier-enabled impl, eliminates redundant fetches
      // in this version, any subsequent calls join at barrier (which opens when result is fetched)

      switch (_.numArgs(fn)) {
        case 1:
          return function (then) {
            if (!cache.already) {
              fn.call(this, cache = _.barrier());
            }

            cache(then);
          };

        case 2:
          cache = {};
          return function (value, then) {
            if (!(value in cache)) {
              fn.call(this, value, cache[value] = _.barrier());
            }

            cache[value](then);
          };

        default:
          throw new Error('_.cps.memoize: unsupported number of arguments');
      }
    }
  });
});
/*  reduce
    ======================================================================== */


_.withTest(['cps', 'reduce'], function () {
  $assertEveryCalled(function (mkay__2) {
    var input = [1, 2, 3];

    var sums = function (a, b, then) {
      then(a + b);
    };

    var check = function (result) {
      $assert(result === 6);
      mkay__2();
    };

    _.cps.reduce(input, sums, check);

    _.cps.reduce([], sums, check, 6);
  });
}, function () {
  var reduce = function (array, op, then, memo, index) {
    // internal impl
    if (!array || index >= (array.length || 0)) {
      then(memo);
    } else {
      op(memo, array[index], function (result) {
        reduce(array, op, then, result, index + 1);
      });
    }
  };

  _.cps.reduce = function (array, op, then, memo) {
    // public API
    if (arguments.length < 4) {
      reduce(array, op, then, array[0], 1);
    } else {
      reduce(array, op, then, memo, 0);
    }
  };
});
/*  noop / identity / constant
    ======================================================================== */


_.withTest(['cps', 'noop, identity, constant'], function () {
  $assertEveryCalled(function (noop, identity, const1, const2) {
    /*  Port of underscore's _.noop to CPS terms
     */
    _.cps.noop(1, 2, 3, function () {
      $assert(arguments.length === 0);
      noop();
    });
    /*  Port of underscore's _.identity to CPS terms
     */


    _.cps.identity(1, 2, 3, function () {
      $assert([1, 2, 3], _.asArray(arguments));
      identity();
    });
    /*  Port of underscore's _.constant to CPS terms
     */


    _.cps.constant(3)(function (_3) {
      $assert(_3 === 3);
      const1();
    });

    _.cps.constant(1, 2)(function (_1, _2) {
      $assert(_1 === 1);
      $assert(_2 === 2);
      const2();
    });
  });
}, function () {
  _.extend(_.cps, {
    noop: $restArg(function () {
      return _.last(arguments).call(this);
    }),
    identity: $restArg(function () {
      var args = _.initial(arguments),
          then = _.last(arguments);

      if (then) {
        return then.apply(this, args);
      }
    }),
    constant: $restArg(function () {
      var args = arguments;
      return function () {
        return _.last(arguments).apply(this, args);
      };
    })
  });
});
/*  arity
    ======================================================================== */


_.deferTest(['cps', 'arity / resultArity'], function () {
  var returnMyArgs = _.cps.identity;

  var put123 = function (fn) {
    return _.partial(fn, 1, 2, 3);
  };

  $assertCPS(put123(returnMyArgs), [1, 2, 3]);
  $assertCPS(put123(_.cps.arity2(returnMyArgs)), [1, 2]);
  $assertCPS(put123(_.cps.arity1(returnMyArgs)), [1]);
  $assertCPS(put123(_.cps.arity0(returnMyArgs)));

  var return123 = function (then) {
    then(1, 2, 3);
  };

  $assertCPS(return123, [1, 2, 3]);
  $assertCPS(_.cps.resultArity2(return123), [1, 2]);
  $assertCPS(_.cps.resultArity1(return123), [1]);
  $assertCPS(_.cps.resultArity0(return123));
}, function () {
  _.cps.arity0 = function (fn) {
    return function () {
      fn.call(this, _.last(arguments));
    };
  };

  _.cps.arity1 = function (fn) {
    return function () {
      fn.call(this, arguments[0], _.last(arguments));
    };
  };

  _.cps.arity2 = function (fn) {
    return function () {
      fn.call(this, arguments[0], arguments[1], _.last(arguments));
    };
  };

  _.cps.transformResult = function (operator, fn) {
    return function (args) {
      fn.apply(this, _.initial(arguments).concat(operator(_.last(arguments))));
    };
  };

  _.cps.resultArity2 = _.partial(_.cps.transformResult, _.arity2);
  _.cps.resultArity1 = _.partial(_.cps.transformResult, _.arity1);
  _.cps.resultArity0 = _.partial(_.cps.transformResult, _.arity0);
});
/*  sequence / compose
    ======================================================================== */


_.withTest(['cps', 'sequence / compose'], function () {
  $assertEveryCalled(function (mkay__4) {
    /*  Basic example of asynchronous functions sequencing
     */
    var makeCookies = function (whatCookies, then) {
      then('cookies ' + whatCookies);
    };

    var eatCookies = function (cookies, then) {
      then('nice ' + cookies);
    };

    var check = function (result) {
      $assert(result, 'nice cookies from shit');
      mkay__4();
    };

    _.cps.sequence(makeCookies, eatCookies, check)('from shit'); // supports both ways (either argument list...


    _.cps.sequence([makeCookies, eatCookies, check])('from shit'); // ..or array


    _.cps(makeCookies, eatCookies, check)('from shit'); // shorthand macro

    /*  A port of underscore's _.compose (simply flipped _.sequence)
     */


    _.cps.compose(check, eatCookies, makeCookies)('from shit');
  });
}, function () {
  _.cps.sequence = $restArg(function (arr) {
    var functions = _.isArray(arr) && arr || _.asArray(arguments);

    return _.reduceRight(functions, function (a, b) {
      return function () {
        return b.apply(this, _.asArray(arguments).concat(a));
      };
    }, _.cps.identity);
  });
  _.cps.compose = $restArg(function (arr) {
    var functions = _.isArray(arr) && arr || _.asArray(arguments);

    return _.cps.sequence(functions.slice().reverse());
  });
});
/*  _.cps.sequence with error handling (kind of a simplified Promise)
    ======================================================================== */


_.deferTest(['cps', 'trySequence'], function () {
  var testErr = new Error();
  /*  No error
   */

  $assertEveryCalledOnce(function (mkay) {
    _.cps.trySequence([_.cps.constant('foo'), _.appends('bar').asContinuation], function (result) {
      $assert(result, 'foobar');
      mkay();
    });
  });
  /*  Throwing error
   */

  $assertEveryCalledOnce(function (mkay) {
    _.cps.trySequence([function () {
      throw testErr;
    }, function () {
      $fail;
    }], function (result) {
      $assert(result === testErr);
      mkay();
    });
  });
  /*  Returning error to continuation
   */

  $assertEveryCalledOnce(function (mkay) {
    _.cps.trySequence([function (then) {
      then(testErr);
    }, function () {
      $fail;
    }], function (result) {
      $assert(result === testErr);
      mkay();
    });
  });
  /*  Reading error in separate callback
   */

  $assertEveryCalledOnce(function (mkay) {
    _.cps.trySequence([function (then) {
      then(testErr);
    }, function () {
      $fail;
    }], function (result) {
      $fail;
    }, function (err) {
      $assert(err === testErr);
      mkay();
    });
  });
}, function () {
  _.cps.trySequence = function (functions, then, err) {
    _.reduceRight(functions, function (a, b) {
      return function (e) {
        if (_.isTypeOf(Error, e)) {
          return (err || then)(e);
        } else {
          try {
            return b.apply(this, _.asArray(arguments).concat(a));
          } catch (e) {
            return (err || then)(e);
          }
        }
      };
    }, then)();
  };
});
},{"underscore":"node_modules/underscore/underscore.js"}],"node_modules/useless/base/infix/extensionMethods.js":[function(require,module,exports) {
"use strict";

var _ = require('underscore')
/*  Extensions methods
    ======================================================================== */
;

['method', 'property', 'flipped', 'forceOverride'].forEach(Meta.globalTag);

$global.$extensionMethods = function (Type, methods) {
  _.each(methods, function (x, name) {
    var fn = Meta.unwrap(x);
    var tags = Meta.tags(x);
    /*  define as _.method (this, ...)
     */

    if (!(name in _)) {
      _[name] = _[name] || fn;
    }
    /*  define as property of Type
     */


    if (!tags.method && (tags.property || _.oneArg(fn))) {
      if (!(name in Type.prototype) || tags.forceOverride) {
        _.defineHiddenProperty(Type.prototype, name, function () {
          return fn(this);
        });
      }
    }
    /*  define as method
     */
    else if (!tags.property) {
        if (!(name in Type.prototype) || tags.forceOverride) {
          Object.defineProperty(Type.prototype, name, {
            writable: true,
            value: _.asMethod(tags.flipped ? _.flip(fn) : fn)
          });
        }
      } else {
        throw new Error('$extensionMethods: crazy input, unable to match');
      }
  });
};
},{"underscore":"node_modules/underscore/underscore.js"}],"node_modules/useless/base/infix/Function.js":[function(require,module,exports) {
"use strict";

var _ = require('underscore');
/*  Function extensions
    ======================================================================== */


_.tests.Function = {
  '$ for partial application': function () {
    var sum = function (a, b) {
      return a + b;
    };

    $assert(sum.$('foo')('bar'), 'foobar'); // bind to head of argument list

    $assert(sum.$$('foo')('bar'), 'barfoo');
  },
  // bind to tail of argument list
  'Fn.callsWith': function () {
    $assert(42, function (a, b, c) {
      $assert([a, b, c], [1, 2, 3]);
      return 42;
    }.callsWith(1, 2)(3));
  },

  /*  Converts regular function (which returns result) to CPS function (which passes result to 'then')
   */
  'asContinuation': function () {
    $assertEveryCalled(function (mkay__2) {
      var twoPlusTwo = function () {
        return 2 + 2;
      };

      var shouldBeFour = function (result) {
        $assert(result == 4);
        mkay__2();
      };

      twoPlusTwo.asContinuation(shouldBeFour);

      _.asContinuation(twoPlusTwo)(shouldBeFour);
    });
  },

  /*  Postpones execution
   */
  'postpone': function (testDone) {
    $assertEveryCalledOnce($async(function (mkay1, mkay2) {
      var testSecondCall = false;

      var callMeLater = function () {
        if (testSecondCall) {
          mkay2();
          testDone();
        } else {
          mkay1();
          testSecondCall = true;
          callMeLater.postpone();
        }
      }; // should be postponed again


      callMeLater.postpone();
      callMeLater.postpone();
    }));
  },
  // should not trigger double call
  'postponed': function (testDone) {
    $assertEveryCalledOnce($async(function (mkay) {
      (function (_42) {
        $assert(this, 'foo');
        $assert(42, _42);
        mkay();
      }).postponed.call('foo', 42);
    }), testDone);
  },
  'postponed args': function (done) {
    var xs = [];

    var f = function (x) {
      xs.push(x);
    };

    f.postponed(42);
    f.postponed(43);

    _.delay(function () {
      $assert(xs, [43]);
      done();
    }, 1);
  },

  /*  Returns function that executed after _.delay
   */
  'delayed': function (testDone) {
    var eat42 = function (_42, then) {
      $assert(_42, 42);
      then();
    };

    var eat42_after5ms = eat42.delayed(5);
    $assertEveryCalledOnce($async(function (mkay) {
      eat42_after5ms(42, function () {
        mkay();
      });
    }), testDone);
  }
};
/*  Impl.
 */

$extensionMethods(Function, {
  $: $method(_.partial),
  // binding to head of argument list
  $$: $method(_.tails),
  // binding to tail of argument list
  bind: _.bind,
  partial: _.partial,
  calls: _.bind,
  tails: _.tails,
  tails2: _.tails2,
  tails3: _.tails3,
  applies: _.applies,
  compose: _.compose,
  then: _.then,
  with: _.flipN,
  flip2: _.flip2,
  flip3: _.flip3,
  asFreeFunction: _.asFreeFunction,
  asMethod: _.asMethod,
  callsWith: _.callsTo,
  tailsWith: _.tailsTo,
  higherOrder: _.higherOrder,
  returns: function (fn, returns) {
    return function () {
      fn.apply(this, arguments);
      return returns;
    };
  },
  asContinuation: function (f) {
    return $restArg(function () {
      _.last(arguments)(f.apply(this, _.initial(arguments)));
    });
  },
  wraps: function (f, w) {
    f._wrapped = _.withSameArgs(f, w);
    return f;
  },
  wrapped: function (f) {
    return f._wrapped || f;
  },
  arity0: _.arity0,
  arity1: _.arity1,
  arity2: _.arity2,
  arity3: _.arity3,
  or: _.or,
  and: _.and,
  //not:    _.not,
  new: _.higherOrder(_.new),
  each: function (fn, obj) {
    return _.each2(obj, fn);
  },
  map: function (fn, obj) {
    return _.map2(obj, fn);
  },
  oneShot: function (fn) {
    var called = false;
    return function () {
      if (!called) {
        called = true;
        return fn.apply(this, arguments);
      }
    };
  },
  memoized: _.memoize,
  throttled: _.throttle,
  debounced: function (func, wait, immediate) {
    var timestamp, timeout, result, args, context;

    var later = function () {
      var last = Date.now() - timestamp;

      if (last < wait && last > 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;

        if (!immediate) {
          result = func.apply(context, args);

          if (!timeout) {
            context = args = null;
          }
        }
      }
    };

    var debouncedFn = function () {
      context = this;
      args = arguments;
      timestamp = Date.now();
      var callNow = immediate && !timeout;

      if (!timeout) {
        timeout = setTimeout(later, wait);
      }

      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };

    debouncedFn.cancel = function () {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
    };

    debouncedFn.callImmediately = function () {
      // cancels timeout (set by fn.debounced/fn.throttled) and calls immediately
      debouncedFn.cancel();
      func.apply(context, args);
    };

    return debouncedFn;
  },
  postpone: $method(function (fn) {
    fn.postponed.apply(null, arguments);
  }),
  postponed: function (fn) {
    return function () {
      var shouldPostpone = !fn._postponed;
      fn._postponed = _.asArray(arguments);
      fn._postponedThis = this;

      if (shouldPostpone) {
        _.delay(function () {
          var args_ = fn._postponed;
          var this_ = fn._postponedThis;
          fn._postponed = undefined;
          fn._postponedThis = undefined;
          fn.apply(this_, args_);
        });
      }
    };
  },
  delay: _.delay,
  delayed: function (fn, time) {
    return function () {
      var args = arguments,
          context = this;

      _.delay(function () {
        fn.apply(context, args);
      }, time);
    };
  }
});
/*  A functional try/catch
    ======================================================================== */

_.tests.Function.catches = function () {
  $assert('yo', _.constant('yo').catches($fails)(), _.identity.catches($fails)('yo'), _.throwsError('xx').catches('yo')());
  $assertThrows(function () {
    _.constant('yo').catches(function () {
      $assert('catch handler shoudnt work on passed continuations');
    }, _.throwsError('xx'))();
  });
  $assert(function (x) {
    throw x;
  }.catches(_.appends('+error_case'), _.appends('+no_error_case'), _.appends('+finally'))('foo'), 'foo+error_case+finally');
  $assertMatches(_.throwError.catches()('yo'), {
    message: 'yo'
  });
  $assert(_.catches(_.throwsError(42), $assertMatches.$({
    message: 42
  }).returns('yo'))(), 'yo');
  $assertCPS(_.constant('yo').catches($fails), 'yo');
};

$extensionMethods(Function, {
  catch_: function (fn, catch_, then, finally_) {
    return fn.catches(catch_, then)();
  },
  catches: function (fn, catch_, then, finally_) {
    var args = arguments.length;
    catch_ = args > 1 ? _.coerceToFunction(catch_) : _.identity;
    then = args > 2 ? _.coerceToFunction(then) : _.identity;
    finally_ = args > 3 ? _.coerceToFunction(finally_) : _.identity;
    return function () {
      var result = undefined,
          catched = false;

      try {
        result = fn.apply(this, arguments);
      } catch (e) {
        result = catch_(e);
        catched = true;
      }

      if (!catched) {
        result = then(result);
      }

      return finally_(result);
    };
  }
});
},{"underscore":"node_modules/underscore/underscore.js"}],"node_modules/useless/base/infix/Array.js":[function(require,module,exports) {
"use strict";

var _ = require('underscore');
/*  Array extensions
    ======================================================================== */


_.withTest('Array extensions', function () {
  var arr = [1, 3, 2, 3, 3, 4, 3];
  $assert([arr.first, arr.second, arr.top, arr.last], [1, 3, 3, 3]);
  $assert(arr.rest, [3, 2, 3, 3, 4, 3]);
  $assert(arr.take(4), [1, 3, 2, 3]);
  $assert([arr.contains(4), arr.contains(9)], [true, false]);
  $assert(arr.lastIndex, 6);
  $assert(arr.copy, arr);
  $assert(arr.copy !== arr);
  $assert(arr.remove(3), [1, 2, 4]); // it is fast

  $assert(arr, [1, 2, 4]); // and mutates original (thats why fast)
  // for immutable version, use underscore's _.without

  $assert(arr.removeAll(), []);
  $assert(arr, []);
  $assert(['a', 'b', 'c'].removeAt(1), ['a', 'c']); // NOTE: mutates original

  $assert(['a', 'c'].insertAt('b', 1), ['a', 'b', 'c']); // NOTE: mutates original

  $assert([0, 1, 2].itemAtWrappedIndex(4) === 1);
  $assert([0, 1, 2].itemAtWrappedIndex(-1) === 2);
  $assert([0, 1, 2].itemAtWrappedIndex(-5) === 1);
  arr = [1, 2, 3];
  $assert(arr.reversed, [3, 2, 1]);
  $assert(arr, [1, 2, 3]); // does not mutate original (in contrary to .reverse)

  $assert([[1], [[2], 3], 4].flat, [1, [2], 3, 4]);
  $assert([[1, 2, 3], [4, 5, 6]].zip(_.sum), [5, 7, 9]);
  $assert(['a', 'b', 'c'].swap(1, 2), ['a', 'c', 'b']); // NOTE: mutates original

  $assert([1].random === 1); // returns random item from array

  $assert([].random === undefined);
  $assert([{
    foo: 'bar'
  }, {
    foo: 'qux'
  }].pluck('foo'), ['bar', 'qux']);
}, function () {
  /*  TODO: rewrite using new $mixin facility
   */
  $extensionMethods(Array, {
    each: _.each,
    map: _.map,
    fold: _.reduce2,
    reduce: _.reduce,
    reduceRight: _.reduceRight,
    zip: _.zipWith,
    groupBy: _.groupBy,
    indexBy: _.indexBy,
    find: _.find,
    findWhere: $method(_.findWhere),
    filter: _.filter,
    reject: $method(_.reject),
    flat: _.flatten.tails2(true),
    object: _.fromPairs,
    shuffle: _.shuffle,
    unique: _.unique.arity1,
    nonempty: _.nonempty,
    pluck: $method(_.pluck),
    without: $method(_.without),
    contains: function (arr, item) {
      return arr.indexOf(item) >= 0;
    },
    top: function (arr) {
      return arr[arr.length - 1];
    },
    first: function (arr) {
      return arr[0];
    },
    second: function (arr) {
      return arr[1];
    },
    rest: function (arr) {
      return arr.slice(1);
    },
    last: function (arr) {
      return arr[arr.length - 1];
    },

    /*  TODO: refactor
     */
    take: function (arr, n) {
      return arr.slice(0, n);
    },
    takeAt: $method(function (arr, n) {
      var i = typeof n == 'number' ? n : arr.findIndex(n);
      return i !== -1 ? arr.splice(i, 1).first : undefined;
    }),
    lastN: $method(_.last),
    before: function (arr, x) {
      var i = arr.indexOf(x);
      return i < 0 ? arr : arr.slice(0, i - 1);
    },
    after: function (arr, x) {
      var i = arr.indexOf(x);
      return i < 0 ? arr : arr.slice(i + 1);
    },
    isEmpty: function (arr) {
      return arr.length === 0;
    },
    notEmpty: function (arr) {
      return arr.length > 0;
    },
    lastIndex: function (arr) {
      return arr.length - 1;
    },
    random: function (arr) {
      return arr[_.random(0, arr.lastIndex)];
    },
    copy: function (arr) {
      return arr.slice(0);
    },
    removeAll: $method(function (arr) {
      return arr.splice(0, arr.length), arr;
    }),
    remove: function (arr, item) {
      var i;

      while ((i = arr.indexOf(item)) !== -1) {
        arr.splice(i, 1);
      }

      return arr;
    },
    removeAt: function (arr, index) {
      arr.splice(index, 1);
      return arr;
    },
    insertAt: function (arr, item, index) {
      arr.splice(index, 0, item);
      return arr;
    },
    itemAtWrappedIndex: function (arr, i) {
      return arr[i < 0 ? arr.length - -i % arr.length : i % arr.length];
    },
    reversed: function (arr) {
      return arr.slice().reverse();
    },
    swap: $method(function (arr, indexA, indexB) {
      var a = arr[indexA],
          b = arr[indexB];
      arr[indexA] = b;
      arr[indexB] = a;
      return arr;
    })
  });
});
},{"underscore":"node_modules/underscore/underscore.js"}],"node_modules/useless/base/infix/String.js":[function(require,module,exports) {
"use strict";

var _ = require('underscore');

var {
  ansiEscapeCodes: ansiEscapeCodes,
  printableCharacters: printableCharacters,
  nonPrintableCharacters: nonPrintableCharacters
} = require('printable-characters');
/*  String extensions
    ======================================================================== */


_.deferTest('String extensions', function () {
  /*  Convenient infix versions of string-crunching basics. The
      naming scheme of reversed/capitalized/trimmed is chosen to
      not cause conflicts with built-in methods/properties doing
      the same (which are implementation-dependent, e.g. str.trim
      method).
   */
  $assert(''.repeats(0) === '');
  $assert(''.repeats(4) === '');
  $assert(''.first(2) === '');
  $assert(''.reversed === '');
  $assert(''.capitalized === ''); // capital Zhopa

  $assert('    '.trimmed === '');
  $assert('<>'.escaped === '&lt;&gt;');
  $assert(''.prepend(''), ''.append(''), '');
  $assert([''.contains(''), ''.contains('')], [true, false]);
  $assert([''.startsWith(''), ''.startsWith(''), ''.startsWith('')], [true, true, false]);
  $assert([''.endsWith(''), ''.endsWith(''), ''.endsWith('')], [true, true, false]);
  /*  Higher order version of former utility
   */

  $assert([_.map([1, 2, 3], _.prepends('foo')), // higher order version
  _.map([1, 2, 3], _.appends('bar'))].zip(_.append), ['foo11bar', 'foo22bar', 'foo33bar']);
  /*  This one is defined via unicode_regexp_hack and is super slow
   */

  $assert('}|{/7A  Py4K() ololo 321321'.latinAlphanumericValue, '7APy4Kololo321321');
  $assert('}|{/7A  Py4K() ololo 321321'.alphanumericValue, '7APy4Kololo321321');
  /*  This one is defined though regexps, and is kinda slow. Don't use
      in performance-critical code (like mass object rendering in UI)
   */

  $assert('+7(965)412-63-21'.numericValue, '79654126321');
  $assert('+7(965)412-63-21'.integerValue, 79654126321);
  $assert('foo'.integerValue, undefined); // NOTE: returns undefined instead of NaN (for consistency reasons)

  $assert('0'.integerValue, 0); // regression test (was resulting to undefined due to bug)

  /*  Use str.parsedInt instead of raw parseInt(), because latter requires
      base-10 argument, often mistakengly omited, thus resulting something
      like '010' to be parsed as octal number. I once spend hours of debugging
      to catch this kind of mistake, and now not want for someone's got
      trapped into the same shitty situation.
   */

  $assert('123'.parsedInt, 123);
  $assert('foo'.parsedInt, undefined); // NOTE: returns undefined instead of NaN (for consistency reasons)

  $assert('0'.parsedInt, 0); // regression test (was resulting to undefined due to bug)

  /*  This one is taken from Java's object hasher. Not to ever be used in
      some security-critical calculations, as it's not secure. It's fast.
   */

  $assert('foo'.hash, 101574);
  /*  Use for filename/URL-part generation
   */

  $assert(' '.transliterate, 'pisyakamushkin');
  /*  This one is really convetient!
   */

  $assert('qux'.quote(''), 'qux');
  $assert('qux'.quote('"'), '"qux"');
  $assert('qux'.quote('[]'), '[qux]');
  $assert('qux'.quote('/'), '/qux/');
  $assert('qux'.quote('{  }'), '{ qux }');
  $assert('qux'.quote('</>'), '</qux>');
  $assert(_.isTypeOf(Uint8Array, 'foo'.bytes));
  $assert(_.asArray('foo'.bytes), [102, 111, 111]);
  $assert(['foobar'.limitedTo(6), 'tooloong'.limitedTo(6), ''.limitedTo(0)], ['foobar', 'toolo', '']);
  $assert(''.pad(5), '  ');
  $assert(''.pad(5, ''), '');
  $assert('foo'.pluck([{
    foo: 10
  }, {
    foo: 11
  }]), [10, 11]);
  $assert('foo'.pluck({
    a: {
      foo: 10
    },
    b: {
      foo: 11
    }
  }), {
    a: 10,
    b: 11
  });
  $assert('foo/'.concatPath('/bar'), 'foo'.concatPath('/bar'), 'foo/'.concatPath('bar'), 'foo'.concatPath('bar'), 'foo/bar');
  $assert('/'.concatPath('/bar'), '/bar');
  $assert('/'.concatPath('bar'), '/bar');
  $assert('123456'.first(2), '12');
  $assert('123456'.last(2), '56');
}, function () {
  $extensionMethods(String, {
    quote: _.quote,
    concatPath: function (a, b) {
      var a_endsWithSlash = a[a.length - 1] === '/';
      var b_startsWithSlash = b[0] === '/';
      return a + (a_endsWithSlash || b_startsWithSlash ? '' : '/') + (a_endsWithSlash && b_startsWithSlash ? b.substring(1) : b);
    },
    pluck: function (s, arr) {
      return _.pluck2(arr, s);
    },
    contains: function (s, other) {
      return s.indexOf(other) >= 0;
    },
    startsWith: function (s, x) {
      return x.length === 1 ? s[0] === x : s.substring(0, x.length) === x;
    },
    endsWith: function (s, x) {
      return x.length === 1 ? s[s.length - 1] === x : s.substring(s.length - x.length) === x;
    },
    pad: function (s, len, filler) {
      return s += (filler || ' ').repeats(Math.max(0, len - s.length));
    },
    cut: function (s, from) {
      return s.substring(0, from - 1) + s.substring(from, s.length);
    },
    insert: function (s, position, what) {
      return s.substring(0, position) + what + s.substring(position, s.length);
    },
    lowercase: function (s) {
      return s.toLowerCase();
    },
    uppercase: function (s) {
      return s.toUpperCase();
    },
    trimmed: function (s) {
      return s.trim();
    },
    looksEmpty: function (s) {
      var visibleLetters = s.replace(nonPrintableCharacters, '');
      return visibleLetters.length === 0;
    },
    limitedTo: function (s, n) {
      return s && (s.length <= n ? s : s.substr(0, n - 1) + '');
    },
    escaped: function (s) {
      return _.escape(s);
    },
    repeats: function (s, n) {
      // TODO: this should come in two versions: _.repeat (s, n) and _.repeats (n, s)
      return _.times(n, _.constant(s)).join('');
    },
    prepend: function (s, other) {
      return other + s;
    },
    append: function (s, other) {
      return s + other;
    },
    first: function (s, n) {
      return s.slice(0, n);
    },
    last: function (s, n) {
      return s.slice(-2);
    },
    reversed: function (s) {
      return s.split('').reverse().join('');
    },
    capitalized: function (s) {
      return s.charAt(0).toUpperCase() + s.slice(1);
    },
    decapitalized: function (s) {
      return s.charAt(0).toLowerCase() + s.slice(1);
    },
    latinAlphanumericValue: function (s) {
      return s.replace(/[^a-z0-9]/gi, '');
    },
    alphanumericValue: function (s) {
      return s.replace(/[^a-z-0-9]/gi, '');
    },
    numericValue: function (s) {
      return s.replace(/[^0-9]/g, '');
    },
    integerValue: function (s) {
      return s.numericValue.parsedInt;
    },
    parsedInt: function (s) {
      var result = parseInt(s, 10);
      return _.isFinite(result) ? result : undefined;
    },
    bytes: function (s) {
      var bytes = new Uint8Array(s.length);

      for (var i = 0; i < s.length; ++i) {
        bytes[i] = s.charCodeAt(i);
      }

      return bytes;
    },
    hash: function (s) {
      // unsecure, but fast, taken from Java's object hasher
      var hash = 0,
          i,
          chr,
          len;

      if (s.length === 0) {
        return hash;
      }

      for (i = 0, len = s.length; i < len; i++) {
        chr = s.charCodeAt(i);
        hash = (hash << 5) - hash + chr;
        hash |= 0;
      } // Convert to 32bit integer


      return hash;
    },
    transliterate: function () {
      var table = _.extend({
        '': 'a',
        '': 'b',
        '': 'v',
        '': 'g',
        '': 'd',
        '': 'e',
        '': 'yo',
        '': 'zh',
        '': 'z',
        '': 'i',
        '': 'y',
        '': 'k',
        '': 'l',
        '': 'm',
        '': 'n',
        '': 'o',
        '': 'p',
        '': 'r',
        '': 's',
        '': 't',
        '': 'u',
        '': 'ph',
        '': 'h',
        '': 'ts',
        '': 'ch',
        '': 'sh',
        '': 'sch',
        '': '',
        '': '',
        '': 'y',
        '': 'e',
        '': 'yu',
        '': 'ya'
      }, _.fromPairs(_.map('_-1234567890qwertyuiopasdfghjklzxcvbnm', function (x) {
        return [x, x];
      })));

      return function (s) {
        var result = '';
        var source = (s || '').toLowerCase();

        for (var i = 0, n = source.length; i < n; i++) {
          var c = source[i];
          var x = table[c] || '';
          result += x;
        }

        return result;
      };
    }()
  });
});

_.extend(String, {
  randomHex: function (length) {
    if (length === undefined) {
      length = _.random(1, 32);
    }

    var string = '';

    for (var i = 0; i < length; i++) {
      string += Math.floor(Math.random() * 16).toString(16);
    }

    return string;
  },
  leadingZero: function (n) {
    return n < 10 ? '0' + n : n.toString();
  }
});

_.deferTest(['identifier naming style interpolation'], function () {
  $assert(_.camelCaseToLoDashes('flyingBurritoOption'), 'flying_burrito_option');
  $assert(_.camelCaseToDashes('flyingBurritoOption'), 'flying-burrito-option');
  $assert(_.dashesToCamelCase('flying-burrito-option'), 'flyingBurritoOption');
  $assert(_.loDashesToCamelCase('flying_burrito_option'), 'flyingBurritoOption');
}, function () {
  _.camelCaseToDashes = function (x) {
    return x.replace(/[a-z][A-Z]/g, function (x) {
      return x[0] + '-' + x[1].lowercase;
    });
  };

  _.camelCaseToLoDashes = function (x) {
    return x.replace(/[a-z][A-Z]/g, function (x) {
      return x[0] + '_' + x[1].lowercase;
    });
  };

  _.dashesToCamelCase = function (x) {
    return x.replace(/(-.)/g, function (x) {
      return x[1].uppercase;
    });
  };
});

_.loDashesToCamelCase = function (x) {
  return x.replace(/(_.)/g, function (x) {
    return x[1].uppercase;
  });
};
},{"underscore":"node_modules/underscore/underscore.js","printable-characters":"node_modules/printable-characters/build/printable-characters.js"}],"node_modules/useless/base/dynamic/bindable.js":[function(require,module,exports) {
"use strict";

var _ = require('underscore');
/*  Interceptable/observable methods
    ======================================================================== */

/*  TODO: rewrite test
 */


_.deferTest('bindable', function () {
  /*  Test subject
   */
  var obj = {
    plusOne: function (x) {
      return x + 1;
    },
    innocentMethod: function (x) {
      return x;
    }
  };
  $assertEveryCalled(function (before__1, after__1, intercept__2, secondIntercept__1, bindable__1, infixBefore__1) {
    /*  That's how you observe method calls
     */
    _.onBefore(obj, 'plusOne', function (x) {
      before__1();
      $assert(x === 7);
    });

    _.onAfter(obj, 'plusOne', function (x, result) {
      after__1();
      $assert([x, result], [7, 8]);
    });

    $assert(obj.plusOne(7), 8);
    /*  That's how you intercept method calls
     */

    _.intercept(obj, 'innocentMethod', function (x, method) {
      intercept__2();
      return method(x + 1) * 2;
    });

    $assert(obj.innocentMethod(42), (42 + 1) * 2);
    /*  Consequent interceptors wrap-up previous ones
     */

    _.intercept(obj, 'innocentMethod', function (x, method) {
      secondIntercept__1();
      $assert(method(x), (42 + 1) * 2);
      return 'hard boiled shit';
    });

    $assert(obj.innocentMethod(42), 'hard boiled shit');
    /*  Test infix calls
     */

    var method = _.bindable(function (x) {
      bindable__1();
      $assert(x === 42);
    });

    method.onBefore(function (x) {
      infixBefore__1();
      $assert(x === 42);
    });
    method(42);
  });
  /*  Test 'once' semantics
   */

  var obj2 = {
    plusOne: function (x) {
      return x + 1;
    }
  };
  $assertEveryCalledOnce(function (beforeCalled, afterCalled) {
    var before = function (x) {
      beforeCalled();
      $assert(x === 7);
    };

    var after = function (x, result) {
      afterCalled();
      $assert([x, result], [7, 8]);
    };

    _.times(2, function () {
      _.onceBefore(obj, 'plusOne', before);

      _.onceAfter(obj, 'plusOne', after);
    });

    $assert(obj.plusOne(7), 8);
    $assert(obj.plusOne(7), 8);
  });
  /*  Test unbinding
   */

  $assertEveryCalled(function (afterCalled__1, shouldNotCall__0) {
    var method = _.bindable(function () {});
    /*  Unbind specific delegate
     */


    method.onBefore(shouldNotCall__0);
    method.onAfter(afterCalled__1);
    method.off(shouldNotCall__0);
    method();
    /*  Unbind everything
     */

    method.onBefore(shouldNotCall__0);
    method.onAfter(shouldNotCall__0);
    method.off();
    method();
  });
}, function () {
  /*  Internal impl
   */
  var hooks = ['onceBefore', 'onceAfter', 'onBefore', 'onAfter', 'intercept'];
  var hooksShort = ['onceBefore', 'onceAfter', 'before', 'after', 'intercept'];

  var copyHooks = function (from, to) {
    _.extend(to, _.map2(_.pick(from, hooks), _.clone));
  };

  var makeBindable = function (obj, targetMethod) {
    var method = obj[targetMethod];
    return _.isBindable(method) ? method : obj[targetMethod] = _.bindable(method);
  };

  var hookProc = function (name) {
    return function (obj, targetMethod, delegate) {
      var bindable = makeBindable(obj, targetMethod);
      return bindable[name].call(bindable, delegate);
    };
  };

  var mixin = function (method, context) {
    if (typeof method !== 'function') {
      throw new Error('method should be a function');
    }

    return _.extend({}, method, {
      _bindable: true,
      impl: method,
      _wrapped: method,
      context: context,
      off: function (delegate) {
        _.each(hooks, function (hook) {
          if (delegate) {
            this['_' + hook].remove(delegate);
          } else {
            this['_' + hook].removeAll();
          }
        }, this);

        return this;
      }
    },
    /*  .onBefore, .onAfter, .intercept (API methods)
     */
    _.fromPairs(_.map(hooks, function (name) {
      var queueName = '_' + name;
      var once = name.indexOf('once') >= 0;
      return [name, function (fn) {
        if (!_.isBindable(this)) {
          throw new Error('wrong this');
        }

        var queue = this[queueName];

        if (!once || queue.indexOf(fn) < 0) {
          this[queueName].push(fn);
        }

        return this;
      }];
    })),
    /*  ._onBefore, ._onAfter, ._intercept (queues)
     */
    _.fromPairs(_.map(hooks, function (name) {
      return ['_' + name, []];
    })));
  };
  /*  Public API
   */


  _.extend(_, _.mapValues(_.invert(hooks), hookProc.flip2), {
    unbind: function (obj, targetMethod, delegate) {
      var method = obj[targetMethod];

      if (method && method.off) {
        method.off(delegate);
      }
    },
    isBindable: function (fn) {
      return fn && fn._bindable ? true : false;
    },
    bindable: _.extendWith({
      hooks: hooks,
      hooksShort: hooksShort
    }, function (method, context) {
      return _.withSameArgs(method, _.extendWith(mixin(method, context), function wrapper() {
        var onceBefore = wrapper._onceBefore;
        var onceAfter = wrapper._onceAfter;
        var before = wrapper._onBefore;
        var after = wrapper._onAfter;
        var intercept = wrapper._intercept;
        var this_ = context || this;
        var i,
            ni = undefined;
        /*  Call onceBefore
         */

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        if (onceBefore.length) {
          for (i = 0, ni = onceBefore.length; i < ni; i++) {
            onceBefore[i].apply(this_, args);
          }

          onceBefore.removeAll();
        }
        /*  Call before
         */


        for (i = 0, ni = before.length; i < ni; i++) {
          before[i].apply(this_, args);
        }
        /*  Call intercept
         */


        var result = (intercept.length ? _.cps.compose([method].concat(intercept)) : method).apply(this_, args); // @hide

        if (after.length || onceAfter.length) {
          var newArgs = args.concat(result);
          /*  Call after
           */

          for (i = 0, ni = after.length; i < ni; i++) {
            after[i].apply(this_, newArgs);
          }
          /*  Call onceAfter
           */


          if (onceAfter.length) {
            var arr = onceAfter.copy;
            onceAfter.removeAll();

            for (i = 0, ni = arr.length; i < ni; i++) {
              arr[i].apply(this_, newArgs);
            }
          }
        }

        return result;
      }));
    })
  });
});
},{"underscore":"node_modules/underscore/underscore.js"}],"node_modules/useless/base/dynamic/stream.js":[function(require,module,exports) {
"use strict";

var _ = require('underscore');
/*  Generic functional primitives for dynamic code binding
    ======================================================================== */


_.tests.stream = {
  'triggerOnce': function () {
    $assertEveryCalledOnce(function (mkay) {
      var t = _.triggerOnce();

      var f = function (_321) {
        $assert(_321 === 321);
        mkay();
      };

      t(f);
      t(f);
      t(321);
      t(123);
    });
  },
  'observable': function () {
    /*  Should accept value as constructor, it should be accessible by .value property
     */
    var initedWithValue = _.observable(555);

    $assert(initedWithValue.value, 555);
    /*  Should call with current value when upon binding
     */

    $assertEveryCalledOnce(function (mkay) {
      var valueChanged = _.observable();

      valueChanged(999);
      valueChanged(function (_999) {
        $assert(_999, 999);
        mkay();
      });
    });
    /*  Should call previously bound callback if changed
     */

    $assertEveryCalled(function (mkay__3) {
      var valueChanged = _.observable();

      valueChanged(mkay__3);
      valueChanged(123);
      valueChanged(345);
      valueChanged(567);
    });
    /*  Should pass last distinct value as argument to callbacks, not calling if its not changed
     */

    $assertEveryCalledOnce(function (mkay) {
      var valueChanged = _.observable();

      valueChanged(function (_111) {
        $assert(111, _111);
        mkay();
      });
      valueChanged(111);
      valueChanged(111);
    });
    /*  Should pass previous value as second argument
     */

    $assertEveryCalledOnce(function (mkay) {
      var valueChanged = _.observable(444);

      valueChanged(function (_666, _444) {
        if (_444) {
          $assert([_666, _444], [666, 444]);
          mkay();
        }
      });
      valueChanged(666);
    });
  },
  'observable.when': function () {
    $assertEveryCalledOnce(function (mkay) {
      var value = _.observable(234);

      value.when(234, function () {
        mkay();
      });
    }); // passing constant should work

    $assertEveryCalledOnce(function (mkay) {
      var value = _.observable();

      value.when(_.equals(432), function () {
        mkay();
      });
      value(432);
      value(234);
    });
    $assertNotCalled(function (mkay) {
      var value = _.observable();

      value.when(_.equals(432), function () {
        mkay();
      });
      value(7);
    });
  },
  'once': function () {
    $assertEveryCalledOnce(function (mkay) {
      var whenSomething = _.trigger();

      whenSomething.once(mkay);
      whenSomething.once(mkay);
      whenSomething();
      whenSomething();
    });
  },
  '_.gatherChanges': function () {
    var valueA = _.observable(),
        valueB = _.observable(),
        changes = [];

    _.gatherChanges(valueA, valueB, function (a, b) {
      changes.push([a, b]);
    });

    valueA(123);
    valueB(777);
    $assert(changes, [[123, undefined], [123, 777]]);
  },
  'context': function () {
    var trigger = _.extend(_.trigger(), {
      context: 42
    });

    trigger(function () {
      $assert(this, 42);
    });
    trigger();
  },
  '_.off (bound)': function () {
    var react = function () {
      $fail;
    };

    var act = _.trigger(react);

    _.off(react);

    act();
  },
  '_.off (stream)': function () {
    var fail = function () {
      $fail;
    };

    var act = _.trigger(fail);

    _.off(act);

    act();
  },
  '_.barrier (defaultListener)': function () {
    $assertEveryCalled(function (mkay) {
      _.barrier(function () {
        mkay();
      })();
    });
  },

  /*  Need to rewrite it for clariy
   */
  'all shit': function () {
    var obj = {
      somethingReady: _.barrier(),
      whenSomething: _.trigger()
    };
    /*  Test conventional semantics (1:1 multicast)
     */

    $assertEveryCalled(function (mkay1__2, mkay2__2) {
      obj.whenSomething(mkay1__2); // that's how you bind

      obj.whenSomething(mkay2__2);
      obj.whenSomething(); // that's how you trigger it

      obj.whenSomething();
    });
    /*  Test unbinding
     */

    $assertEveryCalledOnce(function (shouldCall) {
      var whenSomething = _.trigger();

      var shouldBeCalled = function () {
        shouldCall();
      },
          shouldNotBeCalled = function () {
        $fail;
      };

      whenSomething(shouldBeCalled);
      whenSomething(shouldNotBeCalled);
      whenSomething.off(shouldNotBeCalled); // that's how you unbind specific listeners

      whenSomething();
    });
    /*  Test 'barrier' semantics + test argument passing
     */

    $assertEveryCalledOnce(function (mkay1, mkay2) {
      obj.somethingReady(function (x) {
        $assert(x === 'foo'); // you may pass arguments to callbacks

        obj.somethingReady(x); // should not call anything

        mkay1();
      });
      obj.somethingReady(function (x) {
        $assert(x === 'foo');
        mkay2();
      });
      obj.somethingReady('foo');
    }); // that's how you trigger it (may pass arguments)

    obj.somethingReady('bar'); // should not call anything
  },
  'call order consistency': function (done) {
    var abc = '';

    var put = function (x) {
      return _.barrier(function () {
        abc += x;
      });
    };

    var a = put('a'),
        b = put('b'),
        c = put('c');

    var barr = _.barrier();

    barr(a)(function () {
      barr.postpones = true;
      barr(c);
      barr.postpones = false;
    })(b); // C is bound after B, so it should be executed after B

    barr(true);

    _.allTriggered([a, b, c], function () {
      $assert(abc, 'abc');
      done();
    });
  },
  '_.barrier reset': function () {
    var b = _.barrier();

    b('not_42');
    b.reset();
    $assertEveryCalledOnce(function (mkay) {
      b(function (value) {
        mkay();
        $assert(value, 42);
      });
      b(42);
    });
  },
  '_.barrier (value)': function () {
    $assertEveryCalledOnce(function (mkay) {
      var willBe42 = _.barrier(42);

      $assert(willBe42.already);
      willBe42(function (_42) {
        $assert(_42, 42);
        mkay();
      });
    });
  },
  'observable.item': function () {
    var items = _.observable({
      foo: 7,
      bar: 8
    });

    var foo = items.item('foo');
    var bar = items.item('bar');
    $assert(foo, items.item('foo')); // should be same cached observable

    $assert(foo.value, 7);
    $assert(bar.value, 8);
    foo(77);
    $assert(foo.value, 77);
    $assert(items.value, {
      foo: 77,
      bar: 8
    });
    items({
      bar: 88
    });
    $assert(foo.value, undefined);
    $assert(bar.value, 88);
    $assert(items.value, {
      bar: 88
    });
  },
  'postpone works with _.trigger (regression)': function (done) {
    _.trigger(done).postpone();
  }
};

_.extend(_, {
  gatherChanges: function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var observables = _.isArray(args[0]) ? args[0] : _.initial(args);

    var accept = _.last(args);

    var gather = function (value) {
      accept.apply(this, _.pluck(observables, 'value'));
    };

    _.each(observables, function (read) {
      read(gather);
    });
  },
  allTriggered: function (triggers, then
  /* deprecated */
  ) {
    return Promise.all(triggers.map(function (t) {
      return t.promise;
    })).then(then);
  },
  observableRef: function () {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return _.extend(_.observable.apply(this, args), {
      trackReference: true
    });
  },
  observable: function () {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    var value = args[0];

    var stream = _.stream({
      isObservable: true,
      hasValue: args.length > 0,
      value: _.isFunction(value) ? undefined : value,
      read: function (schedule) {
        return function (returnResult) {
          if (stream.hasValue) {
            returnResult.call(this, stream.value);
          }

          schedule.call(this, returnResult);
        };
      },
      write: function (returnResult) {
        return function (value) {
          if (stream.beforeWrite) {
            value = stream.beforeWrite(value);
          }

          if (!stream.hasValue || !(stream.trackReference ? stream.value === value : _.isEqual(stream.value, value))) {
            var prevValue = stream.value;
            var hadValue = stream.hasValue;
            stream.hasValue = true;
            stream.value = value;

            if (hadValue) {
              returnResult.call(this, false
              /* flush */
              , stream.value, prevValue);
            } else {
              returnResult.call(this, false
              /* flush */
              , stream.value);
            }
          }
        };
      }
    });

    if (args.length) {
      stream.apply(this, args);
    }

    return _.extend(stream, {
      force: function (value) {
        stream.hasValue = false;
        stream(arguments.length ? value : stream.value);
      },
      then: function (fn) {
        var next = _.observable();

        next.beforeWrite = fn;
        stream(function (x) {
          next.write(x);
        });
        return next;
      },
      toggle: function () {
        return stream(!stream.value);
      },
      tie: function (other) {
        stream(other);
        other(stream);
        return stream;
      },
      item: function (id) {
        var all = stream.itemObservables || (stream.itemObservables = {});
        var item = all[id];

        if (!item) {
          item = all[id] = _.observable((stream.value && stream.value)[id]);
          item(function (x) {
            var oldValue = stream.value && stream.value[x];

            if (oldValue !== x) {
              (stream.value || (stream.value = {}))[id] = x;
              stream.force();
            }
          });
          stream(function (items) {
            item.write(items[id]);
          });
        }

        return item;
      },
      when: function (match, then) {
        var matchFn = _.isFunction(match) ? match : _.equals(match),
            alreadyCalled = false;
        stream(function callee() {
          for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            args[_key4] = arguments[_key4];
          }

          if (matchFn(args[0])) {
            if (!alreadyCalled) {
              alreadyCalled = true;
              stream.off(callee);
              then.apply(this, args);
            } else {
              /* log.w ('WTF') */
            }
          }
        });
      }
    });
  },
  barrier: function (defaultValue) {
    var defaultListener = undefined;

    if (_.isFunction(defaultValue)) {
      defaultListener = defaultValue;
      defaultValue = undefined;
    }

    var barrier = _.stream({
      already: defaultValue !== undefined,
      value: defaultValue,
      reset: function () {
        barrier.already = false;
        delete barrier.value;
      },
      write: function (returnResult) {
        return function (value) {
          if (!barrier.already) {
            barrier.already = true;
            barrier.value = value;
          }

          returnResult.call(this, true
          /* flush schedule */
          , barrier.value);
        };
      },
      read: function (schedule) {
        return function (returnResult) {
          if (barrier.already) {
            (barrier.postpones || barrier.commitingReads ? // solves problem outlined in 'call order consistency' test
            returnResult.postponed : returnResult).call(this, barrier.value);
          } else {
            schedule.call(this, returnResult);
          }
        };
      }
    });

    if (defaultListener) {
      barrier(defaultListener);
    }

    return barrier;
  },
  triggerOnce: $restArg(function () {
    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }

    var stream = _.stream({
      read: function (schedule) {
        return function (listener) {
          if (stream.queue.indexOf(listener) < 0) {
            schedule.call(this, listener);
          }
        };
      },
      write: function (writes) {
        return writes.partial(true);
      }
    }).apply(this, args);

    return stream;
  }),
  trigger: $restArg(function () {
    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      args[_key6] = arguments[_key6];
    }

    return _.stream({
      read: _.identity,
      write: function (writes) {
        return writes.partial(false);
      }
    }).apply(this, args);
  }),
  off: function () {
    var fn = arguments.length <= 0 ? undefined : arguments[0],
        what = arguments.length <= 1 ? undefined : arguments[1];

    if (fn.queue) {
      if (arguments.length === 1) {
        fn.queue.off();
      } else {
        fn.queue.off(what);
      }
    }

    if (fn.queuedBy) {
      _.each(fn.queuedBy, function (queue) {
        queue.remove(fn);
      });

      delete fn.queuedBy;
    }
  },
  stream: function (cfg_) {
    var cfg = cfg_ || {};

    var queue = _.extend([], {
      off: function () {
        var fn = arguments.length <= 0 ? undefined : arguments[0];

        if (this.length) {
          if (arguments.length === 0) {
            _.each(this, function (fn) {
              fn.queuedBy.remove(this);
            }, this);

            this.removeAll();
          } else {
            if (fn.queuedBy) {
              fn.queuedBy.remove(this);
              this.remove(fn);
            }
          }
        }
      }
    });

    var self = undefined;

    var scheduleRead = function (fn) {
      if (queue.indexOf(fn) < 0) {
        if (fn.queuedBy) {
          fn.queuedBy.push(queue);
        } else {
          fn.queuedBy = [queue];
        }

        queue.push(fn);
      }
    };

    var commitPendingReads = function (flush) {
      var context = self.context || this,
          schedule = queue.copy;

      if (flush) {
        queue.off();
      }

      self.commitingReads = true;

      for (var _len7 = arguments.length, args = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {
        args[_key7 - 1] = arguments[_key7];
      }

      for (var i = 0, n = schedule.length; i < n; i++) {
        (self.postpones ? schedule[i].postponed : schedule[i]).apply(context, args);
      }

      delete self.commitingReads;
    };

    var write = cfg.write(commitPendingReads);
    var read = cfg.read(scheduleRead);
    /*  I/O API (two-way)
     */

    var frontEnd = function () {
      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        args[_key8] = arguments[_key8];
      }

      var fn = args[0];

      if (_.isFunction(fn)) {
        read.call(this, fn);
      } else {
        write.apply(this, args);
      }

      return frontEnd;
    };
    /*  Once semantics
     */


    var once = function (then) {
      if (!_.find(queue, function (f) {
        return f.onceWrapped_ === then;
      })) {
        read(_.extend(function callee(v) {
          _.off(self, callee);

          then(v);
        }, {
          onceWrapped_: then
        }));
      }
    };
    /*  Constructor
     */


    self = _.extend($restArg(frontEnd), cfg, {
      queue: queue,
      once: once,
      off: _.off.asMethod,
      read: read,
      write: write,
      postpone: function () {
        for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
          args[_key9] = arguments[_key9];
        }

        self.postponed.apply(self.context, args);
      }
    });

    _.defineProperty(self, 'promise', function () {
      return new Promise(function (resolve) {
        return self(resolve);
      });
    });

    return self;
  }
});
/*  Observable.map (experimental)
    ======================================================================== */


_.deferTest(['stream', 'observable.map'], function () {
  /*  General semantics   */
  var foo = _.observable('foo'),
      bar = _.observable('bar');

  var fooBar = _.observable.map([foo, bar], _.appends('42'));

  var results = [];
  fooBar(function (value) {
    results.push(value.copy);
  });
  $assert(results, [['foo42', 'bar42']]);
  foo('qux');
  bar('zap');
  $assert(results, [['foo42', 'bar42'], ['qux42', 'bar42'], ['qux42', 'zap42']]);
  /*  Works over objects  */

  _.observable.map({
    'foo': _.observable('bar')
  })(function (obj) {
    $assert({
      'foo': 'bar'
    }, obj);
  });
}, function () {
  _.observable.map = function (obj, fn) {
    fn = fn || _.identity;
    var value = _.isArray(obj) ? new Array(obj.length) : {};

    var result = _.observable(value);

    _.each(obj, function (read, i) {
      read(function (x) {
        value[i] = fn(x, i);
        result.force(value);
      });
    });

    return result;
  };

  _.observable.all = _.observable.map;
});
},{"underscore":"node_modules/underscore/underscore.js"}],"node_modules/useless/base/OOP.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var _ = require('underscore');
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
------------------------------------------------------------------------

Hot-wires some common C++/Java/C# ways to OOP with JavaScript's ones.

------------------------------------------------------------------------
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */


_.hasOOP = true;

_.withTest('OOP', {
  '$prototype / $extends': function () {
    /*  Prototypes are defined via $prototype
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
    var Foo = $prototype({
      /*  If constructor is not defined (like here), it's default impl. will equal
          to the following:                                                               */
      //          constructor: function (cfg) { _.extend (this, cfg) },

      /*  $static is used to designate type-level members (context-free ones),
          effectively porting that shit from C++/C#/Java world.                           */
      method: function () {
        return 'foo.method';
      },
      staticMethod: $static(function () {
        return 'Foo.staticMethod';
      }),

      /*  $property is used to tag a value as an property definition.
          Property definitions expand itself within properties.js module, which
          is separate from OOP.js                                                         */
      property: $property(function () {
        return 'foo.property';
      }),
      staticProperty: $static($property(function () {
        return 'Foo.staticProperty';
      })),

      /*  Tags on members can be grouped like this, to reduce clutter if you have lots
          of members tagged with same tag.                                                */
      $static: {
        $property: {
          one: 1,
          two: 2,
          three: 3
        }
      },

      /*  Demonstrates some semantics of property definitions, provided by properties.js
          See that module for further investigation.                                      */
      $property: {
        static42: $static(42),
        just42: 42,
        just42_too: function () {
          return 42;
        },
        fullBlown: {
          enumerable: false,
          // will be visible as object's own property (defaults to true)
          configurable: true,
          // can be deleted by delete operator (defaults to false)
          get: function () {
            return 42;
          },
          set: function (x) {
            $stub;
          }
        }
      }
    });
    /*  Inherited prototypes are defined via $extends
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

    var Bar = $extends(Foo, $final({
      /*  If constructor is not defined (like here), it's default impl.
          will be equal to the following one (calls base constructor):     */
      //          constructor: function () { Foo.prototype.constructor.apply (this, arguments)) } 
      staticMethod: $static(function () {
        return 'Bar.staticMethod';
      }),
      method: function () {
        return 'bar.method';
      }
    }));
    /*  Instances of $prototype/$extends are created by the 'new' operator, as
        this pair of utility is just a thin wrapper over native JS prototypes.
         The 'new' operator calls 'constructor' member from a prototype
        definition. If no constructor is specified, default one takes first
        argument and extends constructed instance with it, overriding any member
        value that is specified at prototype definition (and this is a
        really common way to define prototype constructors in JavaScript)
         Such semantics could be treated as somewhat similar to the 'anonymous
        classes' feature in Java, which is a useful mechanism for ad-hoc
        specialization of constructed prototypes.   
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

    var foo = new Foo();
    var fuu = new Foo({
      method: function () {
        return 'fuu.method';
      }
    });
    var bar = new Bar({
      hi: 'there'
    });
    $assert(bar.hi === 'there');
    $assert(fuu.method() === 'fuu.method');
    $assert([foo.just42, bar.just42], [42, 42]); //  inheritance should work

    $assert([Foo.static42, Bar.static42], [42, undefined]); //  (static members do not inherit)

    /*  Overriding should work
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

    $assert([foo.method(), bar.method()], ['foo.method', 'bar.method']);
    $assert([Foo.staticMethod(), Bar.staticMethod()], ['Foo.staticMethod', 'Bar.staticMethod']);
    /*  Regular members shouln't be visible at type level
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

    $assert([foo.property, foo.staticProperty], ['foo.property', undefined]);
    $assert([Foo.staticProperty, Foo.property], ['Foo.staticProperty', undefined]);
    /*  Until explicitly stated otherwise, properties are constant.
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

    $assertThrows(function () {
      foo.just42 = 43;
    }, _.matches({
      message: 'cannot change just42 (as it\'s sealed to 42)'
    }));
  },

  /*  Use $final to tag a thing as non-overrideable (comes from Java)
      ======================================================================== */
  '$final': function () {
    /*  Tagging arbitrary member as $final
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
    $assertThrows(function () {
      var A = $prototype({
        constructor: $final(function () {})
      });
      var B = $extends(A, {
        constructor: function () {}
      });
    }, // will throw Error
    _.matches({
      message: 'Cannot override $final constructor'
    }));
    /*  Tagging whole prototype as $final
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

    $assertThrows(function () {
      var A = $prototype($final({}));
      var B = $extends(A);
    }, // will throw Error
    _.matches({
      message: 'Cannot derive from $final-marked prototype'
    }));
  },

  /*  Use $alias to make member aliases with correct semantics
      ======================================================================== */
  'ES6 properties comprehension': function () {
    var Foo = $prototype({
      get foo() {
        $assert(Meta.unwrap(this.constructor.$definition.foo).get instanceof Function);
        $assert(Meta.tags(this.constructor.$definition.foo), {
          'property': true
        });
        return 42;
      },

      $static: {
        get bar() {
          return 42;
        }

      }
    });
    $assert(Meta.unwrap(Foo.$definition.bar).get instanceof Function);
    $assert(Meta.tags(Foo.$definition.bar), {
      'static': true,
      'property': true
    });
    $assert(Foo.bar, 42);
    var foo = new Foo();
    $assert(foo.foo, 42);
  },

  /*  Use $alias to make member aliases with correct semantics
      ======================================================================== */
  '$alias': function () {
    var foo = new ($prototype({
      error: function () {
        return 'foo.error';
      },
      failure: $alias('error'),
      crash: $alias('error'),
      finalCrash: $final($alias('crash'))
      /* chaining works */

    }))();
    var def = foo.constructor.$definition;
    $assert(foo.finalCrash, foo.crash, foo.failure, foo.error); // all point to same function

    $assert($final.is(def.finalCrash)); // you can add new tags to alias members

    $assertNot($final.is(def.crash)); // adding tags to alias members does not affect original members 

    $assertNot($final.is(def.error));
    /*  Ad-hoc property aliases (applicable even when there's no explicitly declared member at what alias points to)
     */

    var size = new ($prototype({
      w: $alias($property('x')),
      h: $alias($property('y'))
    }))();
    $assert([size.x = 42, size.y = 24], [size.w, size.h], [42, 24]);
  },

  /*  Static (compile-time) constructor gets called at prototype generation
      ======================================================================== */
  '$constructor': function () {
    $assertEveryCalledOnce(function (mkay) {
      var foo = new ($prototype({
        $constructor: function () {
          mkay();
        }
      }))();
    });
  },

  /*  Run-time type information APIs
      ======================================================================== */
  'RTTI': function () {
    var Foo = $prototype({
      $static: {
        noop: _.noop
      }
    }),
        Bar = $extends(Foo); // empty definition argument read as {}

    var foo = new Foo(),
        bar = new Bar();
    /*  Basically, the simplest way to check a type, relying on some native JavaScript prototype semantics.
        But it does not account inheritance.
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

    $assert(foo.constructor === Foo);
    $assert(bar.constructor === Bar);
    /*  A functional crossbrowser version of 'instanceof' (accounts inheritance):
     
            1.  Boils down to native 'instanceof' where available
            2.  In elder browsers, emulates with correct semantics
     
        Why use (instead of native syntax):
        
            -   cross-browser
            -   functional (can be partial'ed to yield a predicate)
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

    $assert(_.isTypeOf(Function, foo.constructor.noop));
    $assert(_.isTypeOf(Meta, foo.constructor.$definition.noop)); // note how $static group is collapsed to normal form

    /*  Infix version (a static member of every $prototype)
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

    $assert(Foo.isTypeOf(foo));
    $assert(!Bar.isTypeOf(foo));
    $assert(Bar.isTypeOf(bar));
    $assert(Foo.isTypeOf(bar));
    /*  Another infix version (a member of every $prototype)
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

    $assert(foo.isInstanceOf(Foo));
    $assert(!foo.isInstanceOf(Bar));
    $assert(bar.isInstanceOf(Bar));
    $assert(bar.isInstanceOf(Foo));
  },

  /*  This is how to decide whether a function is $prototype constructor
      ======================================================================== */
  'isConstructor': function () {
    var Proto = $prototype(),
        // empty argument read as {}
    dummy = function () {};

    $assert($prototype.isConstructor(Proto), true);
    $assert($prototype.isConstructor(dummy), false);
    $assert($prototype.isConstructor(null), false); // regression

    $assert([Proto, dummy].map($prototype.isConstructor), [true, false]);
  },

  /*  $prototype.inheritanceChain for traversing inheritance chain
      ======================================================================== */
  'inheritanceChain': function () {
    var A = $prototype();
    var B = $extends(A);
    var C = $extends(B);
    $assert($prototype.inheritanceChain(C), [C, B, A]);
  },

  /*  $prototype.defines for searching for members on definition chain
      ======================================================================== */
  'defines': function () {
    var A = $prototype({
      toString: function () {}
    });
    var B = $extends(A);
    var C = $prototype();
    $assert([$prototype.defines(B, 'toString'), $prototype.defines(C, 'toString')], [true, false]);
  },

  /*  $prototype is really same as $extends, if passed two arguments
      ======================================================================== */
  'two-argument syntax of $prototype': function () {
    var A = $prototype();
    var B = $prototype(A, {}); // same as $extends (Base, def)

    $assert(B.$base === A.prototype);
  },

  /*  You can enumerate members grouped by tag name via $membersByTag
      ======================================================================== */
  '$membersByTag': function () {
    var foo = $static($property(1)),
        bar = $property(2);
    $assertMatches($prototype({
      foo: foo,
      bar: bar
    }).$membersByTag, {
      'static': {
        'foo': foo
      },
      'property': {
        'foo': foo,
        'bar': bar
      }
    });
  },

  /*  Tags on definition render to static properties
      ======================================================================== */
  'tags on definition': function () {
    $assertMatches($prototype($static($final({}))), {
      $static: true,
      $final: true
    });
  },

  /*  $mixin to extend existing types with $prototype-style definitions
      ======================================================================== */
  '$mixin': function () {
    var Type = $prototype();
    $mixin(Type, {
      twentyFour: $static($property(24)),
      fourtyTwo: $property(42)
    });
    $assert([Type.twentyFour, new Type().fourtyTwo], [24, 42]);
  }
}, function () {
  /*  PUBLIC API
      ======================================================================== */
  _(['property', 'static', 'final', 'alias', 'memoized', 'private', 'builtin', 'hidden', 'testArguments']).each(Meta.globalTag);

  _.extend($global, {
    $prototype: function (arg1, arg2) {
      return $prototype.impl.compile.apply($prototype.impl, arguments.length > 1 ? _.asArray(arguments).reverse() : arguments);
    },
    $extends: function (base, def) {
      return $prototype(base, def || {});
    },
    $mixin: function (constructor, def) {
      return constructor === Array ? $prototype.impl.compileMixin({
        constructor: constructor,
        $hidden: def
      }) : $prototype.impl.compileMixin(_.extend(def, {
        constructor: constructor
      }));
    }
  });

  _.extend($prototype, {
    isConstructor: function (what) {
      return _.isPrototypeConstructor(what);
    },
    macro: function (arg, fn) {
      if (arguments.length === 1) {
        $prototype.impl.alwaysTriggeredMacros.push(arg);
      } else {
        $prototype.impl.memberNameTriggeredMacros[arg] = fn;
      }
    },
    macroTag: function (name, fn) {
      Meta.globalTag(name);
      $prototype.impl.tagTriggeredMacros[name] = fn;
    },
    each: function (visitor) {
      var namespace = $global;

      for (var k in namespace) {
        if (!(k[0] === '$')) {
          var value = namespace[k];

          if ($prototype.isConstructor(value)) {
            visitor(value, k);
          }
        }
      }
    },
    defines: function (constructor, member) {
      return _.find($prototype.inheritanceChain(constructor), function (supa) {
        return supa.$definition && supa.$definition.hasOwnProperty(member) || false;
      }) ? true : false;
    },
    inheritanceChain: function (def) {
      var chain = [];

      while (def) {
        chain.push(def);
        def = def.$base && def.$base.constructor;
      }

      return chain;
    },

    /*  INTERNALS
        ==================================================================== */
    impl: {
      alwaysTriggeredMacros: [],
      memberNameTriggeredMacros: {},
      tagTriggeredMacros: {},
      compile: function (def, base) {
        var impl = base && base.$impl || this;
        return $untag(impl.sequence(def, base).call(impl, def || {}).constructor);
      },
      sequence: function (def, base) {
        return _.sequence(
        /*  TODO: optimize performance (there's PLENTY of room to do that)
         */
        this.convertPropertyAccessors, this.extendWithTags, this.flatten, this.generateCustomCompilerImpl(base), this.ensureFinalContracts(base), this.generateConstructor(base), this.evalAlwaysTriggeredMacros(base), this.evalMemberTriggeredMacros(base), this.contributeTraits(base), this.evalPrototypeSpecificMacros(base), this.generateBuiltInMembers(base), this.callStaticConstructor, this.expandAliases, this.groupMembersByTagForFastEnumeration, this.defineStaticMembers, this.defineInstanceMembers);
      },
      compileMixin: function (def) {
        return _.sequence(this.convertPropertyAccessors, this.flatten, this.contributeTraits(), this.expandAliases, this.evalMemberTriggeredMacros(), this.defineStaticMembers, this.defineInstanceMembers).call(this, def || {}).constructor;
      },
      convertPropertyAccessors: function (def) {
        // converts { get foo () {} } to { get: $property (...) }
        for (var name of Object.getOwnPropertyNames(def)) {
          var desc = Object.getOwnPropertyDescriptor(def, name);

          if (desc.get instanceof Function || desc.set instanceof Function) {
            Object.defineProperty(def, name, {
              value: $property(desc)
            });
          }
        }

        return def;
      },
      flatten: function (def) {
        /*  merge groups    */
        var tagGroups = _.pick(def, this.isTagGroup);

        var mergedTagGroups = _.object(_.flatten(_.map(tagGroups, function (membersDef, tag) {
          return _.map(this.flatten(this.convertPropertyAccessors(membersDef)), function (member, memberName) {
            return [memberName, $global[tag](member)];
          });
        }, this), true));

        var memberDefinitions = _.omit(def, this.isTagGroup);

        return _.extend(memberDefinitions, mergedTagGroups);
      },
      evalAlwaysTriggeredMacros: function (base) {
        return function (def) {
          var macros = $prototype.impl.alwaysTriggeredMacros;

          for (var i = 0, n = macros.length; i < n; i++) {
            def = macros[i](def, base) || def;
          }

          return def;
        };
      },
      evalMemberTriggeredMacros: function (base) {
        return function (def) {
          var names = $prototype.impl.memberNameTriggeredMacros,
              tags = $prototype.impl.tagTriggeredMacros;

          _.each(def, function (value, name) {
            if (names.hasOwnProperty(name)) {
              def = names[name](def, value, name, base) || def;
            }

            Meta.eachTag(value, function (tag) {
              if (tags.hasOwnProperty(tag)) {
                def = tags[tag](def, value, name, base) || def;
              }
            });
          });

          return def;
        };
      },
      evalPrototypeSpecificMacros: function (base) {
        return function (def) {
          if (!def.isTraitOf) {
            var macroTags = $untag(def.$macroTags || base && base.$definition && base.$definition.$macroTags);

            if (macroTags) {
              this.applyMacroTags(macroTags, def);
            }
          }

          return def;
        };
      },
      applyMacroTags: function (macroTags, def) {
        _.each(def, function (memberDef, memberName) {
          _.each(macroTags, function (macroFn, tagName) {
            memberDef = def[memberName];

            if (Meta.hasTag(memberDef, tagName)) {
              def[memberName] = macroFn.call(def, def, memberDef, memberName) || memberDef;
            }
          }, this);
        }, this);

        return def;
      },
      generateCustomCompilerImpl: function (base) {
        return function (def) {
          if (def.$impl) {
            def.$impl = _.extend(Object.create(base && base.$impl || this), def.$impl); // sets prototype to base.$impl || this

            def.$impl = $static($builtin($property(def.$impl)));
          } else if (base && base.$impl) {
            def.$impl = $static($builtin($property(base.$impl)));
          }

          return def;
        };
      },
      contributeTraits: function (base) {
        return function (def) {
          if (def.$traits) {
            var traits = def.$traits;
            this.mergeTraitsMembers(def, traits, base);
            def.$traits = $static($builtin($property(traits)));
            def.hasTrait = $static($builtin(function (Constructor) {
              return traits.indexOf(Constructor) >= 0;
            }));
          }

          return def;
        };
      },
      mergeTraitsMembers: function (def, traits, base) {
        _.each(traits, function (trait) {
          _.defaults(def, _.omit(trait.$definition, function (v, k) {
            return $builtin.is(v) || k === 'constructor';
          }));
        });
      },
      extendWithTags: function (def) {
        return _.extendWith($untag(def), _.object(_.map(Meta.tags(def), function (v, k) {
          return ['$' + k, $static(v)];
        })));
      },
      callStaticConstructor: function (def) {
        if (!def.isTraitOf) {
          _.each($untag(def.$traits), function (T) {
            if (T.$definition.$constructor) {
              $untag(T.$definition.$constructor).call(def);
            }
          });

          if (def.$constructor) {
            $untag(def.$constructor).call(def);
          }
        }

        return def;
      },
      generateConstructor: function (base) {
        return function (def) {
          return _.extend(def, {
            constructor: Meta.modify(def.hasOwnProperty('constructor') ? def.constructor : this.defaultConstructor(base), function (fn) {
              if (base) {
                fn.prototype = Object.create(base.prototype);
                fn.prototype.constructor = fn;
              }

              return fn;
            })
          });
        };
      },
      generateBuiltInMembers: function (base) {
        return function (def) {
          if (def.$constructor) {
            def.$constructor = $builtin($static(def.$constructor));
          }

          return _.defaults(def, {
            $base: $builtin($static($property(_.constant(base && base.prototype)))),
            $definition: $builtin($static($property(_.constant(_.extend({}, base && base.$definition, def))))),
            isTypeOf: $builtin($static(_.partial(_.isTypeOf, $untag(def.constructor)))),
            isInstanceOf: $builtin(function (constructor) {
              return _.isTypeOf(constructor, this);
            }),
            $: $builtin($prototype.impl.$)
          });
        };
      },
      $: function (fn) {
        return _.$.apply(null, [this].concat(_.asArray(arguments)));
      },
      defaultConstructor: function (base) {
        return base ? function () {
          base.prototype.constructor.apply(this, arguments);
        } : function (cfg) {
          _.extend(this, cfg || {});
        };
      },
      defineStaticMembers: function (def) {
        this.defineMembers($untag(def.constructor), _.pick(def, $static.is));
        return def;
      },
      defineInstanceMembers: function (def) {
        this.defineMembers($untag(def.constructor).prototype, _.omit(def, $static.is));
        return def;
      },
      defineMembers: function (targetObject, def) {
        _.each(def, function (value, key) {
          if (key !== 'constructor' && def.hasOwnProperty(key)) {
            this.defineMember(targetObject, value, key);
          }
        }, this);
      },
      defineMember: function (targetObject, def, key) {
        var tags = Meta.tags(def);

        if (tags.property) {
          (tags.memoized ? _.defineMemoizedProperty : _.defineProperty)(targetObject, key, def, tags.hidden ? {
            enumerable: false
          } : {});
        } else {
          try {
            Object.defineProperty(targetObject, key, {
              value: $untag(def),
              configurable: true,
              writable: true,
              enumerable: !tags.hidden
            });
          } catch (e) {
            console.log('Failed to define property', key, 'on', targetObject, 'with def =', def);
            console.log(e);
          }
        }
      },
      ensureFinalContracts: function (base) {
        return function (def) {
          if (base) {
            if (base.$final) {
              throw new Error('Cannot derive from $final-marked prototype');
            }

            if (base.$definition) {
              var invalidMembers = _.intersection(_.keys(_.pick(base.$definition, $final.is)), _.keys(def));

              if (invalidMembers.length) {
                throw new Error('Cannot override $final ' + invalidMembers.join(', '));
              }
            }
          }

          return def;
        };
      },
      expandAliases: function (def) {
        _.each(def, function (v, k) {
          def[k] = this.resolveMember(def, k, v)[1];
        }, this);

        return def;
      },
      resolveMember: function (def, name, member) {
        member = member || def[name];

        if ($alias.is(member)) {
          var ref = this.resolveMember(def, $untag(member));
          var refName = ref[0];
          var refValue = ref[1];
          return [refName, $property.is(member) ? $property({
            get: function () {
              return this[refName];
            },
            set: function (x) {
              this[refName] = x;
            }
          }) : Meta.replaceTags(refValue, _.omit(Meta.tags(member), 'alias'))];
        } else {
          return [name, member];
        }
      },
      groupMembersByTagForFastEnumeration: function (def) {
        var membersByTag = {};

        _.each(def, function (m, name) {
          Meta.eachTag(m, function (tag) {
            return (membersByTag[tag] = membersByTag[tag] || {})[name] = m;
          });
        });

        def.$membersByTag = $static($builtin($property(membersByTag)));
        return def;
      },
      isTagGroup: function (value_, key) {
        var value = $untag(value_);
        return key[0] === '$' && _.isFunction($global[key]) && _typeof(value) === 'object' && !_.isArray(value);
      },
      modifyMember: function (member, newValue) {
        return $property.is(member) && Meta.modify(member, function (value) {
          return _.extend(value, _.map2(_.pick(value, 'get', 'set'), newValue));
        }) || _.isFunction($untag(member)) && Meta.modify(member, newValue) || member;
      }
    }
  });
});
/*  $trait  A combinatoric-style alternative to inheritance.
            (also known as "mixin" in some languages)
    ======================================================================== */


_.withTest(['OOP', '$traits'], function () {
  var Closeable = $trait({
    close: function () {}
  });
  var Movable = $trait({
    move: function () {}
  });
  var Enumerable = $trait({
    each: function (iter) {},
    length: $property(function () {
      return 0;
    })
  });
  var JustCloseable = $prototype({
    $traits: [Closeable]
  });
  var MovableEnumerable = $prototype({
    $traits: [Movable, Enumerable],
    move: function () {}
  });
  var movableEnumerable = new MovableEnumerable();
  $assert(movableEnumerable.move === MovableEnumerable.prototype.move);
  $assertThrows(function () {
    new Closeable();
  }, _.matches({
    message: 'Traits are not instantiable (what for?)'
  }));
  $assertTypeMatches(movableEnumerable, {
    move: 'function',
    each: 'function',
    length: 'number'
  });
  $assert([movableEnumerable.isInstanceOf(Movable), movableEnumerable.isInstanceOf(Enumerable), movableEnumerable.isInstanceOf(Closeable)], [true, true, false]);
  $assert(Movable.isTypeOf(movableEnumerable));
  $assert(Movable.isTraitOf(movableEnumerable));
  $assert(MovableEnumerable.hasTrait(Enumerable));
  $assertMatches(MovableEnumerable, {
    $traits: [Movable, Enumerable]
  });
  $assertMatches(JustCloseable, {
    $traits: [Closeable]
  });
  $assertCallOrder(function (t1_constructed, t2_constructed, proto_constructed) {
    var T1, T2;
    $assertNotCalled(function (not_now) {
      T1 = $trait({
        $constructor: function () {
          not_now();
          t1_constructed();
        }
      });
      T2 = $trait({
        $constructor: function () {
          not_now();
          t2_constructed();
        }
      });
    });
    var Proto = $prototype({
      $traits: [T1, T2],
      $constructor: function () {
        proto_constructed();
      }
    });
  });
}, function () {
  _.isTraitOf = function (Trait, instance) {
    var constructor = instance && instance.constructor;
    return constructor && constructor.hasTrait && constructor.hasTrait(Trait) || false;
  }; //  indexOf is fast if has 1-2 traits,
  //  no need to pre-index


  _.isTypeOf = _.or(_.isTypeOf, _.isTraitOf);

  $global.$trait = function (arg1, arg2) {
    var constructor = undefined;

    var def = _.extend(arguments.length > 1 ? arg2 : arg1, {
      constructor: _.throwsError('Traits are not instantiable (what for?)'),
      isTraitOf: $static($builtin(function (instance) {
        return _.isTraitOf(constructor, instance);
      }))
    });

    return constructor = $prototype.impl.compile(def, arguments.length > 1 ? arg1 : arg2);
  };
});
/*  $macroTags
    ======================================================================== */


$prototype.macro('$macroTags', function (def, value, name) {
  _.each($untag(value), function (v, k) {
    Meta.globalTag(k);
  });
});
/*  Context-free implementation of this.$
    ======================================================================== */

_.$ = function (this_, fn) {
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }

  return args.length ? _.bind.apply(undefined, [fn, this_].concat(args)) : _.withSameArgs(fn, function () {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return fn.apply(this_, args);
  });
}; // @hide

/*  $const (xxx) as convenient alias for $static ($property (xxx))
    ======================================================================== */


_.withTest(['OOP', '$const'], function () {
  var A = $prototype({
    $const: {
      foo: 'foo',
      bar: 'bar'
    },
    qux: $const('qux'),
    zap: $const('zap')
  });
  $assert([A.foo, A.bar, A.qux, A.zap], ['foo', 'bar', 'qux', 'zap']);
  $assertThrows(function () {
    A.foo = 'bar ';
  });
}, function () {
  $global.$const = function (x) {
    return $static($property(x));
  };
});
/*  Dual call interface
    ======================================================================== */

/*  method  free function
 */


_.withTest(['OOP', '$callableAsFreeFunction'], function () {
  var X = $prototype({
    foo: $callableAsFreeFunction($property(function () {
      $assert(this._42, 42);
      return 42;
    }))
  }),
      x = new X({
    _42: 42
  });
  $assert(x.foo, X.foo(x), 42);
}, function () {
  /*  Impl
   */
  Meta.globalTag('callableAsFreeFunction');
  $prototype.macroTag('callableAsFreeFunction', function (def, value, name) {
    def.constructor[name] = $untag(value).asFreeFunction;
    return def;
  });
});
/*  free function  method
 */


_.withTest(['OOP', '$callableAsMethod'], function () {
  var X = $prototype({
    foo: $callableAsMethod(function (this_, _42) {
      $assert(this_._42, _42, 42);
      return 42;
    })
  }),
      x = new X({
    _42: 42
  });
  $assert(x.foo(42), X.foo(x, 42), 42);
}, function () {
  /*  Impl 
   */
  Meta.globalTag('callableAsMethod');
  $prototype.macroTag('callableAsMethod', function (def, value, name) {
    def[name] = Meta.modify(value, _.asMethod);
    def.constructor[name] = $untag(value);
    return def;
  });
});
/*  $singleton (a humanized macro to new ($prototype (definition)))
    ======================================================================== */


_.withTest(['OOP', '$singleton'], function () {
  $assertEveryCalledOnce(function (baseConstructor, derivedConstructor) {
    var Base = $prototype({
      method: _.constant(42)
    });
    /*  returns constructed instance of a definition passed as argument
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

    var Simple = $singleton({
      constructor: function () {
        baseConstructor();
      },
      method: function () {
        return 42;
      }
    });
    /*  can inherit from a prototype
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

    var Derived = $singleton(Base, {
      constructor: function () {
        derivedConstructor();
        Base.prototype.constructor.apply(this, arguments);
      }
    });
    $assert(Simple.method(), Derived.method(), 42);
  });
  /*  inner prototypes
      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

  var Outside = $singleton({
    Inside: $prototype({
      foo: function () {}
    })
  });
  $assertTypeMatches(new Outside.Inside().foo, 'function');
}, function () {
  /*  IMPLEMENTATION
      ==================================================================== */
  $global.$singleton = function (arg1, arg2) {
    return new ($prototype.apply(null, arguments))();
  };
});
},{"underscore":"node_modules/underscore/underscore.js"}],"node_modules/useless/base/infix/Set.js":[function(require,module,exports) {
"use strict";

var _ = require('underscore');
/*  Set extensions
    ======================================================================== */


_.deferTest('Set extensions', function () {
  var set = new Set([1, 2, 3]);
  $assert(set.copy !== set);
  $assert(set.asArray, set.copy.asArray, [1, 2, 3]);
  $assert(set.extend(new Set([4, 5])).asArray, [1, 2, 3, 4, 5]);
  $assert(set.extended(new Set([6, 7])).asArray, [1, 2, 3, 4, 5, 6, 7]);
  $assert(set.asArray, [1, 2, 3, 4, 5]);
  $assert(_.reject([7, 2, 3, 8], [2, 3].asSet.matches), [7, 8]);
}, function () {
  $mixin(Array, {
    asSet: $property(function () {
      return new Set(this);
    })
  });
  $mixin(Set, {
    copy: $property(function () {
      return new Set(this);
    }),
    asArray: $property(function () {
      return Array.from(this.values());
    }),
    matches: $property(function () {
      var self = this;
      return function (x) {
        return self.has(x);
      };
    }),
    extend: function (b) {
      for (var x of b) {
        this.add(x);
      }

      ;
      return this;
    },
    extended: function (b) {
      return this.copy.extend(b);
    }
  });
});
},{"underscore":"node_modules/underscore/underscore.js"}],"node_modules/useless/base/Promise+.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var _ = require('underscore'),
    O = Object;
/*  Promise-centric extensions (WIP) /// TODO: REFACTOR
    ======================================================================== */


_.tests['Promise+'] = {
  /*  ------------------------------------------------------------------------ */
  promisify: function () {
    /*  Example object  */
    var fs = {
      /*  Shouldn't be converted  */
      42: 42,
      dontTouchMe: function () {
        $assert(arguments.length === 0);
        return 42;
      },
      dontTouchMe2: function () {
        $assert(arguments.length === 0);
        return 42;
      },
      readFileSync: function () {
        $assert(arguments.length === 0);
        return 42;
      },

      /*  Will be promisified */
      readFile: function (path, callback) {
        $assert(this === fs);

        if (path) {
          callback(null, 'contents of ' + path);
        } else {
          callback('path empty');
        }
      }
    };
    /*  Run     */

    var fsAsync = Function.promisifyAll(fs, {
      except: _.endsWith.$$('Sync').or(['dontTouchMe', 'dontTouchMe2'].asSet.matches)
    });
    /*  Check if 'except' worked successfully */

    $assert(fsAsync.dontTouchMe(), fsAsync.dontTouchMe2(), fsAsync.readFileSync(), fsAsync['42'], 42);
    /*  Check if 'readFile' converted successfully */

    return __.all([fsAsync.readFile(null).assertRejected('path empty'), fsAsync.readFile('foo').assert('contents of foo')]);
  },

  /*  ------------------------------------------------------------------------ */
  __: function () {
    var adds = function (a, b) {
      return function (x, y) {
        return [x + a, y + b];
      };
    };

    return [__(123).assert(123), __(Promise.resolve(123)).assert(123), __(function () {
      return 123;
    }).assert(123), __(function () {
      throw 123;
    }).assertRejected(123), __(adds('foo', 'bar'), 123, 456).assert(['123foo', '456bar'])];
  },
  firstResolved: function () {
    return [Promise.firstResolved([Promise.reject(123), Promise.resolve(456)]).assert(456), Promise.firstResolved([Promise.reject(123), Promise.reject(456)]).assertRejected(null), Promise.firstResolved([]).assertRejected(null)];
  },
  'aborting __.sleep': function () {
    return [__.sleep(1).abort().assertRejected('aborted'), __.sleep(1).then(function () {
      throw new Error("shouldn't happen");
    }).catch(function (e) {
      $assert(e, 'aborted');
    }).abort().assertRejected('aborted')];
  },
  'firstResolved: finalize semantics': function () {
    var timeouts = [30, 5, 10, 20];
    var resolved = [];
    var rejected = [];
    var promises = timeouts.map(function (t) {
      return __.sleep(t).then(function () {
        resolved.push(t);
        return t;
      }).catch(function (e) {
        rejected.push(t);
        return t;
      });
    });
    return Promise.firstResolved(promises).assert(5).sleep(50).then(function () {
      $assert(resolved, [5]);
      $assert(rejected, [30, 10, 20]);
    });
  },

  /*  ------------------------------------------------------------------------ */
  all: function () {
    return [__.all([123, 456]).assert([123, 456]), __.all([_.constant(123), _.constant(456)]).assert([123, 456]), __.all([Promise.resolve(123), Promise.resolve(456)]).assert([123, 456])];
  },

  /*  ------------------------------------------------------------------------ */
  seq: function () {
    $assert(__.seq(123), 123);
    $assert(__.seq([123, 333]), 333);
    $assert(__.seq(123, 333), 333);
    $assert(__.seq([123, _.constant(333)]), 333);
    $assert(__.seq([_.constant(333)]), 333);
    return [__.seq([Promise.resolve(123), Promise.resolve(333)]).assert(333), __.seq([123, __.constant(333)]).assert(333), __.seq([123, __.rejects('foo')]).assertRejected('foo'), __.seq([123, __.delays(0), _.appends('bar')]).assert('123bar')];
  },

  /*  ------------------------------------------------------------------------ */
  map: function () {
    return [__.map(111, _.appends('bar')).assert('111bar'), __.map([222], _.appends('bar')).assert(['222bar']), __.map(__(333), _.appends('bar')).assert('333bar'), __.map({
      foo: 444
    }, _.appends('bar')).assert({
      foo: '444bar'
    }), __.map({
      foo: 555
    }, __.constant('bar')).assert({
      foo: 'bar'
    }), __.map({
      foo: Promise.resolve(111),
      bar: Promise.resolve(222)
    }).assert({
      foo: 111,
      bar: 222
    }), __.map(['a', 'b', 'c', 'd', 'e'], function (x, i) {
      return Promise.resolve([i, x]).delay(10 - i);
    }).assert([[0, 'a'], [1, 'b'], [2, 'c'], [3, 'd'], [4, 'e']])];
  },

  /*  ------------------------------------------------------------------------ */
  filter: function () {
    return [__.filter(123, _.constant(456)).assert(456), __.filter(['foo', 456], _.isString).assert(['foo']), __.filter(['foo', 456], __.constant('baz')).assert(['baz', 'baz']), __.filter({
      foo: 123,
      bar: '456'
    }, _.isNumber).assert({
      foo: 123
    })];
  },

  /*  ------------------------------------------------------------------------ */
  each: function () {
    var pairs = function (input) {
      var pairs = [];
      return __.each(input, function (x, i) {
        pairs.push([x, i]);
      }).then(_.constant(pairs));
    };

    return [pairs().assert([]), pairs(undefined).assert([]), pairs(42).assert([[42, undefined]]), pairs([42, 48]).assert([[42, 0], [48, 1]]), pairs({
      0: 42,
      1: 48
    }).assert([[42, '0'], [48, '1']]), __.each([1, 2], function (x, i) {
      if (i > 0) $fail; // should stop at 0, due to rejection

      return Promise.reject('foo');
    }).assertRejected('foo')];
  },

  /*  ------------------------------------------------------------------------ */
  'each + break': function _callee2() {
    var log, a, b, c, d;
    return regeneratorRuntime.async(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            log = [];

            a = function () {
              log.push('a');
            };

            b = function _callee() {
              return regeneratorRuntime.async(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      _context.next = 2;
                      return regeneratorRuntime.awrap(__.sleep(1));

                    case 2:
                      log.push('b');

                    case 3:
                    case "end":
                      return _context.stop();
                  }
                }
              }, null, null, null, Promise);
            };

            c = function () {
              log.push('c');
              return 42;
            }; // breaks here


            d = function () {
              log.push('d');
            }; // will not be executed


            _context2.next = 7;
            return regeneratorRuntime.awrap(__.each([a, b, c], function (fn, i, break_) {
              return __.then(fn, function (x) {
                if (x === 42) break_();
              });
            }));

          case 7:
            $assert(log, ['a', 'b', 'c']);

          case 8:
          case "end":
            return _context2.stop();
        }
      }
    }, null, null, null, Promise);
  }
  /*  END OF TESTS ----------------------------------------------------------- */

};
/*  IMPLEMENTATION
    ======================================================================== */

$global.TimeoutError = /*#__PURE__*/function (_Error) {
  _inherits(_class, _Error);

  var _super = _createSuper(_class);

  function _class() {
    _classCallCheck(this, _class);

    return _super.call(this, 'timeout expired');
  }

  return _class;
}( /*#__PURE__*/_wrapNativeSuper(Error));
/*  ------------------------------------------------------------------------ */


$global.__ = Promise.eval = function (x) {
  var _this = this;

  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return x instanceof Promise ? x : x instanceof Function ? new Promise(function (resolve) {
    resolve(x.apply(_this, args));
  }) : // @hide
  Promise.resolve(x);
};

Promise.coerce = function (x) {
  return x instanceof Promise ? x : Promise.resolve(x);
};
/*  ------------------------------------------------------------------------ */


__.noop = function () {
  return Promise.resolve();
};

__.eternity = new Promise(function () {});

__.identity = function (x) {
  return Promise.resolve(x);
};

__.constant = function (x) {
  return function () {
    return Promise.resolve(x);
  };
};

__.reject = function (e) {
  return Promise.reject(e);
};

__.rejects = function (e) {
  return function () {
    return Promise.reject(e);
  };
};
/*  ------------------------------------------------------------------------ */


__.then = function (a, b) {
  b = _.coerceToFunction(b);

  try {
    var x = a instanceof Function ? a() : a;
    return x instanceof Promise ? x.then(b) : b(x);
  } // @hide
  catch (e) {
    return Promise.reject(e);
  }
};
/*  ------------------------------------------------------------------------ */

/*  ------------------------------------------------------------------------ */


__.delay = function (ms) {
  return __.delays(ms)();
};

__.delays = function () {
  var ms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  return function (x) {
    var abort;
    var p = new Promise(function (resolve, reject) {
      var timeout = setTimeout(function () {
        return resolve(x);
      }, ms);

      abort = function () {
        var why = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'aborted';
        return clearTimeout(timeout), reject(why);
      };
    });
    return p.abortableWith(abort);
  };
};

__.sleep = __.delay;
__.sleeps = __.delays;
$mixin(Promise, {
  sleep: $alias('delay'),
  delay: function (ms) {
    return this.then(__.delays(ms));
  },
  timeout: function (ms) {
    return ms === undefined ? this : this.race(__.delay(ms).reject(new TimeoutError()));
  },
  now: $property(function () {
    return this.timeout(0);
  })
});
/*  ------------------------------------------------------------------------ */

$mixin(Array, {
  race: $property(function () {
    return Promise.race(this);
  })
});
/*  ------------------------------------------------------------------------ */

$mixin(Promise, {
  race: function (other) {
    return [this, other].race;
  },
  abortableWith: function (abort) {
    var _this2 = this;

    var _then = this.then.bind(this),
        _catch = this.catch.bind(this);

    return O.assign(this, {
      // propagate .abort to derived promises
      abort: function () {
        return abort(), _this2;
      },
      then: function () {
        return _then.apply(void 0, arguments).abortableWith(abort);
      },
      catch: function () {
        return _catch.apply(void 0, arguments).abortableWith(abort);
      }
    });
  },
  firstResolved: $static(function (arr) {
    return new Promise(function (resolve, reject) {
      var todo = arr && arr.length;

      var abortOthers = function (resolvedOne) {
        return _.each(arr, function (p) {
          return p !== resolvedOne && p && p.abort && p.abort();
        });
      };

      if (!todo) {
        reject(null);
      } else {
        _.each(arr, function (p) {
          Promise.coerce(p).then(function (x) {
            todo--;

            if (resolve) {
              abortOthers(p);
              resolve(x);
              resolve = undefined;
            }
          }).catch(function () {
            todo--;

            if (!todo) {
              reject(null);
            }
          });
        });
      }
    });
  }),
  reject: function (e) {
    return this.then(_.throwsError(e));
  },
  chain: function (fn) {
    return this.then(function (x) {
      fn(x);
      return x;
    });
  },
  done: function (fn) {
    return this.then(function (x) {
      fn(null, x);
      return x;
    }, function (e) {
      fn(e, null);
      throw e;
    });
  },
  finally: function (fn) {
    return this.then(function (x) {
      return fn(null, x);
    }, function (e) {
      return fn(e, null);
    });
  },
  $callableAsFreeFunction: {
    $property: {
      reflect: function () {
        return this.then(function (v) {
          return v;
        }, function (e) {
          return e;
        });
      }
    }
  },

  /*state: $property (function () {
                      return this.then (
                          function (x) { return { state: 'fulfilled', fulfilled: true, value: x } },
                          function (e) { return { state: 'rejected', rejected: true, value: x } }).now.catch (function () {
                                         return { state: 'pending', pending: true } }) }),*/
  log: $property(function () {
    return this.then(log, log.then(_.throwsError));
  }),
  panic: $property(function () {
    return this.catch(function (e) {
      if (_.globalUncaughtExceptionHandler) {
        _.globalUncaughtExceptionHandler(e);
      }

      throw e;
    });
  }),
  assert: function (desired) {
    return this.then(function (x) {
      $assert(x, desired);
      return x;
    });
  },
  assertTypeMatches: function (desired) {
    return this.then(function (x) {
      $assertTypeMatches(x, desired);
      return x;
    });
  },
  assertRejected: function (desired) {
    var check = arguments.length > 0;
    return this.catch(function (x) {
      if (check) {
        $assert(x, desired);
      }

      return x;
    });
  }
});
/*  ------------------------------------------------------------------------ */

_.deferTest(['Promise+', '_.scatter with pooling'], function () {
  var data = _.times(21, function (i) {
    return 'item_' + i;
  });

  var numItems = 0;
  var processedItems = [];

  var op = function (item, i) {
    numItems++;
    $assert(!processedItems.contains(item));
    return __.delay(_.random(2)).then(function () {
      processedItems.push(item);
      return item;
    });
  };

  return __.scatter(data, op, {
    maxConcurrency: 5
  }).then(function () {
    $assert(_.difference(data, processedItems).isEmpty);
  });
},
/*  ------------------------------------------------------------------------ */
function () {
  $global.TaskPool = $prototype({
    constructor: function (cfg) {
      this.maxTime = cfg && cfg.maxTime;
      this.pending = [];

      if (this.maxConcurrency = cfg && cfg.maxConcurrency) {
        this.numActive = 0;
        this.queue = [];
      }
    },
    run: function (task) {
      var self = this;

      if (this.numActive >= this.maxConcurrency) {
        // queue task
        return new Promise(function (resolve) {
          self.queue.push(function () {
            return self.run(task).then(resolve);
          });
        });
      } else {
        // execute task
        var p = __(task);

        if (this.maxTime !== undefined) {
          p = p.timeout(this.maxTime);
        }

        if (this.maxConcurrency !== undefined) {
          // if queueing, wait until complete and pop next task
          self.numActive++;
          p = p.then(function (x) {
            self.numActive--;
            return self.queue.length && self.numActive < self.maxConcurrency ? self.queue.shift()().then(_.constant(x)) : x;
          });
        }

        this.pending.push(p);
        return p;
      }
    },
    all: $property(function () {
      return Promise.all(this.pending);
    })
  }); // @hide

  /*  ------------------------------------------------------------------------ */

  __.scatter = function (x, fn, cfg
  /* { maxConcurrency, maxTime } */
  ) {
    return __.then(x, function (x) {
      if (_.isStrictlyObject(x)) {
        var result = _.coerceToEmpty(x),
            tasks = new TaskPool(cfg);

        _.each2(x, function (v, k) {
          tasks.run(fn.$(v, k, x)).then(function (vk) {
            if (vk) {
              result[vk[1]] = vk[0];
            }
          });
        });

        return tasks.all.then(_.constant(result));
      } else {
        return __(fn, x, undefined, x).then(function (vk) {
          return vk[0];
        });
      }
    });
  };
});
/*  ------------------------------------------------------------------------ */


__.map = function (x, fn, cfg
/* { maxConcurrency, maxTime } */
) {
  fn = fn || _.identity;
  return __.scatter(x, function (v, k, x) {
    return __.then(fn.$(v, k, x), function (x) {
      return [x, k];
    });
  }, cfg);
};

__.parallelEach = __.map;

__.filter = function (x, fn, cfg
/* { maxConcurrency, maxTime } */
) {
  return __.scatter(x, function (v, k, x) {
    return __.then(fn.$(v, k, x), function (decision) {
      return decision === false ? undefined : decision === true ? [v, k] : [decision, k];
    });
  }, cfg);
};

__.each = function (obj, fn) {
  return __.then(obj, function (obj) {
    return new Promise(function (complete, whoops) {
      _.cps.each(obj, function (x, i, then, break_) {
        Promise.coerce(fn(x, i, break_)) // @hide
        .then(then).catch(whoops);
      }, complete);
    });
  });
};

__.seq = function () {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  return _.reduce2(undefined, args.length > 1 ? args : args[0], __.then);
};

__.all = function (arr) {
  return Promise.all(_.map(arr, __));
}; // @hide


__.race = function (arr) {
  return Promise.race(_.map(arr, __));
}; // @hide

/*  ------------------------------------------------------------------------ */


var _loop = function (fn) {
  fn.configure = function (Cfg) {
    return function (x, op, cfg) {
      return fn(x, op, Object.assign({}, Cfg, cfg));
    };
  };

  fn.maxConcurrency = function (n) {
    return fn.configure({
      maxConcurrency: n
    });
  };

  fn.maxTime = function (n) {
    return fn.configure({
      maxTime: n
    });
  };
};

for (var fn of [__.map, __.filter]) {
  _loop(fn);
}
/*  ------------------------------------------------------------------------ */


$mixin(Function, {
  promisifyAll: $static(function (obj, cfg) {
    var cfg = cfg || {},
        except = cfg.except || _.noop;

    if (except instanceof Array) {
      except = except.asSet.matches;
    }

    var result = {};

    for (var k in obj) {
      var x = obj[k];

      if (x instanceof Function) {
        var fn = x.bind(obj);
        result[k] = except(k) ? fn : fn.promisify;
      } else {
        result[k] = x;
      }
    }

    return result;
  }),
  promisify: $hidden($property(function () {
    var f = this;
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        // @hide
        f.apply(self, _.asArray(args).concat(function (err, what) {
          if (err) {
            reject(err);
          }

          resolve(what);
        }));
      });
    };
  }))
});
},{"underscore":"node_modules/underscore/underscore.js"}],"node_modules/useless/base/Channel.js":[function(require,module,exports) {
"use strict";

var _ = require('underscore');
/*  ------------------------------------------------------------------------ */


_.tests['Channel'] = {
  'is promise': function () {
    $assert(new Channel() instanceof Promise);
  },
  'resolve from constructor + then + chanining': function (done) {
    new Channel(function (resolve) {
      resolve(123);
    }).then(function (x) {
      $assert(x, 123);
      return 456;
    }, function () {
      $fail;
    }).then(function (y) {
      $assert(y, 456);
      done();
    });
  },
  'reject from constructor': function (done) {
    new Channel(function (resolve, reject) {
      reject(123);
    }).then(function () {
      $fail;
    }, function (x) {
      $assert(x, 123);
      done();
    });
  },
  'throw from constructor + .catch + chanining': function (done) {
    new Channel(function (resolve, reject) {
      throw 'foo';
    }).then(function () {
      $fail;
    }).catch(function (x) {
      $assert(x, 'foo');
      return 'bar';
    }).then(function (y) {
      $assert(y, 'bar');
      done();
    }, function () {
      $fail;
    });
  },
  'throw from .then': function (done) {
    new Channel(123).then(function (x) {
      throw x + 1;
    }).catch(function (x) {
      $assert(x, 124);
      done();
    });
  },
  'pending state': function () {
    $assert('pending', new Channel().then(function () {
      return $fail;
    }).state);
  },
  'new Channel (const)': function () {
    return new Channel(123).assert(123);
  },
  'recognized by tests as Promise': function () {
    return Channel.resolve(123).assert(123);
  },
  'accepted by Promise.all': function () {
    return Promise.all([Channel.resolve(123).assert(123), Channel.reject(456).assertRejected(456)]).assert([123, 456]);
  },
  'returning channel from then + .resolve': function () {
    var x = Channel.resolve(123),
        y = undefined,
        calls = [];
    x.then(function () {
      return y = new Channel(456);
    }).then(function (x) {
      return calls.push(x);
    }); // should call twice, with 456 and 789 (later)

    y.resolve(789);
    $assert(calls, [456, 789]);
  },
  '$channel for $prototype': function () {
    var Model = $prototype({
      numPersons: $channel()
    });
    var View = $prototype({
      label: $channel()
    });
    /*  $channel tag creates a readwrite property with same name,
        but it should keep $channel tag in meta-information (for reflection purposes)   */

    $assert($channel.is(Model.$definition.numPersons));
    /*  Should be configurable from constructor params  */

    var model = new Model({
      numPersons: 10
    }),
        view = new View();
    $assert(model.numPersons.value, 10);
    $assert(view.label.state, 'pending');
    /*  This is not a simple by-reference assignment, but a channel binding   */

    view.label = model.numPersons.then(function (x) {
      return x + ' persons';
    });
    $assert(view.label !== model.numPersons);
    $assert(view.label.value, '10 persons');
    /*  Assignment to a non-promise should update value    */

    model.numPersons = 11;
    $assert(view.label.value, '11 persons');
  },
  '$channel(const)': function () {
    $assert($singleton({
      count: $channel(7)
    }).count.value, 7);
  },
  'resolve/reject returns this': function () {
    $assert(Channel.resolve(123).resolve(555).resolve(666).value, 666);
  }
  /*'proxy shit works': () => {
       var Channel = class extends Function {
           constructor (fn, transducers, before) {
               super ()
               this.after = []
              this.state = 'pending'
              this.value = undefined
              this.transducers = {
                      resolve: (transducers && transducers.resolve) || (x => x),
                      reject:  (transducers && transducers.reject)  || (e => { throw e }) }
               if (fn instanceof Function) {
                  try {
                      fn.call (this,
                          this.resolve.bind (this),
                          this.reject.bind (this)) }
                   catch (e) {
                      this.reject (e) } }
               else if (fn !== undefined) {
                  this.resolve (fn) } }
           _resolve (x) {
                      this.state = 'resolved'
                      this.value = x
                      this.after.forEach (c => c.resolve (x)) }
           _reject (e) {
                      this.state = 'rejected'
                      this.value = e
                      this.after.forEach (c => c.reject (e)) }
           resolve (x, transducer) {
                       try {
                          x = (transducer || this.transducers.resolve) (x)
                           if (x instanceof Promise) {
                              x.then (
                                  x => this._resolve (x),
                                  e => this._reject (e)) }
                           else {
                              this._resolve (x) } }
                              
                      catch (e) {
                          this._reject (e) }
                       return this }
           reject (e) {
                      return this.resolve (e, this.transducers.reject) }
           then (resolve, reject) {
                   var c = new Channel (undefined, { resolve: resolve, reject: reject }, this)
                   this.after.push (c)
                   if (this.state === 'resolved') {
                      c.resolve (this.value) }
                   else if (this.state === 'rejected') {
                      c.reject (this.value) }
                   return c }
           catch (fn) {
                  
                  return this.then (undefined, fn) } }
       var props = {}
       for (var key of Object.keys(Promise.prototype)) {
          if (!Channel.prototype.hasOwnProperty (key)) {
              props[key] = Object.getOwnPropertyDescriptor (Promise.prototype, key) } }
       Object.defineProperties (Channel.prototype, props);
       Channel = new Proxy (Channel, {
           construct: function (OriginalChannel, args, newTarget) {
             
             var proxy = new Proxy (new OriginalChannel (args[0], args[1], args[2]), {
                  
                  apply: function (chan, thisArg, args) {
                       if (args[0] instanceof Function) {
                          return chan.then.apply (chan, args) }
                      else {
                          chan.resolve.apply (chan, args)
                          return proxy } },
                   getPrototypeOf: function () {
                      return Promise.prototype } })
               return proxy } })
       var foo = new Channel (7)
       $assert (foo instanceof Promise) // is Promise
      $assert (foo (5).value, 5)       // is Function
       $assert (foo.delay, Promise.prototype.delay)
       return Promise.all ([foo, Promise.resolve (10)]).then (function (x) {
          $assert (x, [5, 10]) })
  },*/

};
/*  ------------------------------------------------------------------------ */

$global.Channel = $extends(Promise, {
  constructor: function (fn, transducers, before) {
    this.after = [];
    this.state = 'pending';
    this.value = undefined;
    this.transducers = {
      resolve: transducers && transducers.resolve || function (x) {
        return x;
      },
      reject: transducers && transducers.reject || function (e) {
        throw e;
      }
    };

    if (fn instanceof Function) {
      try {
        fn.call(this, this.$(this.resolve), this.$(this.reject));
      } catch (e) {
        this.reject(e);
      }
    } else if (fn !== undefined) {
      this.resolve(fn);
    }
  },
  _resolve: function (x) {
    this.state = 'resolved';
    this.value = x;
    this.after.forEach(function (c) {
      return c.resolve(x);
    });
  },
  _reject: function (e) {
    this.state = 'rejected';
    this.value = e;
    this.after.forEach(function (c) {
      return c.reject(e);
    });
  },
  resolve: function (x, transducer) {
    var _this = this;

    try {
      x = (transducer || this.transducers.resolve)(x);

      if (x instanceof Promise) {
        x.then(function (x) {
          return _this._resolve(x);
        }, function (e) {
          return _this._reject(e);
        });
      } else {
        this._resolve(x);
      }
    } catch (e) {
      this._reject(e);
    }

    return this;
  },
  reject: function (e) {
    return this.resolve(e, this.transducers.reject);
  },
  then: function (resolve, reject) {
    var c = new Channel(undefined, {
      resolve: resolve,
      reject: reject
    }, this);
    this.after.push(c);

    if (this.state === 'resolved') {
      c.resolve(this.value);
    } else if (this.state === 'rejected') {
      c.reject(this.value);
    }

    return c;
  },
  catch: function (fn) {
    return this.then(undefined, fn);
  }
});
/*  ------------------------------------------------------------------------ */

Channel.all = function (arr) {
  return new Channel(function (resolve) {
    var complete = new Set(),
        value = new Array(arr.length);
    arr.forEach(function (c, i) {
      c.then(function (x) {
        value[i] = x;

        if (complete.length === value.length) {
          resolve(value);
        } else {
          complete.add(i);
        }
      });
    });
  });
};
/*  ------------------------------------------------------------------------ */


Channel.resolve = function (x) {
  return new Channel(function (resolve) {
    return resolve(x);
  });
};

Channel.reject = function (e) {
  return new Channel(function (resolve, reject) {
    return reject(e);
  });
};
/*  ------------------------------------------------------------------------ */


$prototype.macroTag('channel', function (def, value, name) {
  var memberName = '_' + name;
  var initialValue = $untag(value);
  def[name] = Meta.modify(value, function () {
    return $property({
      get: function () {
        return this[memberName] || (this[memberName] = new Channel(initialValue));
      },
      set: function (x) {
        this[name].resolve(x);
      }
    });
  });
});
/*  ------------------------------------------------------------------------ */
},{"underscore":"node_modules/underscore/underscore.js"}],"node_modules/useless/base/Parse.js":[function(require,module,exports) {
"use strict";

var _ = require('underscore');
/*  Parsers (TODO: REFACTOR)
    ======================================================================== */


_.tests.parse = {
  fileName: function () {
    $assert(Parse.fileName(''), '');
    $assert(Parse.fileName('.jpg'), '');
    $assert(Parse.fileName('c:\\/path/path2/.jpg'), '');
  }
};
$global.Parse = {
  keyCodeAsString: function (key) {
    return String.fromCharCode(96 <= key && key <= 105 ? key - 48 : key);
  },
  fileName: function (path) {
    return _.last(path.split(/\\|\//)).split('.')[0];
  }
};
},{"underscore":"node_modules/underscore/underscore.js"}],"node_modules/useless/base/Sort.js":[function(require,module,exports) {
"use strict";

var _ = require('underscore');

$global.Sort = {
  Ascending: 1,
  Descending: -1,
  strings: function (a, b) {
    a = $.trim(a).toLowerCase();
    b = $.trim(b).toLowerCase();

    if (a.length == 0 && b.length > 0) {
      return 1;
    } else if (a.length > 0 && b.length == 0) {
      return -1;
    } else {
      return a == b ? 0 : a < b ? -1 : 1;
    }
  },
  numbers: function (a, b) {
    if (isNaN(a) && isNaN(b)) {
      return 0;
    } else if (isNaN(a)) {
      return -1;
    } else if (isNaN(b)) {
      return 1;
    } else {
      return a < b ? -1 : a > b ? 1 : 0;
    }
  },
  generic: function (a, b) {
    if (!a && !b) {
      return 0;
    } else if (!a) {
      return -1;
    } else if (!b) {
      return 1;
    } else {
      return a < b ? -1 : a > b ? 1 : 0;
    }
  },
  inverse: function (sort) {
    return function (a, b) {
      return -sort(a, b);
    };
  },
  field: function (name, sort, order) {
    return function (a, b) {
      return sort(a[name], b[name]) * order;
    };
  }
};
},{"underscore":"node_modules/underscore/underscore.js"}],"node_modules/useless/base/concurrency.js":[function(require,module,exports) {
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _ = require('underscore');
/*  Unit test / documentation / specification / how-to.
    ======================================================================== */


_.tests.concurrency = {
  'scope': function (testDone) {
    var releases = [],
        acquires = [],
        count = 10;
    var method = $scope(function (release, id, then) {
      acquires.push(id);

      _.delay(function () {
        release(function () {
          releases.push(id);
          if (then) then();
        });
      }, 10);
    });
    method(42, function ()
    /* released */
    {
      $assert(count + 1, acquires.length, releases.length);
      $assert(acquires, releases.reversed);
      testDone();
    });

    _.times(count, function () {
      method(_.random(1000));
    });
  },
  'interlocked': function () {
    var isNowRunning = false;

    var op = _.interlocked(function (item, i) {
      $assert(!isNowRunning);
      isNowRunning = true;
      return __.delay(_.random(2)).then(function () {
        isNowRunning = false;
      });
    });

    return __.scatter(_.times(15, String.randomHex), op, {
      maxConcurrency: 10
    });
  }
};
/*  Mutex/lock (now supports stand-alone operation, and it's re-usable).
 */

$global.Lock = /*#__PURE__*/function () {
  function _class() {
    _classCallCheck(this, _class);
  }

  _createClass(_class, [{
    key: "acquire",
    value: function acquire(then) {
      var _this = this;

      this.wait(function () {
        if (!_this.waitQueue) {
          _this.waitQueue = [];
        }

        then();
      });
    }
  }, {
    key: "acquired",
    value: function acquired() {
      return this.waitQueue !== undefined;
    }
  }, {
    key: "wait",
    value: function wait(then) {
      if (this.acquired()) {
        this.waitQueue.push(then);
      } else {
        then();
      }
    }
  }, {
    key: "release",
    value: function release() {
      if (this.waitQueue.length) {
        var queueFirst = this.waitQueue[0];
        this.waitQueue = this.waitQueue.slice(1);
        queueFirst();
      } else delete this.waitQueue;
    }
  }]);

  return _class;
}();

_.interlocked = function (fn) {
  var lock = new Lock(),
      fn = $untag(fn);
  return _.extendWith({
    lock: lock,
    wait: lock.wait.bind(lock)
  }, function () {
    var _this2 = this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return new Promise(function (resolve) {
      lock.acquire(function () {
        __.then(fn.apply(_this2, args), function (x) {
          lock.release();
          resolve(x);
        });
      });
    });
  });
};
/*  EXPERIMENTAL (TBD)
 */


$global.$scope = function (fn) {
  var releaseStack = undefined;
  return _.argumentPrependingWrapper(Meta.unwrap(fn), function (
  /* acquire */
  fn) {
    var released = {
      when: undefined
    };
    (releaseStack = releaseStack || []).push(released);
    fn(function (
    /* release */
    then) {
      if (released.when) throw new Error('$scope: release called twice');
      released.when = then;

      while (releaseStack && releaseStack.last && releaseStack.last.when) {
        var trigger = releaseStack.last.when;

        if ((releaseStack = _.initial(releaseStack)).isEmpty) {
          releaseStack = undefined;
        }

        trigger();
      }
    });
  });
};
},{"underscore":"node_modules/underscore/underscore.js"}],"node_modules/toposort/index.js":[function(require,module,exports) {

/**
 * Topological sorting function
 *
 * @param {Array} edges
 * @returns {Array}
 */

module.exports = exports = function(edges){
  return toposort(uniqueNodes(edges), edges)
}

exports.array = toposort

function toposort(nodes, edges) {
  var cursor = nodes.length
    , sorted = new Array(cursor)
    , visited = {}
    , i = cursor

  while (i--) {
    if (!visited[i]) visit(nodes[i], i, [])
  }

  return sorted

  function visit(node, i, predecessors) {
    if(predecessors.indexOf(node) >= 0) {
      throw new Error('Cyclic dependency: '+JSON.stringify(node))
    }

    if (!~nodes.indexOf(node)) {
      throw new Error('Found unknown node. Make sure to provided all involved nodes. Unknown node: '+JSON.stringify(node))
    }

    if (visited[i]) return;
    visited[i] = true

    // outgoing edges
    var outgoing = edges.filter(function(edge){
      return edge[0] === node
    })
    if (i = outgoing.length) {
      var preds = predecessors.concat(node)
      do {
        var child = outgoing[--i][1]
        visit(child, nodes.indexOf(child), preds)
      } while (i)
    }

    sorted[--cursor] = node
  }
}

function uniqueNodes(arr){
  var res = []
  for (var i = 0, len = arr.length; i < len; i++) {
    var edge = arr[i]
    if (res.indexOf(edge[0]) < 0) res.push(edge[0])
    if (res.indexOf(edge[1]) < 0) res.push(edge[1])
  }
  return res
}

},{}],"node_modules/useless/base/math.js":[function(require,module,exports) {
"use strict";

var _ = require('underscore');
/*  TODO:   UNIT TEST DAT MUTHAFUCKA
 */

/*  TODO:   get rid of _ namespace (now legacy)
 */


Math.clamp = _.clamp = function (n, min, max) {
  return Math.max(min, Math.min(max, n));
};

Math.lerp = _.lerp = function (t, min, max) {
  return min + (max - min) * t;
};

Math.rescale = _.rescale = function (v, from, to, opts) {
  var unit = (v - from[0]) / (from[1] - from[0]);
  return _.lerp(opts && opts.clamp ? _.clamp(unit, 0, 1) : unit, to[0], to[1]);
};

Math.rescaleClamped = _.rescaleClamped = function (v, from, to) {
  return _.rescale(v, from, to, {
    clamp: true
  });
};

Math.sqr = _.sqr = function (x) {
  return x * x;
};
/*  Math.sign (missing from Safari)
    ======================================================================== */


if (!Math.sign) {
  Math.sign = function (x) {
    return x < 0 ? -1 : x > 0 ? 1 : 0;
  };
}
/*  Intersections (draft)
    ======================================================================== */


$global.Intersect = {
  rayCircle: function (origin, d, center, r) {
    var f = origin.sub(center);
    var a = d.dot(d);
    var b = 2.0 * f.dot(d);
    var c = f.dot(f) - r * r;
    var discriminant = b * b - 4.0 * a * c;

    if (discriminant < 0) {
      return undefined;
    } else {
      discriminant = Math.sqrt(discriminant);
      var t1 = (-b - discriminant) / (2.0 * a);
      var t2 = (-b + discriminant) / (2.0 * a);

      if (t1 >= 0 && t1 <= 1) {
        return {
          time: t1,
          where: origin.add(d.scale(t1))
        };
      }

      if (t2 >= 0 && t2 <= 1) {
        return {
          time: t2,
          where: origin.add(d.scale(t2)),
          insideOut: true
        };
      }

      return undefined;
    }
  }
};
/*  TODO: Vec1, for consistency with arity-abstract vector algorithms
    ======================================================================== */

/*  2-dimensional vector
    ======================================================================== */

$global.Vec2 = $prototype({
  $static: {
    xx: function (x) {
      return new Vec2(x, x);
    },
    xy: function (x, y) {
      return new Vec2(x, y);
    },
    x: function (x) {
      return new Vec2(x, 0);
    },
    y: function (y) {
      return new Vec2(0, y);
    },
    zero: $property(function () {
      return new Vec2(0, 0);
    }),
    unit: $property(function () {
      return new Vec2(1, 1);
    }),
    one: $alias('unit'),
    lt: $alias('fromLT'),
    wh: $alias('fromWH'),
    fromLT: function (lt) {
      return lt && new Vec2(lt.left, lt.top);
    },
    fromWH: function (wh) {
      return wh && new Vec2(wh.width, wh.height);
    },
    fromLeftTop: $alias('fromLT'),
    fromWidthHeight: $alias('fromWH'),
    lerp: function (t, a, b) {
      return new Vec2(_.lerp(t, a.x, b.x), _.lerp(t, a.y, b.y));
    },
    clamp: function (n, a, b) {
      return new Vec2(_.clamp(n.x, a.x, b.x), _.clamp(n.y, a.y, b.y));
    },
    random: $property(function () {
      return new Vec2(Math.random(), Math.random());
    })
  },
  constructor: function (x, y) {
    if (arguments.length === 1) {
      if (_.isNumber(x)) {
        this.x = this.y = x;
      } else {
        this.x = x.x;
        this.y = x.y;
      }
    } else {
      this.x = x;
      this.y = y;
    }
  },
  w: $alias($property('x')),
  h: $alias($property('y')),
  width: $alias($property('x')),
  height: $alias($property('y')),
  left: $alias($property('x')),
  top: $alias($property('y')),
  right: $alias($property('x')),
  bottom: $alias($property('y')),
  length: $property(function () {
    return Math.sqrt(this.lengthSquared);
  }),
  lengthSquared: $property(function () {
    return this.x * this.x + this.y * this.y;
  }),
  distance: function (pt) {
    return this.sub(pt).length;
  },
  aspect: $property(function () {
    return this.x / this.y;
  }),
  add: function (a, b) {
    if (b === undefined) {
      return typeof a === 'number' ? new Vec2(this.x + a, this.y + a) : new Vec2(this.x + a.x, this.y + a.y);
    } else {
      return new Vec2(this.x + a, this.y + b);
    }
  },
  jitter: function (amount) {
    return this.add(Vec2.random.scale(amount));
  },
  dot: function (other) {
    return this.x * other.x + this.y * other.y;
  },
  sub: function (other) {
    return new Vec2(this.x - other.x, this.y - other.y);
  },
  scale: function (tx, ty) {
    return new Vec2(this.x * tx, this.y * (ty === undefined ? tx : ty));
  },
  mul: function (other) {
    return new Vec2(this.x * other.x, this.y * other.y);
  },
  divide: function (other) {
    return new Vec2(this.x / other.x, this.y / other.y);
  },
  normal: $property(function () {
    return this.scale(1.0 / this.length);
  }),
  perp: $property(function () {
    return new Vec2(this.y, -this.x);
  }),
  half: $property(function () {
    return new Vec2(this.x * 0.5, this.y * 0.5);
  }),
  inverse: $property(function () {
    return new Vec2(-this.x, -this.y);
  }),
  asArray: $property(function () {
    return [this.x, this.y];
  }),
  asLeftTop: $property(function () {
    return {
      left: this.x,
      top: this.y
    };
  }),
  asLeftTopMargin: $property(function () {
    return {
      marginLeft: this.x,
      marginTop: this.y
    };
  }),
  asWidthHeight: $property(function () {
    return {
      width: this.x,
      height: this.y
    };
  }),
  asTranslate: $property(function () {
    return 'translate(' + this.x + ' ' + this.y + ')';
  }),
  separatedWith: function (sep) {
    return this.x + sep + this.y;
  },
  floor: $property(function () {
    return new Vec2(Math.floor(this.x), Math.floor(this.y));
  }),
  sum: $static(function (arr) {
    return _.reduce(_.isArray(arr) && arr || _.asArray(arguments), function (memo, v) {
      return memo.add(v || Vec2.zero);
    }, Vec2.zero);
  }),
  projectOnCircle: function (center, r) {
    return center.add(this.sub(center).normal.scale(r));
  },
  projectOnLineSegment: function (v, w) {
    var wv = w.sub(v);
    var l2 = wv.lengthSquared;
    if (l2 == 0) return v;
    var t = this.sub(v).dot(wv) / l2;
    if (t < 0) return v;
    if (t > 1) return w;
    return v.add(wv.scale(t));
  },
  projectOnRay: function (origin, dir) {
    var l2 = dir.lengthSquared;
    if (l2 == 0) return 0;
    return this.sub(origin).dot(dir) / l2;
  }
});
/*  ------------------------------------------------------------------------ */

if (typeof Symbol !== 'undefined') {
  Vec2.prototype[Symbol.for('String.ify')] = function () {
    return '{' + this.x + ',' + this.y + '}';
  };
}
/*  Cubic bezier
    ======================================================================== */


$global.Bezier = {
  cubic: function (t, p0, p1, p2, p3) {
    var cube = t * t * t;
    var square = t * t;
    var ax = 3.0 * (p1.x - p0.x);
    var ay = 3.0 * (p1.y - p0.y);
    var bx = 3.0 * (p2.x - p1.x) - ax;
    var by = 3.0 * (p2.y - p1.y) - ay;
    var cx = p3.x - p0.x - ax - bx;
    var cy = p3.y - p0.y - ay - by;
    var x = cx * cube + bx * square + ax * t + p0.x;
    var y = cy * cube + by * square + ay * t + p0.y;
    return new Vec2(x, y);
  },
  cubic1D: function (t, a, b, c, d) {
    return Bezier.cubic(t, Vec2.zero, new Vec2(a, b), new Vec2(c, d), Vec2.one).y;
  },
  make: {
    cubic: function (a, b, c, d) {
      return function (t) {
        return Bezier.cubic(t, a, b, c, d);
      };
    },
    cubic1D: function (a, b, c, d) {
      return function (t) {
        return Bezier.cubic1D(t, a, b, c, d);
      };
    }
  }
};
/*  Bounding box (2D)
    ======================================================================== */

$global.BBox = $prototype({
  $static: {
    zero: $property(function () {
      return new BBox(0, 0, 0, 0);
    }),
    unit: $property(function () {
      return new BBox(0, 0, 1, 1);
    }),
    rect: $property(function (sideSize) {
      return new BBox(0, 0, sideSize, sideSize);
    }),
    fromLeftTopAndSize: function (pt, size) {
      return BBox.fromLTWH({
        left: pt.x,
        top: pt.y,
        width: size.x,
        height: size.y
      });
    },
    fromLTWH: function (l, t, w, h) {
      if (arguments.length === 1) {
        return l && BBox.fromLTWH(l.left, l.top, l.width, l.height);
      } else {
        return new BBox(l + w / 2.0, t + h / 2.0, w, h);
      }
    },
    fromLTRB: function (l, t, r, b) {
      if (arguments.length === 1) {
        return l && BBox.fromLTRB(l.left, l.top, l.right, l.bottom);
      } else if (arguments.length === 2) {
        return BBox.fromLTRB(l.x, l.y, t.x, l.y);
      } else {
        return new BBox(_.lerp(0.5, l, r), _.lerp(0.5, t, b), r - l, b - t);
      }
    },
    fromSizeAndCenter: function (size, center) {
      return new BBox(center.x - size.x / 2.0, center.y - size.y / 2.0, size.x, size.y);
    },
    fromSize: function (a, b) {
      if (b) {
        return new BBox(-a / 2.0, -b / 2.0, a, b);
      } else {
        return new BBox(-a.x / 2.0, -a.y / 2.0, a.x, a.y);
      }
    },
    fromPoints: function (pts) {
      var l = Number.MAX_VALUE,
          t = Number.MAX_VALUE,
          r = Number.MIN_VALUE,
          b = Number.MIN_VALUE;

      _.each(pts, function (pt) {
        l = Math.min(pt.x, l);
        t = Math.min(pt.y, t);
        r = Math.max(pt.x, r);
        b = Math.max(pt.y, b);
      });

      return BBox.fromLTRB(l, t, r, b);
    }
  },
  constructor: function (x, y, w, h) {
    if (arguments.length == 4) {
      this.x = x;
      this.y = y;
      this.width = w;
      this.height = h;
    } else {
      _.extend(this, x);
    }
  },
  isPointInside: function (pt) {
    return this.classifyPoint(pt).inside;
  },
  classifyPoint: function (pt) {
    var sides = _.extend(pt.x > this.right ? {
      right: true
    } : {}, pt.x < this.left ? {
      left: true
    } : {}, pt.y > this.bottom ? {
      bottom: true
    } : {}, pt.y < this.top ? {
      top: true
    } : {});

    return _.extend(sides, !sides.left && !sides.right && !sides.bottom && !sides.top ? {
      inside: true
    } : {});
  },
  classifyRay: function (origin, delta, cornerRadius) {
    var half = this.size.half;
    var farTime, farTimeX, farTimeY, nearTime, nearTimeX, nearTimeY, scaleX, scaleY, signX, signY;
    scaleX = 1.0 / delta.x;
    scaleY = 1.0 / delta.y;
    signX = Math.sign(scaleX);
    signY = Math.sign(scaleY);
    nearTimeX = (this.x - signX * half.x - origin.x) * scaleX;
    nearTimeY = (this.y - signY * half.y - origin.y) * scaleY;
    farTimeX = (this.x + signX * half.x - origin.x) * scaleX;
    farTimeY = (this.y + signY * half.y - origin.y) * scaleY;

    if (nearTimeX > farTimeY || nearTimeY > farTimeX) {
      return undefined;
    }

    nearTime = nearTimeX > nearTimeY ? nearTimeX : nearTimeY;
    farTime = farTimeX < farTimeY ? farTimeX : farTimeY;

    if (nearTime >= 1 || farTime <= 0) {
      return undefined;
    }

    var hit = {
      time: _.clamp(nearTime, 0, 1)
    };

    if (nearTimeX > nearTimeY) {
      hit.normal = new Vec2(-signX, 0);
    } else {
      hit.normal = new Vec2(0, -signY);
    }

    hit.delta = delta.scale(hit.time);
    hit.where = origin.add(hit.delta);

    if (cornerRadius) {
      var inner = this.grow(-cornerRadius);

      if (hit.where.x > inner.right) {
        if (hit.where.y < inner.top) {
          hit = Intersect.rayCircle(origin, delta, inner.rightTop, cornerRadius);
        } else if (hit.where.y > inner.bottom) {
          hit = Intersect.rayCircle(origin, delta, inner.rightBottom, cornerRadius);
        }
      } else if (hit.where.x < inner.left) {
        if (hit.where.y < inner.top) {
          hit = Intersect.rayCircle(origin, delta, inner.leftTop, cornerRadius);
        } else if (hit.where.y > inner.bottom) {
          hit = Intersect.rayCircle(origin, delta, inner.leftBottom, cornerRadius);
        }
      }

      if (hit && hit.insideOut) {
        hit.where = origin;
      }
    }

    return hit;
  },
  nearestPointTo: function (pt, cornerRadius) {
    var r = cornerRadius || 0;
    var a = new Vec2(this.left, this.top),
        b = new Vec2(this.right, this.top),
        c = new Vec2(this.right, this.bottom),
        d = new Vec2(this.left, this.bottom);
    var pts = [pt.projectOnLineSegment(a.add(r, 0), b.add(-r, 0)), // top
    pt.projectOnLineSegment(b.add(0, r), c.add(0, -r)), // right
    pt.projectOnLineSegment(c.add(-r, 0), d.add(r, 0)), // bottom
    pt.projectOnLineSegment(d.add(0, -r), a.add(0, r)), // left
    pt.projectOnCircle(a.add(r, r), r), pt.projectOnCircle(b.add(-r, r), r), pt.projectOnCircle(c.add(-r, -r), r), pt.projectOnCircle(d.add(r, -r), r)];
    return _.min(pts, function (test) {
      return pt.sub(test).length;
    });
  },
  xywh: $property(function () {
    return {
      x: this.x,
      y: this.y,
      width: this.width,
      height: this.height
    };
  }),
  ltwh: $property(function () {
    return {
      left: this.left,
      top: this.top,
      width: this.width,
      height: this.height
    };
  }),
  union: function (other) {
    return BBox.fromLTRB(Math.min(this.left, other.left), Math.min(this.top, other.top), Math.max(this.right, other.right), Math.max(this.bottom, other.bottom));
  },
  centerIn: function (other) {
    return new BBox(other.x, other.y, this.width, this.height);
  },
  clone: $property(function () {
    return new BBox(this.x, this.y, this.width, this.height);
  }),
  floor: $property(function () {
    return new BBox.fromLTRB(Math.floor(this.left), Math.floor(this.top), Math.floor(this.right), Math.floor(this.bottom));
  }),
  css: $property(function () {
    return {
      left: this.left + 'px',
      top: this.top + 'px',
      width: this.width + 'px',
      height: this.height + 'px'
    };
  }),
  leftTop: $property(function () {
    return new Vec2(this.left, this.top);
  }),
  leftBottom: $property(function () {
    return new Vec2(this.left, this.bottom);
  }),
  rightBottom: $property(function () {
    return new Vec2(this.right, this.bottom);
  }),
  rightCenter: $property(function () {
    return new Vec2(this.right, this.center.y);
  }),
  rightTop: $property(function () {
    return new Vec2(this.right, this.top);
  }),
  setLeftTop: function (pt) {
    return BBox.fromLTRB(pt.x, pt.y, this.right, this.bottom);
  },
  setRightTop: function (pt) {
    return BBox.fromLTRB(this.left, pt.y, pt.x, this.bottom);
  },
  setRightBottom: function (pt) {
    return BBox.fromLTRB(this.left, this.top, pt.x, pt.y);
  },
  setLeftBottom: function (pt) {
    return BBox.fromLTRB(pt.x, this.top, this.right, pt.y);
  },
  left: $property(function () {
    return this.x - this.width / 2.0;
  }),
  right: $property(function () {
    return this.x + this.width / 2.0;
  }),
  top: $property(function () {
    return this.y - this.height / 2.0;
  }),
  bottom: $property(function () {
    return this.y + this.height / 2.0;
  }),
  center: $property(function () {
    return new Vec2(this.x, this.y);
  }),
  extent: $alias('size'),
  size: $property(function () {
    return new Vec2(this.width, this.height);
  }),
  offset: function (amount) {
    return new BBox(this.x + amount.x, this.y + amount.y, this.width, this.height);
  },
  newWidth: function (width) {
    return new BBox(this.x - (width - this.width) / 2.0, this.y, width, this.height);
  },
  grow: function (amount) {
    return new BBox(this.x, this.y, this.width + amount * 2, this.height + amount * 2);
  },
  shrink: function (amount) {
    return this.grow(-amount);
  },
  mul: function (z) {
    return new BBox(this.x * z, this.y * z, this.width * z, this.height * z);
  },
  scale: function (v) {
    return new BBox(this.x * v.x, this.y * v.y, this.width * v.x, this.height * v.y);
  },
  area: $property(function () {
    return Math.abs(this.width * this.height);
  }),
  intersects: function (other) {
    return !(this.right < other.left || this.left > other.right || this.bottom < other.top || this.top > other.bottom);
  },
  intersect: function (other) {
    return this.intersects(other) ? BBox.fromLTRB(Math.max(this.left, other.left), Math.max(this.top, other.top), Math.min(this.right, other.right), Math.min(this.bottom, other.bottom)) : undefined;
  },
  intersectionArea: function (other) {
    var intersection = this.intersect(other);
    return intersection && intersection.area || 0;
  },
  equals: function (other) {
    return this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height;
  },
  project: function (other) {
    if (other instanceof BBox) {
      return BBox.fromSizeAndCenter(other.size.divide(this.size), this.project(other.center));
    } else {
      return new Vec2((other.x - this.left) / this.width, (other.y - this.top) / this.height);
    }
  }
});

BBox.union = function (a, b) {
  return a ? a.union(b) : new BBox(b.x, b.y, 0, 0);
};
/*  ------------------------------------------------------------------------ */


if (typeof Symbol !== 'undefined') {
  BBox.prototype[Symbol.for('String.ify')] = function () {
    return '{ ' + this.left + ',' + this.top + '  ' + this.right + ',' + this.bottom + ' }';
  };
}
/*  3x3 affine transform matrix, encoding scale/offset/rotate/skew in 2D
    ======================================================================== */


$global.Transform = $prototype({
  $static: {
    identity: $property(function () {
      return new Transform();
    }),
    svgMatrix: function (m) {
      return new Transform([[m.a, m.c, m.e], [m.b, m.d, m.f], [0.0, 0.0, 1.0]]);
    },
    translation: function (v) {
      return new Transform([[1.0, 0.0, v.x], [0.0, 1.0, v.y], [0.0, 0.0, 1.0]]);
    }
  },
  constructor: function (components) {
    this.components = components || [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]];
  },
  multiply: function (m) {
    var result = [[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]];
    var i,
        j,
        k,
        a = this.components,
        b = m.components;

    for (i = 0; i < 3; i++) {
      for (j = 0; j < 3; j++) {
        for (k = 0; k < 3; k++) {
          result[i][j] += a[i][k] * b[k][j];
        }
      }
    }

    return new Transform(result);
  },
  translate: function (v) {
    return this.multiply(Transform.translation(v));
  },
  scale: function (s) {
    return this.multiply(new Transform([[s, 0.0, 0.0], [0.0, s, 0.0], [0.0, 0.0, 1.0]]));
  },
  inverse: $property($memoized(function () {
    var m = this.components;
    var id = 1.0 / (m[0][0] * (m[1][1] * m[2][2] - m[2][1] * m[1][2]) - m[0][1] * (m[1][0] * m[2][2] - m[1][2] * m[2][0]) + m[0][2] * (m[1][0] * m[2][1] - m[1][1] * m[2][0]));
    return new Transform([[(m[1][1] * m[2][2] - m[2][1] * m[1][2]) * id, // 0 0
    -(m[0][1] * m[2][2] - m[0][2] * m[2][1]) * id, // 0 1
    (m[0][1] * m[1][2] - m[0][2] * m[1][1]) * id], // 0 2
    [(m[1][0] * m[2][2] - m[1][2] * m[2][0]) * id, // 1 0
    (m[0][0] * m[2][2] - m[0][2] * m[2][0]) * id, // 1 1
    -(m[0][0] * m[1][2] - m[1][0] * m[0][2]) * id], // 1 2
    [(m[1][0] * m[2][1] - m[2][0] * m[1][1]) * id, // 2 0
    -(m[0][0] * m[2][1] - m[2][0] * m[0][1]) * id, // 2 1
    (m[0][0] * m[1][1] - m[1][0] * m[0][1]) * id]]);
  })),
  // 2 2
  unproject: function (v) {
    var m = this.components;
    return new Vec2(v.x * m[0][0] + v.y * m[0][1] + m[0][2], v.x * m[1][0] + v.y * m[1][1] + m[1][2]);
  },
  project: function (v) {
    return this.inverse.unproject(v);
  }
});
/*  Generates random number generator
    ======================================================================== */

_.rng = function (seed, from, to) {
  var m_w = seed;
  var m_z = 987654321;
  var mask = 0xffffffff;
  return function () {
    m_z = 36969 * (m_z & 65535) + (m_z >> 16) & mask;
    m_w = 18000 * (m_w & 65535) + (m_w >> 16) & mask;
    var result = (m_z << 16) + m_w & mask;
    result /= 4294967296;
    result += 0.5;

    if (from === undefined && to === undefined) {
      return result;
    } else {
      return Math.round(from + result * (to - from));
    }
  };
};
/*  Kind of Brezenham algorithm for 1D
    ======================================================================== */


_.equalDistribution = function (value, n) {
  var average = value / n;
  var realLeft = 0.0;
  return _.times(n, function () {
    var left = Math.round(realLeft);
    var right = Math.round(realLeft += average);
    var rough = Math.floor(right - left);
    return rough;
  });
};
/*  DEPRECATED: use BBox utility
    ======================================================================== */


_.ptInRect = function (pt, rect) {
  return pt.x >= rect.left && pt.y >= rect.top && pt.x < rect.right && pt.y < rect.bottom;
};
/*  Color utility
    ======================================================================== */


_.hue2CSS = function (H, a) {
  return _.RGB2CSS(_.hue2RGB(H), a);
};

_.HSL2CSS = function (hsl, a) {
  return _.RGB2CSS(_.HSL2RGB(hsl), a);
};

_.HSL2RGB = function (hsl) {
  var h = hsl[0],
      s = hsl[1],
      l = hsl[2];

  var rgb = _.hue2RGB(h);

  var c = (1.0 - Math.abs(2.0 * l - 1.0)) * s;
  return [(rgb[0] - 0.5) * c + l, (rgb[1] - 0.5) * c + l, (rgb[2] - 0.5) * c + l];
};

_.hue2RGB = function (hue) {
  return [Math.max(0.0, Math.min(1.0, Math.abs(hue * 6.0 - 3.0) - 1.0)), Math.max(0.0, Math.min(1.0, 2.0 - Math.abs(hue * 6.0 - 2.0))), Math.max(0.0, Math.min(1.0, 2.0 - Math.abs(hue * 6.0 - 4.0)))];
};

_.RGB2CSS = function (rgb, a) {
  return 'rgba(' + Math.round(rgb[0] * 255) + ',' + Math.round(rgb[1] * 255) + ',' + Math.round(rgb[2] * 255) + ',' + (a === undefined ? rgb[3] === undefined ? 1.0 : rgb[3] : a) + ')';
};

_.RGB2HSL = function (rgb, a_) {
  var r = rgb[0],
      g = rgb[1],
      b = rgb[2],
      a = a_ === undefined ? rgb[3] : a_;
  var max = Math.max(r, g, b),
      min = Math.min(r, g, b);
  var h,
      s,
      l = (max + min) / 2;

  if (max == min) {
    h = s = 0;
  } else {
    var d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;

      case g:
        h = (b - r) / d + 2;
        break;

      case b:
        h = (r - g) / d + 4;
        break;
    }

    h /= 6;
  }

  return a === undefined ? [h, s, l] : [h, s, l, a];
};
/*  Advanced rounding utility
    ======================================================================== */


_.extend(Math, function (decimalAdjust) {
  return {
    roundTo: function (value, precision) {
      return value - value % precision;
    },
    round10: function (value, exp) {
      return decimalAdjust('round', value, exp);
    },
    floor10: function (value, exp) {
      return decimalAdjust('floor', value, exp);
    },
    ceil10: function (value, exp) {
      return decimalAdjust('ceil', value, exp);
    }
  };
}(function (
/* decimalAdjust */
type, value, exp) {
  /**
   * Decimal adjustment of a number.
   *
   * @param   {String}    type    The type of adjustment.
   * @param   {Number}    value   The number.
   * @param   {Integer}   exp     The exponent (the 10 logarithm of the adjustment base).
   * @returns {Number}            The adjusted value.
   */
  // If the exp is undefined or zero...
  if (typeof exp === 'undefined' || +exp === 0) {
    return Math[type](value);
  }

  value = +value;
  exp = +exp; // If the value is not a number or the exp is not an integer...

  if (isNaN(value) || !(typeof exp === 'number' && exp % 1 === 0)) {
    return NaN;
  } // Shift


  value = value.toString().split('e');
  value = Math[type](+(value[0] + 'e' + (value[1] ? +value[1] - exp : -exp))); // Shift back

  value = value.toString().split('e');
  return +(value[0] + 'e' + (value[1] ? +value[1] + exp : exp));
}))
/*  ------------------------------------------------------------------------ */
;

(function () {
  var toposort = require('toposort');

  $mixin(Array, {
    topoSort: function () {
      return toposort(this);
    }
  });
})();
/*  ------------------------------------------------------------------------ */


_.withTest(['Array', 'topomerge'], function () {
  $assert([['all', 'your', 'to', 'us'], ['your', 'belong', 'us'], ['base', 'belong', 'to'], ['your', 'base']].topoMerge(),
  /* -------------------------------------- */
  ['all', 'your', 'base', 'belong', 'to', 'us']);
  /*  ------------------------------------------------------------------------ */
}, function () {
  $mixin(Array, {
    topoMerge: function () {
      var edges = [];

      for (var i = 0, ni = this.length; i < ni; i++) {
        var sequence = this[i];

        for (var j = 0, nj = sequence.length - 1; j < nj; j++) {
          edges.push([sequence[j], sequence[j + 1]]);
        }
      }

      return edges.topoSort();
    }
  });
});
/*  ------------------------------------------------------------------------ */


_.withTest(['DAG', 'sortedSubgraphOf'], function () {
  var modules = {
    '1': {
      requires: []
    },
    '11': {
      requires: ['1']
    },
    '2': {
      requires: ['0']
    },
    '111': {
      requires: ['12', '100']
    },
    '12': {
      requires: ['0', '11', '2']
    },
    '100': {
      requires: ['10']
    },
    '0': {
      requires: []
    },
    '10': {
      requires: ['0', '2']
    },
    'root': {
      requires: ['2', '111']
    }
  };
  $assert(DAG.sortedSubgraphOf('root', {
    nodes: function (x) {
      return modules[x].requires;
    }
  }), ["0", "1", "11", "2", "12", "10", "100", "111"]);
  /*  ------------------------------------------------------------------------ */
}, function () {
  $global.DAG = function (cfg) {
    this.cfg = cfg || {}, this.nodes = cfg.nodes || _.noop;
  }, DAG.prototype.each = function (N, fn, prev, visited) {
    visited = visited || new Set();

    if (!visited.has(N)) {
      visited.add(N);
      var self = this,
          nodes = this.nodes(N) || [],
          stop = fn.call(this, N, {
        nodes: nodes,
        prev: prev,
        visited: visited
      });

      if (stop !== true) {
        nodes.forEach(function (NN) {
          self.each(NN, fn, N, visited);
        });
      }
    }

    ;
    return visited;
  }, DAG.prototype.edges = function (N) {
    var edges = [];
    this.each(N, function (N, context) {
      context.nodes.concat(N).reduce(function (A, B) {
        edges.push([A, B]);
        return B;
      });
    });
    return edges;
  }, DAG.prototype.sortedSubgraphOf = function (node0) {
    return this.edges(node0).topoSort().remove(node0);
  };

  DAG.sortedSubgraphOf = function (node0, cfg) {
    return new DAG(cfg).sortedSubgraphOf(node0);
  };
});
/*  ------------------------------------------------------------------------ */
},{"underscore":"node_modules/underscore/underscore.js","toposort":"node_modules/toposort/index.js"}],"node_modules/useless/base/component.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var _ = require('underscore');
/*  What for:

    -   Hierarchy management (parent-child relationship)
    -   Destructors ('destroy' method), propagating through hierarchy
    -   bindable on $prototypes, auto-disconnecting if involved component gets destroyed
    -   trigger/barrier on $prototypes, auto-disconnecting if involved component gets destroyed

    Component facility provides unified mechanics for deinitialization, thus allowing
    to freely combine distinct components into more complex structure with no need to
    know how to specifically deinitialize each of them.

    Use to define highly configurable/reusable objects having limited lifetime, holding
    system resources and organizing into hierarchies, e.g. UI components, like dialogs,
    menus, embeddable data views. They hold DOM references and bound events, so one needs
    to properly free those resources during deinitialization. Case studies:

    -   For example, a pop-up menu could render itself into top-level 'document' element, 
        so just by destroying its parent component's DOM, things created by this pop-up
        wont be destroyed, and that's why explicit 'destroy' method is needed. With
        Component, you call 'destroy' on parent component, and it propagates to child
        components automatically, triggering their 'destroy' methods.

    -   A component could dynamically bind to other components with help of $bindable and
        $trigger facilities. If such component gets destroyed, those links became invalid
        and should be removed, otherwise it's considered as 'memory leak'. Component handles
        such situation, removing those links if any involved component gets destroyed.

    Component could be considered as basic tool for dynamic code binding at macro level,
    promoting functional code binding tools (defined in dynamic/stream.js) to $prototypes.
 */


_.tests.component = {
  /*  - Passing config to constructor will extend constructed instance with that object
      - Component constructors exhibit CPS interface (last function argument interprets as continuation)
   */
  'constructor([cfg, ][then])': function () {
    $assertNotCalled(function (mkay) {
      var Compo = $component({});
      /*  1. constructor (cfg)
       */

      $assertMatches(new Compo({
        foo: 42
      }), {
        foo: 42
      });
      /*  2. constructor (then)
       */
      //new Compo (mkay)

      /*  3. constructor (cfg, then)
       */

      /*$assertMatches (new Compo ({ foo: 42 }, mkay), { foo: 42 })*/
    });
  },

  /*  init() should be entry point to a component, calling at constructor by default
   */
  'init': function () {
    $assertEveryCalledOnce(function (mkay) {
      $singleton(Component, {
        init: function () {
          mkay();
        }
      });
    });
  },

  /*  init(then) means your initialization is defined in CPS style
   */

  /*'CPS init': function () { $assertEveryCalled (function (compo1, compo2) {
                           var Compo = $prototype ({
                              init: function (then) { // you're required to call then, to complete init
                                  then () } })
                           var compo = new Compo (function () {
                              compo1 () })
                           var compo2 = new Compo ({ _42: 42 }, function () {
                              $assert (this._42, 42)
                              compo2 () }) }) },*/

  /*  constructor overriding is prohibited (by $final), use init() API for configuration means
   */
  'no constructor overriding': function () {
    $assertThrows(function () {
      $singleton(Component, {
        constructor: function () {}
      });
    });
  },

  /*  If you don't want init() to be called at constructor (to call it manually later),
      pass init:false to constructor's config
   */
  'manual init()': function () {
    $assertNotCalled(function (fail) {
      var Compo = $component({
        init: function () {
          fail();
        }
      });
      var compo = new Compo({
        init: false
      });
      $assert(_typeof(compo.init), 'function');
    });
  },
  // shouldn't be replaced by false

  /*  initialized is a _.barrier that opens after initialization
   */
  'initialized (barrier)': function () {
    var Compo = $component({
      init: function () {}
    });
    var compo = new Compo({
      init: false
    });
    $assert(!compo.initialized.already);
    $assertEveryCalledOnce(function (mkay) {
      compo.initialized(function () {
        mkay();
      });
      compo.init();
    });
  },

  /*  'thiscall' semantics for methods (which can be defined by a variety of ways)
   */
  'thiscall for methods': function () {
    $assertEveryCalledOnce(function (prototypeMethod, instanceMethod) {
      var instance = null;
      var Compo = new $component({
        prototypeMethod: function () {
          $assert(this === instance);
          prototypeMethod();
        }
      });
      instance = new Compo({
        instanceMethod: function () {
          $assert(this === instance);
          instanceMethod();
        }
      });
      instance.prototypeMethod.call(null);
      instance.instanceMethod.call(null);
    });
  },

  /*  Pluggable init/destroy with $traits (tests all combinations of CPS / sequential style method calling)
   */
  'pluggable init with $traits': function () {
    var A, B, C, D;
    var A = $trait({
      beforeInit: function () {
        A = true;
        return Promise.resolve();
      },
      afterInit: function () {
        B = true;
        return Promise.resolve();
      }
    });
    var B = $trait({
      beforeInit: function () {
        C = true;
      },
      afterInit: function () {
        D = true;
      }
    });
    var C = $component({
      $traits: [B, A]
    });
    return new C().initialized.promise.then(function () {
      $assert(A, B, C, D, true);
    });
  },

  /*  $defaults is convenient macro to extract _.defaults thing from init() to definition level
   */
  '$defaults basic': function () {
    var Compo = $component({
      $defaults: {
        foo: 42
      }
    });
    $assert($untag(Compo.$definition.$defaults), {
      foo: 42
    });
    $assert(Compo.$defaults, {
      foo: 42
    });
    var Compo2 = $component({
      $traits: [$trait({
        $defaults: {
          foo: 11
        }
      })],
      $defaults: {}
    });
    $assert($untag(Compo2.$definition.$defaults), {
      foo: 11
    });
    $assert(Compo2.$defaults, {
      foo: 11
    });
  },
  '$defaults': function () {
    var Trait = $trait({
      $defaults: {
        pff: 'pff',
        inner: {
          fromTrait: 1
        }
      }
    });
    var Base = $component({
      $defaults: {
        foo: 12,
        qux: 'override me',
        inner: {
          fromBase: 1
        }
      }
    });
    var Derived = $extends(Base, {
      $traits: [Trait],
      $defaults: {
        bar: 34,
        qux: 'overriden',
        inner: {
          fromDerived: 1
        }
      }
    }); //$assert (Derived.$ownDefaults,
    //               { bar: 34, qux: 'overriden', inner: { fromDerived: 1 } } )

    /* TODO: fix bug not allowing derived to not have $defaults
       var Derived2 = $extends (Derived, {}) */

    $assert(new Derived().inner !== new Derived().inner); // should clone $defaults at instance construction

    $assertMatches(new Derived({
      pff: 'overriden from cfg'
    }), {
      pff: 'overriden from cfg',
      foo: 12,
      bar: 34,
      qux: 'overriden',
      inner: {
        fromTrait: 1,
        fromBase: 1,
        fromDerived: 1
      }
    });
  },
  '$defaults cloning semantics': function () {
    var set = new Set([1, 2, 3]);
    var S = $component({
      $defaults: {
        foo: set,
        bar: new Set()
      }
    });
    var s = new S();
    $assert(s.foo instanceof Set, s.bar instanceof Set, true);
    $assert(s.foo !== set);
  },

  /*  Use $requires to specify required config params along with their type signatures
   */
  '$requires': function () {
    var SomeType = $prototype();
    var CompoThatRequires = $component({
      $requires: {
        foo: SomeType,
        // requires foo to be instance of SomeType
        ffu: {
          a: 'number',
          b: 'string'
        },
        // breakdown test
        bar: 'number',
        qux: ['number'],
        baz: _.not(_.isEmpty)
      }
    }); // custom requirement predicate

    var DerivedCompoThatRequiresMore = $extends(CompoThatRequires, {
      $requires: {
        more: 'string'
      }
    });
    $assertFails(function () {
      new CompoThatRequires({
        baz: {}
      });
    }); // $requires behaves like assertion in case of failure

    $assertFails(function () {
      new DerivedCompoThatRequiresMore({
        more: 'hey how about other requirements'
      });
    });
    new DerivedCompoThatRequiresMore({
      foo: new SomeType(),
      bar: 42,
      qux: [1, 2, 3],
      more: 'blah blah',
      ffu: {
        a: 1,
        b: '2'
      },
      baz: 'blahblah'
    });
  },

  /*  $overrideThis is a macro that requires a method to be overriden
   */

  /*'overrideThis': function () {
      $assertThrows (function () { $singleton (Component, { foo: $overrideThis (function () {}) }) },
          _.matches ({ message: 'foo should be overriden' })) },*/

  /*  $bindable lifts _.bindable to Component level, opening new venues to hooking onto existing impl,
      in ad-hoc way, with no need to specify hard-coded callback structure beforehand.
       Use to implement common beforeXXX and afterXXX semantics.
   */
  '$bindable': function () {
    $assertEveryCalledOnce(function (method, before, after) {
      var compo = $singleton(Component, {
        method: $bindable(function (x) {
          method();
          return 42;
        })
      });
      compo.method.onBefore(function (_5) {
        before();
        $assert(this === compo);
        $assert(_5, 5);
      });
      compo.method.onAfter(function (_5, _result) {
        after();
        $assert(this === compo);
        $assert(_5, 5);
        $assert(_result, 42);
      });
      $assert(compo.method(5), 42);
    });
  },

  /*  Trigger has many names in outer world, like Event, Signal (and legion of
      many other misleading buzzwords).
       In our implementation, Trigger is a partial case of 'stream' concept, which
      is a highly abstract functional I/O primitive for multicasting of data/events).
      See dynamic/stream.js for its amazingly simple implementation.
           1.  If called with some value arguments (or no argument), it performs
              multicast of these arguments to all bound listeners (readers).
              In terms of 'streams' that operation is called 'write'.
           2.  If called with function argument, it adds that function to the wait
              queue mentioned before. In terms of 'streams' it is called 'read'.
       Component manages those streams (defined by $-syntax at its prototype definition),
      auto-disconnecting bound methods, so that no method of Component bound
      to such streams will ever be called after destroy().
   */
  '$trigger': function () {
    $assertEveryCalled(function (mkay__2) {
      var compo = $singleton(Component, {
        mouseMoved: $trigger()
      });
      compo.mouseMoved(function (x, y) {
        $assert([x, y], [7, 12]);
        mkay__2();
      });
      compo.mouseMoved(7, 12);
      compo.mouseMoved(7, 12);
    });
  },
  'init streams from config': function () {
    $assertEveryCalled(function (atDefinition, atInit) {
      var Compo = $component({
        mouseMoved: $trigger(atDefinition),
        init: function () {
          this.mouseMoved();
        }
      });
      new Compo({
        mouseMoved: atInit
      });
    });
  },

  /*  A variation of trigger. On 'write' operation, it flushes wait queue, so
      no callback bound previously gets called in future (until explicitly
      queued again by 'read' operation).
   */
  '$triggerOnce': function () {
    var compo = $singleton(Component, {
      somthingHappened: $triggerOnce()
    });
    $assertEveryCalled(function (first, second) {
      compo.somthingHappened(function (what) {
        $assert(what, 'somthin');
        first();
      });
      compo.somthingHappened(function (what) {
        $assert(what, 'somthin');
        second();
      });
      compo.somthingHappened('somthin');
    });
  },

  /*  Another variation of stream, having 'memory fence / memory barrier' semantics,
      widely known as synchronization primitive in concurrent programming.
           1.  At first, barrier is in closed state, putting any callback passed to it
              to a queue.
           2.  When barrier is called with value argument, it state changes to 'opened',
              triggering all queued callbacks with that value argument passed in.
           3.  After barrier had opened, any futher callback gets called immediately
              with that value argument passed before, i.e. short-circuits.
   */
  '$barrier': function () {
    $assertEveryCalled(function (early, lately) {
      var compo = $singleton(Component, {
        hasMessage: $barrier()
      });
      compo.hasMessage(function (_msg) {
        $assert(_msg, 'mkay');
        early();
      });
      compo.hasMessage('mkay');
      compo.hasMessage(function (_msg) {
        $assert(_msg, 'mkay');
        lately();
      });
    });
  },

  /*  $observableProperty is a powerful compound mechanism for data-driven dynamic
      code binding, built around streams described previously.
   */
  '$observableProperty': function () {
    $assertEveryCalled(function (fromConstructor, fromConfig, fromLateBoundListener, fromDefinition, fromListenerOnlyVariant) {
      var Compo = $component({
        color: $observableProperty(),
        smell: $observableProperty(),
        shape: $observableProperty('round', function (now) {
          $assert(now, 'round');
          fromDefinition();
        }),
        size: $observableProperty(function (x) {
          $assert(x, 42);
          fromListenerOnlyVariant();
        }),
        init: function () {
          this.colorChange(function (now, was) {
            if (was) {
              fromConstructor();
              $assert([now, was], ['green', 'blue']);
            }
          });
        }
      });
      var compo = new Compo({
        color: 'blue',
        size: 42,
        colorChange: function (now, was) {
          if (was) {
            fromConfig();
            $assert([now, was], ['green', 'blue']);
          }
        }
      }); //console.log (compo.constructor.$definition)

      compo.smellChange(function (now, was) {
        fromLateBoundListener();
        $assert(compo.smell, now, 'bad');
        $assert(undefined, was);
      });
      compo.color = 'green';
      compo.smell = 'bad';
    });
  },

  /*  $observableProperty automatically calls prototype constructor if supplied with non-prototype instance data
   */
  '$observableProperty (Prototype)': function () {
    var Compo = $component({
      position: $observableProperty(Vec2.zero),
      init: function () {
        this.positionChange(function (v) {
          $assertTypeMatches(v, Vec2);
          $assert(v.y, 42);
        });
      }
    });
    var compo = new Compo({
      position: {
        x: 10,
        y: 42
      }
    }); // supply POD value from constructor

    compo.position = {
      x: 20,
      y: 42
    };
  },
  // supply POD value from property accessor
  'binding to streams with traits': function () {
    Meta.globalTag('dummy');
    $assertEveryCalled(function (mkay1, mkay2) {
      var this_ = undefined;
      var Trait = $trait({
        somethingHappened: $trigger()
      });
      var Other = $trait({
        somethingHappened: $dummy(function (_42) {
          $assert(this, this_);
          $assert(_42, 42);
          mkay1();
        })
      });
      var Compo = $component({
        $traits: [Trait, Other],
        somethingHappened: function (_42) {
          $assert(this, this_);
          $assert(_42, 42);
          mkay2();
        }
      });
      this_ = new Compo();
      this_.somethingHappened(42);
    });
  },
  'binding to bindables with traits': function () {
    $assertCallOrder(function (beforeCalled, interceptCalled, bindableCalled, afterCalled) {
      var this_ = undefined;
      var Trait = $trait({
        doSomething: $bindable(function (x) {
          $assert(this, this_);
          bindableCalled();
        })
      });
      var Other = $trait({
        beforeDoSomething: function (_42) {
          $assert(this, this_);
          $assert(_42, 42);
          beforeCalled();
        },
        interceptDoSomething: function (_42, impl) {
          interceptCalled();
          $assert(this, this_);
          return impl(_42);
        }
      });
      var Compo = $component({
        $traits: [Trait, Other],
        afterDoSomething: function (_42) {
          $assert(this, this_);
          $assert(_42, 42);
          afterCalled();
        }
      });
      this_ = new Compo();
      this_.doSomething(42);
    });
  },
  'binding to observable properties with traits': function () {
    $assertEveryCalled(function (one, two) {
      var this_ = undefined;
      var Trait = $trait({
        someValue: $observableProperty(42)
      });
      var Other = $trait({
        someValue: function (_42) {
          one();
        }
      });
      var Compo = $component({
        $traits: [Trait, Other],
        someValue: function (_42) {
          two();
        }
      });
      this_ = new Compo();
      $assert(_.isFunction(this_.someValueChange));
      this_.someValue = 33;
    });
  },
  'hierarchy management': function () {
    $assertEveryCalled(function (mkay__9) {
      var Compo = $extends(Component, {
        init: function () {
          mkay__9();
        },
        destroy: function () {
          mkay__9();
        }
      });
      var parent = new Compo().attach(new Compo().attach(new Compo()));
      var parrot = new Compo().attachTo(parent).attachTo(parent);
      $assert(parrot.attachedTo === parent);
      $assert(parrot.detach().attachedTo === undefined);
      var carrot = new Compo();
      parent.attach(carrot);
      parent.attach(carrot);
      parent.destroy();
    });
  },
  'thiscall for streams': function () {
    var compo = $singleton(Component, {
      trig: $trigger()
    });
    compo.trig(function () {
      $assert(this === compo);
    });
    compo.trig.call({});
  },
  '$defaults can set $observableProperty': function () {
    var compo = $singleton(Component, {
      twentyFour: $observableProperty(42),
      $defaults: {
        twentyFour: 24
      }
    });
    $assertEveryCalledOnce(function (mkay) {
      compo.twentyFourChange(function (val) {
        $assert(val, 24);
        mkay();
      });
    });
  },
  'defer init with $defaults': function () {
    var compo = $singleton(Component, {
      $defaults: {
        init: false
      },
      init: function () {}
    });
    compo.init();
  },
  'stream members should be available at property setters when inited from config': function () {
    var compo = new ($component({
      ready: $barrier(),
      value: $property({
        set: function (_42) {
          $assertTypeMatches(this.ready, 'function');
        }
      })
    }))({
      value: 42
    });
  },
  'observableProperty.force (regression)': function () {
    $assertEveryCalled(function (mkay__2) {
      var compo = $singleton(Component, {
        prop: $observableProperty()
      });
      compo.prop = 42;
      compo.propChange(function (value) {
        $assert(value, 42);
        $assert(this === compo);
        mkay__2();
      });
      compo.propChange.force();
    });
  },
  'two-argument $observableProperty syntax': function () {
    $assertEveryCalled(function (mkay) {
      var compo = $singleton(Component, {
        prop: $observableProperty(42, function (value) {
          mkay();

          if (compo) {
            $assert(this === compo);
            $assert(value === compo.prop);
          }
        })
      });
      compo.prop = 43;
    });
  },
  'two-argument $observable': function () {
    $assertEveryCalled(function (mkay) {
      $assert('foo', $singleton(Component, {
        foo: $observable('foo', function (x) {
          $assert(x, 'foo');
          mkay();
        })
      }).foo.value);
    });
  },
  'destroyAll()': function () {
    $assertEveryCalled(function (destroyed__2) {
      var Compo = $extends(Component, {
        destroy: function () {
          destroyed__2();
        }
      });
      var parent = new Compo().attach(new Compo()).attach(new Compo());
      $assert(parent.attached.length === 2);
      parent.destroyAll();
      parent.destroyAll();
      $assert(parent.attached.length === 0);
    });
  },
  '$macroTags for component-specific macros': function () {
    var Trait = $trait({
      $macroTags: {
        add_2: function (def, fn, name) {
          return Meta.modify(fn, function (fn) {
            return fn.then(_.sum.$(2));
          });
        }
      }
    });
    var Base = $component({
      $macroTags: {
        add_20: function (def, fn, name) {
          return Meta.modify(fn, function (fn) {
            return fn.then(_.sum.$(20));
          });
        }
      }
    });
    var Compo = $extends(Base, {
      $traits: [Trait],
      $macroTags: {
        dummy: function () {}
      },
      testValue: $static($add_2($add_20(_.constant(20))))
    });
    $assert(42, Compo.testValue());
    $assertMatches(_.keys(Compo.$macroTags), ['dummy', 'add_2', 'add_20']);

    _.each(_.keys(Compo.$macroTags), function (name) {
      delete $global['$' + name];
    });
  },
  '$raw for performance-critical methods (disables thiscall proxy)': function () {
    var compo = new ($component({
      method: function (this_) {
        $assert(this_ === this);
      },
      rawMethod: $raw(function (this_) {
        $assert(this_ !== this);
      })
    }))();
    var method = compo.method;
    method(compo);
    var rawMethod = compo.rawMethod;
    rawMethod(compo);
  },
  'two-way $observable binding': function () {
    var Compo = $component({
      x: $observable('foo')
    });

    var x = _.observable('bar');

    var compo = new Compo({
      x: x
    });
    $assert(compo.x !== x);
    $assert(compo.x.value, x.value, 'bar');
    compo.x(42);
    $assert(x.value, 42);
    x('lol');
    $assert(compo.x.value, 'lol');
    /*  Test unbinding    */

    compo.destroy();
    $assert(compo.x.queue, []);
    compo.x('yo');
    $assert(x.value, 'lol'); // shouldnt change

    x('oy');
    $assert(compo.x.value, 'yo'); // shouldnt change
  },
  'member order': function () {
    var X = $component({
      $depends: [$trait({
        foo_1: function () {}
      }), $trait({
        foo_2: function () {}
      })],
      foo_3: function () {}
    });
    $assert(_.filter(_.keys(X.prototype), function (k) {
      return k.startsWith('foo');
    }), ['foo_1', 'foo_2', 'foo_3']);
  },

  /*  $alias (TODO: fix bugs)
   */

  /*'$alias': function () { var value = 41
       var compo = $singleton (Component, {
           foo: function () { return ++value },
          bar: $bindable ($alias ('foo')),
          baz: $memoize  ($alias ('bar')) })
       $assertEveryCalled (function (mkay) { compo.bar.onBefore (mkay)
          $assert (compo.baz (),
                   compo.baz (), 42) }) },*/

  /*  Auto-unbinding
   */
  'unbinding (simple)': function () {
    var somethingHappened = _.trigger();

    var compo = $singleton(Component, {
      fail: function () {
        $fail;
      }
    });
    somethingHappened(compo.fail);
    compo.destroy();
    somethingHappened();
  },
  // should not invoke compo.fail
  '(regression) undefined was allowed as trait': function () {
    $assertThrows(function () {
      var Compo = $component({
        $traits: [undefined]
      });
    }, {
      message: 'invalid $traits value'
    });
  },
  '(regression) undefined members fail': function () {
    var Compo = $component({
      yoba: undefined
    });
    $assert('yoba' in Compo.prototype);
  },
  '(regression) $defaults with $traits fail': function () {
    var Compo = $component({
      $traits: [$trait({
        $defaults: {
          x: 1
        }
      })],
      $defaults: {
        a: {},
        b: [],
        c: 0
      }
    });
    $assert(Compo.$defaults, {
      x: 1,
      a: {},
      b: [],
      c: 0
    });
  },
  '(regression) $defaults with $traits fail #2': function () {
    var Compo = $component({
      $traits: [$trait({
        $defaults: {
          x: 1
        }
      })]
    });
    $assert(Compo.$defaults, {
      x: 1
    });
  },
  '(regression) method overriding broken': function () {
    var Compo = $component({
      method: function () {
        $fail;
      }
    });
    var compo = new Compo({
      value: 42,
      method: function () {
        return this.value;
      }
    });
    $assert(compo.method(), 42);
  },
  '(regression) $observableProperty (false)': function () {
    $assertEveryCalledOnce(function (mkay) {
      $singleton(Component, {
        foo: $observableProperty(false),
        init: function () {
          this.fooChange(mkay);
        }
      });
    });
  },
  '(regression) was not able to define inner compos at singleton compos': function () {
    var Foo = $singleton(Component, {
      InnerCompo: $component({
        foo: $observableProperty()
      })
    });
    var Bar = $extends(Foo.InnerCompo, {
      bar: $observableProperty()
    });
    var bar = new Bar();
    $assertTypeMatches(bar, {
      fooChange: 'function',
      barChange: 'function'
    });
  },

  /*'(regression) postpone': function (testDone) { $assertEveryCalledOnce ($async (function (foo) {
      $singleton (Component, {
          foo: function () { foo (); },
          init: function () { this.foo.postpone () } }) }), testDone) },*/
  '(regression) undefined at definition': function () {
    $singleton(Component, {
      fail: undefined
    });
  },
  '(regression) properties were evaluated before init': function () {
    $singleton(Component, {
      fail: $property(function () {
        $fail;
      })
    });
  },
  '(regression) misinterpretation of definition': function () {
    $singleton(Component, {
      get: function () {
        $fail;
      }
    });
  },
  '(regression) alias incorrectly worked with destroy': function () {
    var test = $singleton(Component, {
      destroy: function () {
        mkay();
      },
      close: $alias('destroy')
    });
    $assert(test.close, test.destroy);
  },
  '(regression) pollution of stream listeners': function () {
    var A = $trait({
      something: $bindable(function (x) {})
    });
    var B = $trait({
      afterSomething: function (x) {
        $assert(false);
      }
    });
    var Y = $singleton(Component, {
      $depends: [A, B]
    });
    var Z = $singleton(Component, {
      $depends: [A]
    });
    Z.something();
  }
};
/*  General syntax
 */

$global.$component = function (definition) {
  return $extends(Component, definition);
};

_(['extendable', 'trigger', 'triggerOnce', 'barrier', 'bindable', 'memoize', 'interlocked', 'memoizeCPS', 'debounce', 'throttle', 'overrideThis', 'listener', 'postpones', 'reference', 'raw', 'binds', 'observes']).each(Meta.globalTag);

(function () {
  var impl = function (tag, a, b) {
    if (arguments.length < 3) {
      var listener = $untag(a);
      return _.isFunction(listener) ? Meta.setTag(tag, listener) // $observableProperty (listener)
      : Meta.setTag(tag, true, a); // $observableProperty (value)
    } else {
      var _listener = $untag(b);

      return Meta.setTag(tag, _.isFunction(_listener) ? _listener : true, a); // $observableProperty (value, listener)
    }
  };

  Meta.globalTag('observableProperty', impl);
  Meta.globalTag('observable', impl);
})();

$global.$observableRef = function (x) {
  return $observableProperty($reference(x));
};

$prototype.macro('$depends', function (def, value, name) {
  def.$depends = $builtin($const(_.coerceToArray(value)));
  return def;
});
$prototype.macroTag('extendable', function (def, value, name) {
  def[name] = $builtin($const(value));
  return def;
});
$global.Component = $prototype({
  $defaults: $extendable({}),
  $requires: $extendable({}),
  $macroTags: $extendable({}),

  /*  Overrides default OOP.js implementation
   */
  $impl: {
    sequence: function (def, base) {
      return _.sequence(this.convertPropertyAccessors, this.extendWithTags, this.flatten, this.generateCustomCompilerImpl(base), this.ensureFinalContracts(base), this.generateConstructor(base), this.evalAlwaysTriggeredMacros(base), this.evalMemberTriggeredMacros(base), this.expandTraitsDependencies, this.mergeExtendables(base), this.contributeTraits(base), this.mergeStreams, this.mergeBindables, this.generateBuiltInMembers(base), this.callStaticConstructor, this.expandAliases, this.groupMembersByTagForFastEnumeration, this.defineStaticMembers, this.defineInstanceMembers);
    },
    expandTraitsDependencies: function (def) {
      if (_.isNonempty($untag(def.$depends)) && _.isEmpty($untag(def.$traits))) {
        def.$traits = DAG.sortedSubgraphOf(def, {
          nodes: function (def) {
            return $untag(def.$depends);
          }
        });
      }

      ;
      return def;
    },
    mergeExtendables: function (base) {
      return function (def) {
        _.each(base.$definition, function (value, name) {
          if ($extendable.is(value)) {
            def[name] = Meta.modify(value, function (value) {
              value = _.extendedDeep(value, $untag(def[name] || {}));

              _.each($untag(def.$traits), function (trait) {
                if (!trait) {
                  log.e(def.$traits);
                  throw new Error('invalid $traits value');
                }

                var traitVal = trait.$definition[name];

                if (traitVal) {
                  value = _.extendedDeep($untag(traitVal), value);
                }
              });

              return value;
            });
          }
        });

        return def;
      };
    },
    mergeTraitsMembers: function (def, traits) {
      var newDef = {}; // clone to re-add members in correct order (traits first)

      var pool = {},
          bindables = {},
          streams = {};
      var macroTags = $untag(def.$macroTags);

      var definitions = _.pluck(traits, '$definition').concat(_.clone(def));

      _.each(definitions, function (traitDef) {
        _.each(macroTags && this.applyMacroTags(macroTags, _.extend(_.clone(traitDef), {
          constructor: def.constructor
        })) || traitDef, function (member, name) {
          if ($builtin.isNot(member) && $builtin.isNot(def[name]) && name !== 'constructor') {
            if ($bindable.is(member)) {
              bindables[name] = member;
            }

            if (Component.isStreamDefinition(member)) {
              streams[name] = member;
            }

            (pool[name] || (pool[name] = [])).push(member);
            newDef[name] = member;
          }
        });
      }, this);

      def.__bindables = bindables;
      def.__streams = streams;
      def.__membersByName = pool;
      /*  Re-add members in correct order */

      for (var k of Object.keys(newDef)) {
        delete def[k];
      }

      for (var _k of Object.keys(newDef)) {
        def[_k] = newDef[_k];
      }
    },
    mergeStreams: function (def) {
      var pool = def.__membersByName;

      _.each(def.__streams, function (stream, name) {
        var clonedStream = def[name] = Meta.new(stream);
        clonedStream.listeners = [];

        _.each(pool[name], function (member) {
          if (member !== stream) {
            clonedStream.listeners.push($untag(member));
          }
        });
      });

      return def;
    },
    mergeBindables: function (def) {
      var pool = def.__membersByName;

      _.each(def.__bindables, function (member, name) {
        var bound = _.filter2(_.bindable.hooks, function (hook, i) {
          var bound = pool[_.bindable.hooksShort[i] + name.capitalized];
          return bound ? [hook, bound] : false;
        });

        if (bound.length) {
          var hooks = {};

          _.each(bound, function (kv) {
            _.each(kv[1], function (fn) {
              fn = $untag(fn);

              if (_.isFunction(fn)) {
                var k = '_' + kv[0];
                (hooks[k] || (hooks[k] = [])).push(fn);
              }
            });
          });

          def[name] = $bindable({
            hooks: hooks
          }, member);
        }
      });

      return def;
    }
  },

  /*  Syntax helper
   */
  isStreamDefinition: $static(function (def) {
    var tags = Meta.tags(def);
    return tags.trigger || tags.triggerOnce || tags.barrier || tags.observable || tags.observableProperty;
  }),

  /*  Another helper (it was needed because _.methods actually evaluate $property values while enumerating keys,
      and it ruins most of application code, because it happens before Component is actually created).
   */
  mapMethods: function ()
  /* [predicate, ] iterator */
  {
    var iterator = _.last(arguments),
        predicate = arguments.length === 1 ? _.constant(true) : arguments[0];

    var methods = [];

    for (var k in this) {
      var def = this.constructor.$definition[k];

      if ($property.isNot(def)) {
        var fn = this[k];

        if (_.isFunction(fn) && !_.isPrototypeConstructor(fn) && predicate(def)) {
          this[k] = iterator.call(this, fn, k, def) || fn;
        }
      }
    }
  },
  enumMethods: function (_1, _2) {
    if (arguments.length === 2) {
      this.mapMethods(_1, _2.returns(undefined));
    } else {
      this.mapMethods(_1.returns(undefined));
    }
  },

  /*  Thou shall not override this
   */
  constructor: $final(function (arg1, arg2) {
    this.parent_ = undefined;
    this.children_ = [];
    var cfg = this.cfg = _typeof(arg1) === 'object' ? arg1 : {},
        componentDefinition = this.constructor.$definition;
    /*  Apply $defaults
     */

    if (this.constructor.$defaults) {
      cfg = this.cfg = _.extend(_.cloneDeep(this.constructor.$defaults), cfg);
    }
    /*  Add thiscall semantics to methods
     */


    this.mapMethods(function (fn, name, def) {
      if (name !== '$' && name !== 'init' && $raw.isNot(def)) {
        return this.$(fn);
      }
    });
    /*  Listen self destroy method
     */

    _.onBefore(this, 'destroy', this._beforeDestroy);

    _.onAfter(this, 'destroy', this._afterDestroy);

    var initialStreamListeners = [];
    var excludeFromCfg = {
      init: true
    };
    /*  Expand macros
        TODO: execute this substitution at $prototype code-gen level, not at instance level
     */

    _.each(componentDefinition, function (def, name) {
      var _this = this;

      if (def !== undefined) {
        var member = Meta.unwrap(def);
        var tags = Meta.tags(def);
        /*  Expand $observableProperty
            TODO: rewrite with $prototype.macro
         */

        if (tags.observableProperty) {
          var definitionValue = member;
          var defaultValue = name in cfg ? cfg[name] : definitionValue;
          var streamName = name + 'Change';
          /*  xxxChange stream
           */

          var observable = excludeFromCfg[streamName] = this[streamName] = _.observable();

          observable.context = this;
          observable.postpones = tags.postpones;
          /*  auto-coercion of incoming values to prototype instance
           */

          if (_.isPrototypeInstance(definitionValue)) {
            var constructor = definitionValue.constructor;

            observable.beforeWrite = function (value) {
              return constructor.isTypeOf(value) ? value : new constructor(value);
            };
          }
          /*  tracking by reference
           */


          if (tags.reference) {
            observable.trackReference = true;
          }
          /*  property
           */


          _.defineProperty(this, name, {
            get: function () {
              return observable.value;
            },
            set: function (x) {
              observable.write.call(this, x);
            }
          });
          /*  Default listeners (come from traits)
           */


          if (def.listeners) {
            _.each(def.listeners, function (value) {
              initialStreamListeners.push([observable, value]);
            });
          }
          /*  Default listener which comes from $observableProperty (defValue, defListener) syntax
           */


          if (_.isFunction(tags.observableProperty)) {
            initialStreamListeners.push([observable, tags.observableProperty]);
          }
          /*  write default value
           */


          if (defaultValue !== undefined) {
            observable(defaultValue);
          }
        }
        /*  Expand streams
         */
        else if (Component.isStreamDefinition(def)) {
            var stream = excludeFromCfg[name] = this[name] = _.extend((tags.trigger ? _.trigger : tags.triggerOnce ? _.triggerOnce : tags.observable ? _.observable : tags.barrier ? _.barrier : undefined)(member), {
              context: this,
              postpones: tags.postpones
            });
            /*  tracking by reference
             */


            if (tags.reference) {
              observable.trackReference = true;
            }

            if (def.listeners) {
              _.each(def.listeners, function (value) {
                initialStreamListeners.push([stream, value]);
              });
            }
            /*  Default listener which comes from $observable (defValue, defListener) syntax
             */


            if (_.isFunction(tags.observable)) {
              initialStreamListeners.push([stream, tags.observable]);
            }

            var defaultListener = cfg[name];

            if (defaultListener) {
              if (tags.observable && defaultListener.isObservable) {
                // two-way observable binding
                defaultListener.tie(stream);
              } else {
                initialStreamListeners.push([stream, defaultListener]);
              }
            }
          }
        /*  Expand $listener (TODO: REMOVE)
         */


        if (tags.listener) {
          this[name].queuedBy = [];
        }
        /*  Expand $interlocked
         */


        if (tags.interlocked) {
          this[name] = _.interlocked(this[name]);
        }
        /*  Expand $bindable
         */


        if (tags.bindable) {
          this[name] = _.extend(_.bindable(this[name], this), _.map2(tags.bindable.hooks || {}, function (hooks) {
            return _.map(hooks, function (f) {
              return _this.$(f);
            });
          }));
        }
        /*  Expand $debounce
         */


        if (tags.debounce) {
          var fn = this[name],
              opts = _.coerceToObject(tags.debounce);

          this[name] = fn.debounced(opts.wait || 500, opts.immediate);
        }
        /*  Expand $throttle
         */


        if (tags.throttle) {
          var fn = this[name],
              opts = _.coerceToObject(tags.throttle);

          this[name] = _.throttle(fn, opts.wait || 500, opts);
        }
        /*  Expand $memoize
         */


        if (tags.memoize) {
          this[name] = _.memoize(this[name]);
        } else if (tags.memoizeCPS) {
          this[name] = _.cps.memoize(this[name]);
        }
      }
    }, this);
    /*  Add before/after stage to init
     */


    var init = this.init;
    this.init = this._beforeInit.then(init.then(this._afterInit)).bind(this);
    /*  Apply cfg thing
     */

    _.each(cfg, function (value, name) {
      if (!(name in excludeFromCfg)) {
        this[name] = _.isFunction(value) ? this.$(value) : value;
      }
    }, this);
    /*  Fixup aliases (they're now pointing to nothing probably, considering what we've done at this point)
     */


    _.each(componentDefinition, function (def, name) {
      if ($alias.is(def) && $raw.isNot(def)) {
        this[name] = this[$untag(def)];
      }
    }, this);
    /*  Check $overrideThis
     */

    /*_.each (componentDefinition, function (def, name) {
        if (def.$overrideThis && this[name] === undefined) {
            throw new Error (name + ' should be overriden') } })*/

    /*  Check $requires (TODO: make human-readable error reporting)
     */


    if (_.hasAsserts) {
      _.each(this.constructor.$requires, function (contract, name) {
        $assertTypeMatches(_.fromPairs([[name, this[name]]]), _.fromPairs([[name, contract]]));
      }, this);
    }
    /*  Subscribe default listeners
     */


    _.each(initialStreamListeners, function (v) {
      v[0].call(this, v[1]);
    }, this);
    /*  Call init (if not marked as deferred)
     */


    if (!(cfg.init === false || this.constructor.$defaults && this.constructor.$defaults.init === false)) {
      var result = this.init();

      if (result instanceof Promise) {
        result.panic;
      }
    }
  }),

  /*  Arranges methods defined in $traits in chains and evals them
   */
  methodChain: function (name) {
    var _this2 = this;

    var {
      reverse = false,
      until = function () {
        return false;
      }
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var methods = _.filter2(this.constructor.$traits || [], function (Trait) {
      var method = Trait.prototype[name];
      return method && method.bind(_this2) || false;
    });

    return function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return __.each(reverse ? methods.reverse() : methods, function (fn, i, break_) {
        return __.then(fn.apply(void 0, args), function (returnValue) {
          if (until(returnValue)) {
            break_();
          }
        });
      });
    };
  },

  /*  LEGACY
      TODO: find why methodChain () does not work as a replacement    */
  callChainMethod: function (name) {
    var self = this; //console.log ('callChainMethod', this.constructor.$meta.name, name)

    var methods = _.filter2(this.constructor.$traits || [], function (Trait) {
      var method = Trait.prototype[name]; // if (method) {
      //     return (...args) => {
      //         console.log ('Calling', Trait.$meta.name, name)
      //         return method.call (self, ...args)
      //     }
      // }

      return method && method.bind(self) || false;
    });

    return __.seq(methods);
  },

  /*  Lifecycle
   */
  _beforeInit: function () {
    if (this.initialized.already) {
      throw new Error('Component: I am already initialized. Probably you\'re doing it wrong.');
    }

    return this.callChainMethod('beforeInit');
  },
  init: function () {
    /* return Promise for asynchronous init */
  },
  _afterInit: function () {
    var cfg = this.cfg,
        self = this;
    return __.then(this.callChainMethod.$('afterInit'), function () {
      self.initialized(true);
      self.alive(true);
      /*  Bind default property listeners. Doing this after init, because property listeners
          get called immediately after bind (observable semantics), and we're want to make
          sure that component is initialized at the moment of call.
           We do not do this for other streams, as their execution is up to component logic,
          and they're might get called at init, so their default values get bound before init.
       */

      _.each(self.constructor.$definition, function (def, name) {
        if ($observableProperty.is(def)) {
          name += 'Change';
          var defaultListener = cfg[name];

          if (defaultListener) {
            self[name](defaultListener);
          }
        }
      });

      return true;
    });
  },
  initialized: $barrier(),
  alive: $observable(false),
  _beforeDestroy: function () {
    if (this.destroyed_) {
      throw new Error('Component: I am already destroyed. Probably you\'re doing it wrong.');
    }

    if (this.destroying_) {
      throw new Error('Component: Recursive destroy() call detected. Probably you\'re doing it wrong.');
    }

    this.destroying_ = true;

    _.each(this.constructor.$traits, function (Trait) {
      if (Trait.prototype.beforeDestroy) {
        Trait.prototype.beforeDestroy.call(this);
      }
    }, this);

    this.alive(false);
    /*  Unbind streams
     */

    this.enumMethods(_.off.arity1);
    /*  Destroy children
     */

    _.each(this.children_, _.method('destroy'));

    this.children_ = [];
  },
  destroy: function () {},
  _afterDestroy: function () {
    _.each(this.constructor.$traits, function (Trait) {
      if (Trait.prototype.destroy) {
        Trait.prototype.destroy.call(this);
      }

      if (Trait.prototype.afterDestroy) {
        Trait.prototype.afterDestroy.call(this);
      }
    }, this);

    delete this.destroying_;
    this.parent_ = undefined;
    this.destroyed_ = true;
  },

  /*  Parent manip.
   */
  attachedTo: $property(function () {
    return this.parent_;
  }),
  attachTo: function (p) {
    if (p === this) {
      throw new Error('smells like time-travel paradox.. how else can I be parent of myself?');
    }

    if (this.parent_ !== p) {
      if (this.parent_ !== undefined) {
        this.parent_.children_.remove(this);
      }

      if ((this.parent_ = p) !== undefined) {
        this.parent_.children_.push(this);
      }
    }

    return this;
  },
  detach: function () {
    return this.attachTo(undefined);
  },

  /*  Child manip.
   */
  attached: $property(function () {
    return this.children_;
  }),
  attach: function (c) {
    _.invoke(_.coerceToArray(c), 'attachTo', this);

    return this;
  },
  detachAll: function () {
    _.each(this.children_, function (c) {
      c.parent_ = undefined;
    });

    this.children_ = [];
    return this;
  },
  destroyAll: function () {
    _.each(this.children_, function (c) {
      c.parent_ = undefined;
      c.destroy();
    });

    this.children_ = [];
    return this;
  }
});
},{"underscore":"node_modules/underscore/underscore.js"}],"node_modules/useless/base/Rx.js":[function(require,module,exports) {
"use strict";

var _ = require('underscore');

$global.R = $singleton({
  $test: function () {
    var $assertExpr = function (a, b) {
      $assert(a, _.quote(b.str, '//'));
    };
    /*  R should be used for code clarity purposes when one needs to generate a
        complex regular expression that is hard to read and maintain.
     */


    $assertExpr('/[^\\s]*/', $r.anyOf.except.space.$);
    $assertExpr('/\\[.*\\]|[\\s]/', $r.anything.inBrackets.or.oneOf.space.$);
    var expr = $r.expr('before', $r.anything.text('$print').something).then($r.expr('argument', $r.someOf.except.text(',)')).inParentheses.then($r.expr('tail', $r.anything))).$;
    /*  Above construction generates the following regular expression
     */

    $assertExpr('/(.*\\$print.+)\\(([^,\\)]+)\\)(.*)/', expr);
    /*  Main feature: named groups, easily accessible as dictionary elements.
     */

    $assert(expr.parse(' var x = $print (blabla) // lalala '), {
      before: ' var x = $print ',
      argument: 'blabla',
      tail: ' // lalala '
    });
    /*  Based on Lisp-like list based syntax, for easy programmatic generation and stuff
     */

    $assert([['[^', '\\s', "\]"], '*'], R.anyOf(R.except(R.space)));
  },
  constructor: function () {
    this.reduce = _.hyperOperator(_.binary, _.reduce2, _.goDeeperAlwaysIfPossible, _.isNonTrivial.and(_.not(this.isSubexpr)));
    this.initDSL();
  },
  expr: function (expr, subexprs) {
    subexprs = subexprs || [];
    return new R.Expr(R.reduce('', expr, function (memo, s) {
      if (R.isSubexpr(s)) {
        subexprs.push(s);
        return memo + R.expr(R.root(s.value), subexprs).str;
      } else {
        return memo + s;
      }
    }), subexprs);
  },
  Expr: $prototype({
    constructor: function (str, subexprs) {
      this.rx = new RegExp();
      this.rx.compile(str);
      this.str = str;
      this.subexprs = subexprs;
    },
    parse: function (str) {
      var match = str.match(this.rx);
      return match && _.extend.apply(null, _.zipWith([match.slice(1), this.subexprs], function (match, subexpr) {
        return _.fromPairs([[subexpr.name, match]]);
      })) || {};
    }
  }),
  escape: function (s) {
    return _.map(s, function (x) {
      return R.metacharacters[x] ? '\\' + x : x;
    }).join('');
  },
  text: $alias('escape'),
  subexpr: function (name, s) {
    return {
      name: name,
      value: ['(', s, ')']
    };
  },
  maybe: function (s) {
    return [s, '?'];
  },
  anyOf: function (s) {
    return [s, '*'];
  },
  someOf: function (s) {
    return [s, '+'];
  },
  oneOf: function (s) {
    return ['[', s, ']'];
  },
  except: function (s) {
    return ['[^', s, ']'];
  },
  or: function (a, b) {
    return [a, '|', b];
  },
  $property: {
    metacharacters: _.index('\\^$.|?*+()[{'),
    begin: '^',
    end: '$',
    space: '\\s',
    maybeSpaces: '\\s*',
    spaces: '\\s+',
    anything: '.*',
    something: '.+',
    comma: ','
  },
  parentheses: function (s) {
    return ['\\(', s, '\\)'];
  },
  brackets: function (s) {
    return ['\\[', s, '\\]'];
  },
  isSubexpr: function (s) {
    return _.isStrictlyObject(s) && !_.isArray(s) ? true : false;
  },
  root: function (r) {
    return r && r.$$ ? r.$$ : r;
  },
  initDSL: function () {
    $global.property('$r', function () {
      return $$r([]);
    });
    $global.const('$$r', function (cursor) {
      var shift = function (x) {
        return cursor.push(x), cursor.forward;
      };

      var def = _.defineHiddenProperty;
      def(cursor, 'then', function (x) {
        cursor.push(R.root(x));
        return cursor;
      });
      def(cursor, 'text', function (x) {
        cursor.push(R.text(x));
        return cursor;
      });
      def(cursor, 'expr', function (x, s) {
        cursor.push(R.subexpr(x, R.root(s)));
        return cursor;
      });
      def(cursor, 'forward', function () {
        return cursor.next || ((cursor.next = $r).prev = cursor).next;
      });

      _.each(['maybe', 'anyOf', 'someOf', 'oneOf', 'except'], function (key) {
        def(cursor, key, function () {
          return shift(R[key](cursor.forward));
        });
      });

      _.each(['parentheses', 'brackets'], function (key) {
        return def(cursor, 'in' + key.capitalized, function () {
          return cursor.$$.prev = $$r(R[key](cursor.$$));
        });
      });

      _.each(['or'], function (key) {
        return def(cursor, key, function () {
          var next = $r;
          return (next.prev = cursor.$$.prev = $$r(R[key](cursor.$$, next))).next = next;
        });
      });

      _.each(['begin', 'end', 'space', 'anything', 'something'], function (key) {
        return def(cursor, key, function () {
          return shift([R[key], cursor.forward]);
        });
      });

      def(cursor, '$$', function () {
        var root = cursor;

        while (root.prev) {
          root = root.prev;
        }

        return root;
      });
      def(cursor, '$', function () {
        return R.expr(cursor.$$);
      });
      return cursor;
    });
  }
});
},{"underscore":"node_modules/underscore/underscore.js"}],"node_modules/string.ify/build/string.ify.js":[function(require,module,exports) {
var global = arguments[3];
"use strict";

function _objectValues(obj) {
    var values = [];
    var keys = Object.keys(obj);

    for (var k = 0; k < keys.length; ++k) values.push(obj[keys[k]]);

    return values;
}

function _objectEntries(obj) {
    var entries = [];
    var keys = Object.keys(obj);

    for (var k = 0; k < keys.length; ++k) entries.push([keys[k], obj[keys[k]]]);

    return entries;
}

const bullet = require('string.bullet'),
      isBrowser = typeof window !== 'undefined' && window.window === window && window.navigator,
      maxOf = (arr, pick) => arr.reduce((max, s) => Math.max(max, pick ? pick(s) : s), 0),
      isInteger = Number.isInteger || (value => typeof value === 'number' && isFinite(value) && Math.floor(value) === value),
      isTypedArray = x => x instanceof Float32Array || x instanceof Float64Array || x instanceof Int8Array || x instanceof Uint8Array || x instanceof Uint8ClampedArray || x instanceof Int16Array || x instanceof Int32Array || x instanceof Uint32Array;

const assignProps = (to, from) => {
    for (const prop in from) {
        Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
    };return to;
};

const escapeStr = x => x.replace(/\n/g, '\\n').replace(/\'/g, "\\'").replace(/\"/g, '\\"');

const { first, strlen } = require('printable-characters'); // handles ANSI codes and invisible characters

const limit = (s, n) => s && (strlen(s) <= n ? s : first(s, n - 1) + '');

const configure = cfg => {

    const stringify = x => {

        const state = Object.assign({ parents: new Set(), siblings: new Map() }, cfg);

        if (cfg.pretty === 'auto') {
            const oneLine = stringify.configure({ pretty: false, siblings: new Map() })(x);
            return oneLine.length <= cfg.maxLength ? oneLine : stringify.configure({ pretty: true, siblings: new Map() })(x);
        }

        var customFormat = cfg.formatter && cfg.formatter(x, stringify);

        if (typeof customFormat === 'string') {
            return customFormat;
        }

        if (typeof jQuery !== 'undefined' && x instanceof jQuery) {
            x = x.toArray();
        } else if (isTypedArray(x)) {
            x = Array.from(x);
        }

        if (isBrowser && x === window) {
            return 'window';
        } else if (!isBrowser && typeof global !== 'undefined' && x === global) {
            return 'global';
        } else if (x === null) {
            return 'null';
        } else if (x instanceof Date) {
            return state.pure ? x.getTime() : "  " + x.toString();
        } else if (x instanceof RegExp) {
            return state.json ? '"' + x.toString() + '"' : x.toString();
        } else if (state.parents.has(x)) {
            return state.pure ? undefined : '<cyclic>';
        } else if (!state.pure && state.siblings.has(x)) {
            return '<ref:' + state.siblings.get(x) + '>';
        } else if (x && typeof Symbol !== 'undefined' && (customFormat = x[Symbol.for('String.ify')]) && typeof customFormat === 'function' && typeof (customFormat = customFormat.call(x, stringify.configure(state))) === 'string') {

            return customFormat;
        } else if (x instanceof Function) {
            return cfg.pure ? x.toString() : x.name ? '<function:' + x.name + '>' : '<function>';
        } else if (typeof x === 'string') {
            return '"' + escapeStr(limit(x, cfg.pure ? Number.MAX_SAFE_INTEGER : cfg.maxStringLength)) + '"';
        } else if (x instanceof Promise && !state.pure) {
            return '<Promise>';
        } else if (typeof x === 'object') {

            state.parents.add(x);
            state.siblings.set(x, state.siblings.size);

            const result = stringify.configure(Object.assign({}, state, { pretty: state.pretty === false ? false : 'auto', depth: state.depth + 1 })).object(x);

            state.parents.delete(x);

            return result;
        } else if (typeof x === 'number' && !isInteger(x) && cfg.precision > 0) {
            return x.toFixed(cfg.precision);
        } else {
            return String(x);
        }
    };

    /*  API  */

    assignProps(stringify, {

        state: cfg,

        configure: newConfig => configure(Object.assign({}, cfg, newConfig)),

        /*  TODO: generalize generation of these chain-style .configure helpers (maybe in a separate library, as it looks like a common pattern)    */

        get pretty() {
            return stringify.configure({ pretty: true });
        },
        get noPretty() {
            return stringify.configure({ pretty: false });
        },

        get json() {
            return stringify.configure({ json: true, pure: true });
        },
        get pure() {
            return stringify.configure({ pure: true });
        },

        maxStringLength(n = Number.MAX_SAFE_INTEGER) {
            return stringify.configure({ maxStringLength: n });
        },
        maxArrayLength(n = Number.MAX_SAFE_INTEGER) {
            return stringify.configure({ maxArrayLength: n });
        },
        maxDepth(n = Number.MAX_SAFE_INTEGER) {
            return stringify.configure({ maxDepth: n });
        },
        maxLength(n = Number.MAX_SAFE_INTEGER) {
            return stringify.configure({ maxLength: n });
        },

        precision(p) {
            return stringify.configure({ precision: p });
        },
        formatter(f) {
            return stringify.configure({ formatter: f });
        },

        /*  Some undocumented internals    */

        limit,

        rightAlign: strings => {
            var max = maxOf(strings, s => s.length);
            return strings.map(s => ' '.repeat(max - s.length) + s);
        },

        object: x => {

            if (x instanceof Set) {
                x = Array.from(x.values());
            } else if (x instanceof Map) {
                x = Array.from(x.entries());
            }

            const isArray = Array.isArray(x);

            if (isBrowser) {

                if (x instanceof Element) {
                    return '<' + (x.tagName.toLowerCase() + (x.id && '#' + x.id || '') + (x.className && '.' + x.className || '')) + '>';
                } else if (x instanceof Text) {
                    return '@' + stringify.limit(x.wholeText, 20);
                }
            }

            if (!cfg.pure && (cfg.depth > cfg.maxDepth || isArray && x.length > cfg.maxArrayLength)) {
                return isArray ? '<array[' + x.length + ']>' : '<object>';
            }

            const pretty = cfg.pretty ? true : false,
                  entries = _objectEntries(x),
                  oneLine = !pretty || entries.length < 2,
                  quoteKey = cfg.json ? k => '"' + escapeStr(k) + '"' : k => /^[A-z][A-z0-9]*$/.test(k) ? k : "'" + escapeStr(k) + "'";

            if (pretty) {

                const values = _objectValues(x),
                      printedKeys = stringify.rightAlign(Object.keys(x).map(k => quoteKey(k) + ': ')),
                      printedValues = values.map(stringify),
                      leftPaddings = printedValues.map((x, i) => x[0] === '[' || x[0] === '{' ? 3 : typeof values[i] === 'string' ? 1 : 0),
                      maxLeftPadding = maxOf(leftPaddings),
                      items = leftPaddings.map((padding, i) => {
                    const value = ' '.repeat(maxLeftPadding - padding) + printedValues[i];
                    return isArray ? value : bullet(printedKeys[i], value);
                }),
                      printed = bullet(isArray ? '[ ' : '{ ', items.join(',\n')),
                      lines = printed.split('\n'),
                      lastLine = lines[lines.length - 1];

                return printed + (' '.repeat(maxOf(lines, l => l.length) - lastLine.length) + (isArray ? ' ]' : ' }'));
            } else {

                const items = entries.map(kv => (isArray ? '' : quoteKey(kv[0]) + ': ') + stringify(kv[1])),
                      content = items.join(', ');

                return isArray ? '[' + content + ']' : '{ ' + content + ' }';
            }
        }
    });

    return stringify;
};

module.exports = configure({

    depth: 0,
    pure: false,
    json: false,
    //  color:           false, // not supported yet
    maxDepth: 5,
    maxLength: 50,
    maxArrayLength: 60,
    maxStringLength: 60,
    precision: undefined,
    formatter: undefined,
    pretty: 'auto'
});


},{"string.bullet":"node_modules/string.bullet/string.bullet.js","printable-characters":"node_modules/printable-characters/build/printable-characters.js"}],"node_modules/ansicolor/build/ansicolor.js":[function(require,module,exports) {
"use strict";

/*  ------------------------------------------------------------------------ */

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

const O = Object;

/*  See https://misc.flogisoft.com/bash/tip_colors_and_formatting
    ------------------------------------------------------------------------ */

const colorCodes = ['black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'lightGray', '', 'default'],
      colorCodesLight = ['darkGray', 'lightRed', 'lightGreen', 'lightYellow', 'lightBlue', 'lightMagenta', 'lightCyan', 'white', ''],
      styleCodes = ['', 'bright', 'dim', 'italic', 'underline', '', '', 'inverse'],
      asBright = { 'red': 'lightRed',
    'green': 'lightGreen',
    'yellow': 'lightYellow',
    'blue': 'lightBlue',
    'magenta': 'lightMagenta',
    'cyan': 'lightCyan',
    'black': 'darkGray',
    'lightGray': 'white' },
      types = { 0: 'style',
    2: 'unstyle',
    3: 'color',
    9: 'colorLight',
    4: 'bgColor',
    10: 'bgColorLight' },
      subtypes = { color: colorCodes,
    colorLight: colorCodesLight,
    bgColor: colorCodes,
    bgColorLight: colorCodesLight,
    style: styleCodes,
    unstyle: styleCodes

    /*  ------------------------------------------------------------------------ */

};const clean = obj => {
    for (const k in obj) {
        if (!obj[k]) {
            delete obj[k];
        }
    }
    return O.keys(obj).length === 0 ? undefined : obj;
};

/*  ------------------------------------------------------------------------ */

class Color {

    constructor(background, name, brightness) {

        this.background = background;
        this.name = name;
        this.brightness = brightness;
    }

    get inverse() {
        return new Color(!this.background, this.name || (this.background ? 'black' : 'white'), this.brightness);
    }

    get clean() {
        return clean({ name: this.name === 'default' ? '' : this.name,
            bright: this.brightness === Code.bright,
            dim: this.brightness === Code.dim });
    }

    defaultBrightness(value) {

        return new Color(this.background, this.name, this.brightness || value);
    }

    css(inverted) {

        const color = inverted ? this.inverse : this;

        const rgbName = color.brightness === Code.bright && asBright[color.name] || color.name;

        const prop = color.background ? 'background:' : 'color:',
              rgb = Colors.rgb[rgbName],
              alpha = this.brightness === Code.dim ? 0.5 : 1;

        return rgb ? prop + 'rgba(' + [].concat(_toConsumableArray(rgb), [alpha]).join(',') + ');' : !color.background && alpha < 1 ? 'color:rgba(0,0,0,0.5);' : ''; // Chrome does not support 'opacity' property...
    }
}

/*  ------------------------------------------------------------------------ */

class Code {

    constructor(n) {
        if (n !== undefined) {
            this.value = Number(n);
        }
    }

    get type() {
        return types[Math.floor(this.value / 10)];
    }

    get subtype() {
        return subtypes[this.type][this.value % 10];
    }

    get str() {
        return this.value ? '\u001b\[' + this.value + 'm' : '';
    }

    static str(x) {
        return new Code(x).str;
    }

    get isBrightness() {
        return this.value === Code.noBrightness || this.value === Code.bright || this.value === Code.dim;
    }
}

/*  ------------------------------------------------------------------------ */

O.assign(Code, {

    bright: 1,
    dim: 2,
    inverse: 7,
    noBrightness: 22,
    noItalic: 23,
    noUnderline: 24,
    noInverse: 27,
    noColor: 39,
    noBgColor: 49
});

/*  ------------------------------------------------------------------------ */

const replaceAll = (str, a, b) => str.split(a).join(b);

/*  ANSI brightness codes do not overlap, e.g. "{bright}{dim}foo" will be rendered bright (not dim).
    So we fix it by adding brightness canceling before each brightness code, so the former example gets
    converted to "{noBrightness}{bright}{noBrightness}{dim}foo"  this way it gets rendered as expected.
 */

const denormalizeBrightness = s => s.replace(/(\u001b\[(1|2)m)/g, '\u001b[22m$1');
const normalizeBrightness = s => s.replace(/\u001b\[22m(\u001b\[(1|2)m)/g, '$1');

const wrap = (x, openCode, closeCode) => {

    const open = Code.str(openCode),
          close = Code.str(closeCode);

    return String(x).split('\n').map(line => denormalizeBrightness(open + replaceAll(normalizeBrightness(line), close, open) + close)).join('\n');
};

/*  ------------------------------------------------------------------------ */

const camel = (a, b) => a + b.charAt(0).toUpperCase() + b.slice(1);

const stringWrappingMethods = (() => [].concat(_toConsumableArray(colorCodes.map((k, i) => !k ? [] : [// color methods

[k, 30 + i, Code.noColor], [camel('bg', k), 40 + i, Code.noBgColor]])), _toConsumableArray(colorCodesLight.map((k, i) => !k ? [] : [// light color methods

[k, 90 + i, Code.noColor], [camel('bg', k), 100 + i, Code.noBgColor]])), _toConsumableArray(['', 'BrightRed', 'BrightGreen', 'BrightYellow', 'BrightBlue', 'BrightMagenta', 'BrightCyan'].map((k, i) => !k ? [] : [['bg' + k, 100 + i, Code.noBgColor]])), _toConsumableArray(styleCodes.map((k, i) => !k ? [] : [// style methods

[k, i, k === 'bright' || k === 'dim' ? Code.noBrightness : 20 + i]]))).reduce((a, b) => a.concat(b)))();

/*  ------------------------------------------------------------------------ */

const assignStringWrappingAPI = function (target) {
    let wrapBefore = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : target;
    return stringWrappingMethods.reduce((memo, _ref) => {
        var _ref2 = _slicedToArray(_ref, 3);

        let k = _ref2[0],
            open = _ref2[1],
            close = _ref2[2];
        return O.defineProperty(memo, k, {
            get: () => assignStringWrappingAPI(str => wrapBefore(wrap(str, open, close)))
        });
    }, target);
};

/*  ------------------------------------------------------------------------ */

/**
 * Represents an ANSI-escaped string.
 */
class Colors {

    /**
     * @param {string} s a string containing ANSI escape codes.
     */
    constructor(s) {

        if (s) {

            const r = /\u001b\[(\d+)m/g;

            const spans = s.split(/\u001b\[\d+m/);
            const codes = [];

            for (let match; match = r.exec(s);) codes.push(match[1]);

            this.spans = spans.map((s, i) => ({ text: s, code: new Code(codes[i]) }));
        } else {
            this.spans = [];
        }
    }

    get str() {
        return this.spans.reduce((str, p) => str + p.text + p.code.str, '');
    }

    get parsed() {

        var color = new Color(),
            bgColor = new Color(true /* background */),
            brightness = undefined,
            styles = new Set();

        return O.assign(new Colors(), {

            spans: this.spans.map(span => {

                const c = span.code;

                const inverted = styles.has('inverse'),
                      underline = styles.has('underline') ? 'text-decoration: underline;' : '',
                      italic = styles.has('italic') ? 'font-style: italic;' : '',
                      bold = brightness === Code.bright ? 'font-weight: bold;' : '';

                const foreColor = color.defaultBrightness(brightness);

                const styledSpan = O.assign({ css: bold + italic + underline + foreColor.css(inverted) + bgColor.css(inverted) }, clean({ bold: !!bold, color: foreColor.clean, bgColor: bgColor.clean }), span);

                for (const k of styles) {
                    styledSpan[k] = true;
                }

                if (c.isBrightness) {

                    brightness = c.value;
                } else {

                    switch (span.code.type) {

                        case 'color':
                        case 'colorLight':
                            color = new Color(false, c.subtype);break;

                        case 'bgColor':
                        case 'bgColorLight':
                            bgColor = new Color(true, c.subtype);break;

                        case 'style':
                            styles.add(c.subtype);break;
                        case 'unstyle':
                            styles.delete(c.subtype);break;
                    }
                }

                return styledSpan;
            }).filter(s => s.text.length > 0)
        });
    }

    /*  Outputs with Chrome DevTools-compatible format     */

    get asChromeConsoleLogArguments() {

        const spans = this.parsed.spans;

        return [spans.map(s => '%c' + s.text).join('')].concat(_toConsumableArray(spans.map(s => s.css)));
    }

    get browserConsoleArguments() /* LEGACY, DEPRECATED */{
        return this.asChromeConsoleLogArguments;
    }

    /**
     * @desc installs String prototype extensions
     * @example
     * require ('ansicolor').nice
     * console.log ('foo'.bright.red)
     */
    static get nice() {

        Colors.names.forEach(k => {
            if (!(k in String.prototype)) {
                O.defineProperty(String.prototype, k, { get: function () {
                        return Colors[k](this);
                    } });
            }
        });

        return Colors;
    }

    /**
     * @desc parses a string containing ANSI escape codes
     * @return {Colors} parsed representation.
     */
    static parse(s) {
        return new Colors(s).parsed;
    }

    /**
     * @desc strips ANSI codes from a string
     * @param {string} s a string containing ANSI escape codes.
     * @return {string} clean string.
     */
    static strip(s) {
        return s.replace(/[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g, ''); // hope V8 caches the regexp
    }

    /**
     * @example
     * const spans = [...ansi.parse ('\u001b[7m\u001b[7mfoo\u001b[7mbar\u001b[27m')]
     */
    [Symbol.iterator]() {
        return this.spans[Symbol.iterator]();
    }
}

/*  ------------------------------------------------------------------------ */

assignStringWrappingAPI(Colors, str => str);

/*  ------------------------------------------------------------------------ */

Colors.names = stringWrappingMethods.map((_ref3) => {
    var _ref4 = _slicedToArray(_ref3, 1);

    let k = _ref4[0];
    return k;
});

/*  ------------------------------------------------------------------------ */

Colors.rgb = {

    black: [0, 0, 0],
    darkGray: [100, 100, 100],
    lightGray: [200, 200, 200],
    white: [255, 255, 255],

    red: [204, 0, 0],
    lightRed: [255, 51, 0],

    green: [0, 204, 0],
    lightGreen: [51, 204, 51],

    yellow: [204, 102, 0],
    lightYellow: [255, 153, 51],

    blue: [0, 0, 255],
    lightBlue: [26, 140, 255],

    magenta: [204, 0, 204],
    lightMagenta: [255, 0, 255],

    cyan: [0, 153, 255],
    lightCyan: [0, 204, 255]

    /*  ------------------------------------------------------------------------ */

};module.exports = Colors;

/*  ------------------------------------------------------------------------ */


},{}],"node_modules/useless/base/uncaught.js":[function(require,module,exports) {
"use strict";
/*  Uncaught exception handling facility
    ======================================================================== */

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

(function () {
  _.hasUncaught = true;
  var reThrownTag = ' [re-thrown by a hook]'; // marks error as already processed by globalUncaughtExceptionHandler

  var globalUncaughtExceptionHandler = _.globalUncaughtExceptionHandler = function (e) {
    var chain = globalUncaughtExceptionHandler.chain;
    globalUncaughtExceptionHandler.chain = _.reject(chain, _.property('catchesOnce'));

    if (chain.length) {
      for (var i = 0, n = chain.length; i < n; i++) {
        try {
          chain[i](e);
          break;
        } catch (newE) {
          if (i === n - 1) {
            console.log(newE);
            newE.message += reThrownTag;
            throw newE;
            break;
          } else {
            if (newE && _typeof(newE) === 'object') {
              newE.originalError = e;
            }

            e = newE;
          }
        }
      }
    } else {
      e.message += reThrownTag;
      console.log(e);
      throw e;
    }
  };

  _.withUncaughtExceptionHandler = function (handler, context_) {
    var context = context_ || _.identity;

    if (context_) {
      handler.catchesOnce = true;
    }

    globalUncaughtExceptionHandler.chain.unshift(handler);
    context(function () {
      globalUncaughtExceptionHandler.chain.remove(handler);
    });
  };

  globalUncaughtExceptionHandler.chain = [];

  switch ($platform.engine) {
    case 'node':
      require('process').on('uncaughtException', globalUncaughtExceptionHandler);

      require('process').on('unhandledRejection', globalUncaughtExceptionHandler);

      break;

    case 'browser':
      // window.addEventListener ('unhandledrejection', function (e) {
      //     globalUncaughtExceptionHandler (_.extend (new Error (e.reason), { stub: true }))
      // })
      window.addEventListener('error', function (e) {
        if (!e.message.includes(reThrownTag) && !(e.error === null && e.lineno === 0 && e.colno === 0 && e.filename === '')) {
          // if not already processed by async hooks
          if (e.error) {
            globalUncaughtExceptionHandler(e.error);
          } else {
            // emulate missing .error (that's Safari)
            globalUncaughtExceptionHandler(_.extend(new Error(e.message), {
              stub: true,
              stack: 'at ' + e.filename + ':' + e.lineno + ':' + e.colno
            }));
          }
        }
      });
  }
})();
},{"process":"../../../../.nvm/versions/node/v12.18.3/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"node_modules/get-source/node_modules/source-map/lib/base64.js":[function(require,module,exports) {
/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */

exports.encode = function (number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }

  throw new TypeError("Must be between 0 and 63: " + number);
};
/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */


exports.decode = function (charCode) {
  var bigA = 65; // 'A'

  var bigZ = 90; // 'Z'

  var littleA = 97; // 'a'

  var littleZ = 122; // 'z'

  var zero = 48; // '0'

  var nine = 57; // '9'

  var plus = 43; // '+'

  var slash = 47; // '/'

  var littleOffset = 26;
  var numberOffset = 52; // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ

  if (bigA <= charCode && charCode <= bigZ) {
    return charCode - bigA;
  } // 26 - 51: abcdefghijklmnopqrstuvwxyz


  if (littleA <= charCode && charCode <= littleZ) {
    return charCode - littleA + littleOffset;
  } // 52 - 61: 0123456789


  if (zero <= charCode && charCode <= nine) {
    return charCode - zero + numberOffset;
  } // 62: +


  if (charCode == plus) {
    return 62;
  } // 63: /


  if (charCode == slash) {
    return 63;
  } // Invalid base64 digit.


  return -1;
};
},{}],"node_modules/get-source/node_modules/source-map/lib/base64-vlq.js":[function(require,module,exports) {
/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
var base64 = require('./base64'); // A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011


var VLQ_BASE_SHIFT = 5; // binary: 100000

var VLQ_BASE = 1 << VLQ_BASE_SHIFT; // binary: 011111

var VLQ_BASE_MASK = VLQ_BASE - 1; // binary: 100000

var VLQ_CONTINUATION_BIT = VLQ_BASE;
/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */

function toVLQSigned(aValue) {
  return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
}
/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */


function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative ? -shifted : shifted;
}
/**
 * Returns the base 64 VLQ encoded value.
 */


exports.encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;
  var vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;

    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }

    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};
/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */


exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }

    digit = base64.decode(aStr.charCodeAt(aIndex++));

    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }

    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};
},{"./base64":"node_modules/get-source/node_modules/source-map/lib/base64.js"}],"node_modules/get-source/node_modules/source-map/lib/util.js":[function(require,module,exports) {
/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  } else {
    throw new Error('"' + aName + '" is a required argument.');
  }
}

exports.getArg = getArg;
var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;

function urlParse(aUrl) {
  var match = aUrl.match(urlRegexp);

  if (!match) {
    return null;
  }

  return {
    scheme: match[1],
    auth: match[2],
    host: match[3],
    port: match[4],
    path: match[5]
  };
}

exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
  var url = '';

  if (aParsedUrl.scheme) {
    url += aParsedUrl.scheme + ':';
  }

  url += '//';

  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + '@';
  }

  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }

  if (aParsedUrl.port) {
    url += ":" + aParsedUrl.port;
  }

  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }

  return url;
}

exports.urlGenerate = urlGenerate;
/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */

function normalize(aPath) {
  var path = aPath;
  var url = urlParse(aPath);

  if (url) {
    if (!url.path) {
      return aPath;
    }

    path = url.path;
  }

  var isAbsolute = exports.isAbsolute(path);
  var parts = path.split(/\/+/);

  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
    part = parts[i];

    if (part === '.') {
      parts.splice(i, 1);
    } else if (part === '..') {
      up++;
    } else if (up > 0) {
      if (part === '') {
        // The first part is blank if the path is absolute. Trying to go
        // above the root is a no-op. Therefore we can remove all '..' parts
        // directly after the root.
        parts.splice(i + 1, up);
        up = 0;
      } else {
        parts.splice(i, 2);
        up--;
      }
    }
  }

  path = parts.join('/');

  if (path === '') {
    path = isAbsolute ? '/' : '.';
  }

  if (url) {
    url.path = path;
    return urlGenerate(url);
  }

  return path;
}

exports.normalize = normalize;
/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */

function join(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  if (aPath === "") {
    aPath = ".";
  }

  var aPathUrl = urlParse(aPath);
  var aRootUrl = urlParse(aRoot);

  if (aRootUrl) {
    aRoot = aRootUrl.path || '/';
  } // `join(foo, '//www.example.org')`


  if (aPathUrl && !aPathUrl.scheme) {
    if (aRootUrl) {
      aPathUrl.scheme = aRootUrl.scheme;
    }

    return urlGenerate(aPathUrl);
  }

  if (aPathUrl || aPath.match(dataUrlRegexp)) {
    return aPath;
  } // `join('http://', 'www.example.com')`


  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    aRootUrl.host = aPath;
    return urlGenerate(aRootUrl);
  }

  var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

  if (aRootUrl) {
    aRootUrl.path = joined;
    return urlGenerate(aRootUrl);
  }

  return joined;
}

exports.join = join;

exports.isAbsolute = function (aPath) {
  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
};
/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */


function relative(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  aRoot = aRoot.replace(/\/$/, ''); // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.

  var level = 0;

  while (aPath.indexOf(aRoot + '/') !== 0) {
    var index = aRoot.lastIndexOf("/");

    if (index < 0) {
      return aPath;
    } // If the only part of the root that is left is the scheme (i.e. http://,
    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    // have exhausted all components, so the path is not relative to the root.


    aRoot = aRoot.slice(0, index);

    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
      return aPath;
    }

    ++level;
  } // Make sure we add a "../" for each component we removed from the root.


  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}

exports.relative = relative;

var supportsNullProto = function () {
  var obj = Object.create(null);
  return !('__proto__' in obj);
}();

function identity(s) {
  return s;
}
/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */


function toSetString(aStr) {
  if (isProtoString(aStr)) {
    return '$' + aStr;
  }

  return aStr;
}

exports.toSetString = supportsNullProto ? identity : toSetString;

function fromSetString(aStr) {
  if (isProtoString(aStr)) {
    return aStr.slice(1);
  }

  return aStr;
}

exports.fromSetString = supportsNullProto ? identity : fromSetString;

function isProtoString(s) {
  if (!s) {
    return false;
  }

  var length = s.length;

  if (length < 9
  /* "__proto__".length */
  ) {
      return false;
    }

  if (s.charCodeAt(length - 1) !== 95
  /* '_' */
  || s.charCodeAt(length - 2) !== 95
  /* '_' */
  || s.charCodeAt(length - 3) !== 111
  /* 'o' */
  || s.charCodeAt(length - 4) !== 116
  /* 't' */
  || s.charCodeAt(length - 5) !== 111
  /* 'o' */
  || s.charCodeAt(length - 6) !== 114
  /* 'r' */
  || s.charCodeAt(length - 7) !== 112
  /* 'p' */
  || s.charCodeAt(length - 8) !== 95
  /* '_' */
  || s.charCodeAt(length - 9) !== 95
  /* '_' */
  ) {
      return false;
    }

  for (var i = length - 10; i >= 0; i--) {
    if (s.charCodeAt(i) !== 36
    /* '$' */
    ) {
        return false;
      }
  }

  return true;
}
/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */


function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  var cmp = strcmp(mappingA.source, mappingB.source);

  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;

  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;

  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;

  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;

  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}

exports.compareByOriginalPositions = compareByOriginalPositions;
/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */

function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;

  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;

  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);

  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;

  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;

  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}

exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

function strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
    return 0;
  }

  if (aStr1 === null) {
    return 1; // aStr2 !== null
  }

  if (aStr2 === null) {
    return -1; // aStr1 !== null
  }

  if (aStr1 > aStr2) {
    return 1;
  }

  return -1;
}
/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */


function compareByGeneratedPositionsInflated(mappingA, mappingB) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;

  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;

  if (cmp !== 0) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);

  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;

  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;

  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}

exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
/**
 * Strip any JSON XSSI avoidance prefix from the string (as documented
 * in the source maps specification), and then parse the string as
 * JSON.
 */

function parseSourceMapInput(str) {
  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
}

exports.parseSourceMapInput = parseSourceMapInput;
/**
 * Compute the URL of a source given the the source root, the source's
 * URL, and the source map's URL.
 */

function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
  sourceURL = sourceURL || '';

  if (sourceRoot) {
    // This follows what Chrome does.
    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
      sourceRoot += '/';
    } // The spec says:
    //   Line 4: An optional source root, useful for relocating source
    //   files on a server or removing repeated values in the
    //   sources entry.  This value is prepended to the individual
    //   entries in the source field.


    sourceURL = sourceRoot + sourceURL;
  } // Historically, SourceMapConsumer did not take the sourceMapURL as
  // a parameter.  This mode is still somewhat supported, which is why
  // this code block is conditional.  However, it's preferable to pass
  // the source map URL to SourceMapConsumer, so that this function
  // can implement the source URL resolution algorithm as outlined in
  // the spec.  This block is basically the equivalent of:
  //    new URL(sourceURL, sourceMapURL).toString()
  // ... except it avoids using URL, which wasn't available in the
  // older releases of node still supported by this library.
  //
  // The spec says:
  //   If the sources are not absolute URLs after prepending of the
  //   sourceRoot, the sources are resolved relative to the
  //   SourceMap (like resolving script src in a html document).


  if (sourceMapURL) {
    var parsed = urlParse(sourceMapURL);

    if (!parsed) {
      throw new Error("sourceMapURL could not be parsed");
    }

    if (parsed.path) {
      // Strip the last path component, but keep the "/".
      var index = parsed.path.lastIndexOf('/');

      if (index >= 0) {
        parsed.path = parsed.path.substring(0, index + 1);
      }
    }

    sourceURL = join(urlGenerate(parsed), sourceURL);
  }

  return normalize(sourceURL);
}

exports.computeSourceURL = computeSourceURL;
},{}],"node_modules/get-source/node_modules/source-map/lib/array-set.js":[function(require,module,exports) {
/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
var util = require('./util');

var has = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";
/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */

function ArraySet() {
  this._array = [];
  this._set = hasNativeMap ? new Map() : Object.create(null);
}
/**
 * Static method for creating ArraySet instances from an existing array.
 */


ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet();

  for (var i = 0, len = aArray.length; i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }

  return set;
};
/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */


ArraySet.prototype.size = function ArraySet_size() {
  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};
/**
 * Add the given string to this set.
 *
 * @param String aStr
 */


ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
  var idx = this._array.length;

  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }

  if (!isDuplicate) {
    if (hasNativeMap) {
      this._set.set(aStr, idx);
    } else {
      this._set[sStr] = idx;
    }
  }
};
/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */


ArraySet.prototype.has = function ArraySet_has(aStr) {
  if (hasNativeMap) {
    return this._set.has(aStr);
  } else {
    var sStr = util.toSetString(aStr);
    return has.call(this._set, sStr);
  }
};
/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */


ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
  if (hasNativeMap) {
    var idx = this._set.get(aStr);

    if (idx >= 0) {
      return idx;
    }
  } else {
    var sStr = util.toSetString(aStr);

    if (has.call(this._set, sStr)) {
      return this._set[sStr];
    }
  }

  throw new Error('"' + aStr + '" is not in the set.');
};
/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */


ArraySet.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }

  throw new Error('No element indexed by ' + aIdx);
};
/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */


ArraySet.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

exports.ArraySet = ArraySet;
},{"./util":"node_modules/get-source/node_modules/source-map/lib/util.js"}],"node_modules/get-source/node_modules/source-map/lib/mapping-list.js":[function(require,module,exports) {
/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
var util = require('./util');
/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */


function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}
/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */


function MappingList() {
  this._array = [];
  this._sorted = true; // Serves as infimum

  this._last = {
    generatedLine: -1,
    generatedColumn: 0
  };
}
/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */


MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
  this._array.forEach(aCallback, aThisArg);
};
/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */


MappingList.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;

    this._array.push(aMapping);
  } else {
    this._sorted = false;

    this._array.push(aMapping);
  }
};
/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */


MappingList.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util.compareByGeneratedPositionsInflated);

    this._sorted = true;
  }

  return this._array;
};

exports.MappingList = MappingList;
},{"./util":"node_modules/get-source/node_modules/source-map/lib/util.js"}],"node_modules/get-source/node_modules/source-map/lib/source-map-generator.js":[function(require,module,exports) {
/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
var base64VLQ = require('./base64-vlq');

var util = require('./util');

var ArraySet = require('./array-set').ArraySet;

var MappingList = require('./mapping-list').MappingList;
/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */


function SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }

  this._file = util.getArg(aArgs, 'file', null);
  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}

SourceMapGenerator.prototype._version = 3;
/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */

SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
  var sourceRoot = aSourceMapConsumer.sourceRoot;
  var generator = new SourceMapGenerator({
    file: aSourceMapConsumer.file,
    sourceRoot: sourceRoot
  });
  aSourceMapConsumer.eachMapping(function (mapping) {
    var newMapping = {
      generated: {
        line: mapping.generatedLine,
        column: mapping.generatedColumn
      }
    };

    if (mapping.source != null) {
      newMapping.source = mapping.source;

      if (sourceRoot != null) {
        newMapping.source = util.relative(sourceRoot, newMapping.source);
      }

      newMapping.original = {
        line: mapping.originalLine,
        column: mapping.originalColumn
      };

      if (mapping.name != null) {
        newMapping.name = mapping.name;
      }
    }

    generator.addMapping(newMapping);
  });
  aSourceMapConsumer.sources.forEach(function (sourceFile) {
    var sourceRelative = sourceFile;

    if (sourceRoot !== null) {
      sourceRelative = util.relative(sourceRoot, sourceFile);
    }

    if (!generator._sources.has(sourceRelative)) {
      generator._sources.add(sourceRelative);
    }

    var content = aSourceMapConsumer.sourceContentFor(sourceFile);

    if (content != null) {
      generator.setSourceContent(sourceFile, content);
    }
  });
  return generator;
};
/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */


SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
  var generated = util.getArg(aArgs, 'generated');
  var original = util.getArg(aArgs, 'original', null);
  var source = util.getArg(aArgs, 'source', null);
  var name = util.getArg(aArgs, 'name', null);

  if (!this._skipValidation) {
    this._validateMapping(generated, original, source, name);
  }

  if (source != null) {
    source = String(source);

    if (!this._sources.has(source)) {
      this._sources.add(source);
    }
  }

  if (name != null) {
    name = String(name);

    if (!this._names.has(name)) {
      this._names.add(name);
    }
  }

  this._mappings.add({
    generatedLine: generated.line,
    generatedColumn: generated.column,
    originalLine: original != null && original.line,
    originalColumn: original != null && original.column,
    source: source,
    name: name
  });
};
/**
 * Set the source content for a source file.
 */


SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
  var source = aSourceFile;

  if (this._sourceRoot != null) {
    source = util.relative(this._sourceRoot, source);
  }

  if (aSourceContent != null) {
    // Add the source content to the _sourcesContents map.
    // Create a new _sourcesContents map if the property is null.
    if (!this._sourcesContents) {
      this._sourcesContents = Object.create(null);
    }

    this._sourcesContents[util.toSetString(source)] = aSourceContent;
  } else if (this._sourcesContents) {
    // Remove the source file from the _sourcesContents map.
    // If the _sourcesContents map is empty, set the property to null.
    delete this._sourcesContents[util.toSetString(source)];

    if (Object.keys(this._sourcesContents).length === 0) {
      this._sourcesContents = null;
    }
  }
};
/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */


SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
  var sourceFile = aSourceFile; // If aSourceFile is omitted, we will use the file property of the SourceMap

  if (aSourceFile == null) {
    if (aSourceMapConsumer.file == null) {
      throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' + 'or the source map\'s "file" property. Both were omitted.');
    }

    sourceFile = aSourceMapConsumer.file;
  }

  var sourceRoot = this._sourceRoot; // Make "sourceFile" relative if an absolute Url is passed.

  if (sourceRoot != null) {
    sourceFile = util.relative(sourceRoot, sourceFile);
  } // Applying the SourceMap can add and remove items from the sources and
  // the names array.


  var newSources = new ArraySet();
  var newNames = new ArraySet(); // Find mappings for the "sourceFile"

  this._mappings.unsortedForEach(function (mapping) {
    if (mapping.source === sourceFile && mapping.originalLine != null) {
      // Check if it can be mapped by the source map, then update the mapping.
      var original = aSourceMapConsumer.originalPositionFor({
        line: mapping.originalLine,
        column: mapping.originalColumn
      });

      if (original.source != null) {
        // Copy mapping
        mapping.source = original.source;

        if (aSourceMapPath != null) {
          mapping.source = util.join(aSourceMapPath, mapping.source);
        }

        if (sourceRoot != null) {
          mapping.source = util.relative(sourceRoot, mapping.source);
        }

        mapping.originalLine = original.line;
        mapping.originalColumn = original.column;

        if (original.name != null) {
          mapping.name = original.name;
        }
      }
    }

    var source = mapping.source;

    if (source != null && !newSources.has(source)) {
      newSources.add(source);
    }

    var name = mapping.name;

    if (name != null && !newNames.has(name)) {
      newNames.add(name);
    }
  }, this);

  this._sources = newSources;
  this._names = newNames; // Copy sourcesContents of applied map.

  aSourceMapConsumer.sources.forEach(function (sourceFile) {
    var content = aSourceMapConsumer.sourceContentFor(sourceFile);

    if (content != null) {
      if (aSourceMapPath != null) {
        sourceFile = util.join(aSourceMapPath, sourceFile);
      }

      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }

      this.setSourceContent(sourceFile, content);
    }
  }, this);
};
/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */


SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
  // When aOriginal is truthy but has empty values for .line and .column,
  // it is most likely a programmer error. In this case we throw a very
  // specific error message to try to guide them the right way.
  // For example: https://github.com/Polymer/polymer-bundler/pull/519
  if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
    throw new Error('original.line and original.column are not numbers -- you probably meant to omit ' + 'the original mapping entirely and only map the generated position. If so, pass ' + 'null for the original mapping instead of an object with empty or null values.');
  }

  if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
    // Case 1.
    return;
  } else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aOriginal && 'line' in aOriginal && 'column' in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
    // Cases 2 and 3.
    return;
  } else {
    throw new Error('Invalid mapping: ' + JSON.stringify({
      generated: aGenerated,
      source: aSource,
      original: aOriginal,
      name: aName
    }));
  }
};
/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */


SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
  var previousGeneratedColumn = 0;
  var previousGeneratedLine = 1;
  var previousOriginalColumn = 0;
  var previousOriginalLine = 0;
  var previousName = 0;
  var previousSource = 0;
  var result = '';
  var next;
  var mapping;
  var nameIdx;
  var sourceIdx;

  var mappings = this._mappings.toArray();

  for (var i = 0, len = mappings.length; i < len; i++) {
    mapping = mappings[i];
    next = '';

    if (mapping.generatedLine !== previousGeneratedLine) {
      previousGeneratedColumn = 0;

      while (mapping.generatedLine !== previousGeneratedLine) {
        next += ';';
        previousGeneratedLine++;
      }
    } else {
      if (i > 0) {
        if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
          continue;
        }

        next += ',';
      }
    }

    next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
    previousGeneratedColumn = mapping.generatedColumn;

    if (mapping.source != null) {
      sourceIdx = this._sources.indexOf(mapping.source);
      next += base64VLQ.encode(sourceIdx - previousSource);
      previousSource = sourceIdx; // lines are stored 0-based in SourceMap spec version 3

      next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
      previousOriginalLine = mapping.originalLine - 1;
      next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
      previousOriginalColumn = mapping.originalColumn;

      if (mapping.name != null) {
        nameIdx = this._names.indexOf(mapping.name);
        next += base64VLQ.encode(nameIdx - previousName);
        previousName = nameIdx;
      }
    }

    result += next;
  }

  return result;
};

SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
  return aSources.map(function (source) {
    if (!this._sourcesContents) {
      return null;
    }

    if (aSourceRoot != null) {
      source = util.relative(aSourceRoot, source);
    }

    var key = util.toSetString(source);
    return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
  }, this);
};
/**
 * Externalize the source map.
 */


SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
  var map = {
    version: this._version,
    sources: this._sources.toArray(),
    names: this._names.toArray(),
    mappings: this._serializeMappings()
  };

  if (this._file != null) {
    map.file = this._file;
  }

  if (this._sourceRoot != null) {
    map.sourceRoot = this._sourceRoot;
  }

  if (this._sourcesContents) {
    map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
  }

  return map;
};
/**
 * Render the source map being generated to a string.
 */


SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
  return JSON.stringify(this.toJSON());
};

exports.SourceMapGenerator = SourceMapGenerator;
},{"./base64-vlq":"node_modules/get-source/node_modules/source-map/lib/base64-vlq.js","./util":"node_modules/get-source/node_modules/source-map/lib/util.js","./array-set":"node_modules/get-source/node_modules/source-map/lib/array-set.js","./mapping-list":"node_modules/get-source/node_modules/source-map/lib/mapping-list.js"}],"node_modules/get-source/node_modules/source-map/lib/binary-search.js":[function(require,module,exports) {
/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.GREATEST_LOWER_BOUND = 1;
exports.LEAST_UPPER_BOUND = 2;
/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */

function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
  // This function terminates when one of the following is true:
  //
  //   1. We find the exact element we are looking for.
  //
  //   2. We did not find the exact element, but we can return the index of
  //      the next-closest element.
  //
  //   3. We did not find the exact element, and there is no next-closest
  //      element than the one we are searching for, so we return -1.
  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
  var cmp = aCompare(aNeedle, aHaystack[mid], true);

  if (cmp === 0) {
    // Found the element we are looking for.
    return mid;
  } else if (cmp > 0) {
    // Our needle is greater than aHaystack[mid].
    if (aHigh - mid > 1) {
      // The element is in the upper half.
      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
    } // The exact needle element was not found in this haystack. Determine if
    // we are in termination case (3) or (2) and return the appropriate thing.


    if (aBias == exports.LEAST_UPPER_BOUND) {
      return aHigh < aHaystack.length ? aHigh : -1;
    } else {
      return mid;
    }
  } else {
    // Our needle is less than aHaystack[mid].
    if (mid - aLow > 1) {
      // The element is in the lower half.
      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
    } // we are in termination case (3) or (2) and return the appropriate thing.


    if (aBias == exports.LEAST_UPPER_BOUND) {
      return mid;
    } else {
      return aLow < 0 ? -1 : aLow;
    }
  }
}
/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */


exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
  if (aHaystack.length === 0) {
    return -1;
  }

  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);

  if (index < 0) {
    return -1;
  } // We have found either the exact element, or the next-closest element than
  // the one we are searching for. However, there may be more than one such
  // element. Make sure we always return the smallest of these.


  while (index - 1 >= 0) {
    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
      break;
    }

    --index;
  }

  return index;
};
},{}],"node_modules/get-source/node_modules/source-map/lib/quick-sort.js":[function(require,module,exports) {
/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
// It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.

/**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */
function swap(ary, x, y) {
  var temp = ary[x];
  ary[x] = ary[y];
  ary[y] = temp;
}
/**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */


function randomIntInRange(low, high) {
  return Math.round(low + Math.random() * (high - low));
}
/**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */


function doQuickSort(ary, comparator, p, r) {
  // If our lower bound is less than our upper bound, we (1) partition the
  // array into two pieces and (2) recurse on each half. If it is not, this is
  // the empty array and our base case.
  if (p < r) {
    // (1) Partitioning.
    //
    // The partitioning chooses a pivot between `p` and `r` and moves all
    // elements that are less than or equal to the pivot to the before it, and
    // all the elements that are greater than it after it. The effect is that
    // once partition is done, the pivot is in the exact place it will be when
    // the array is put in sorted order, and it will not need to be moved
    // again. This runs in O(n) time.
    // Always choose a random pivot so that an input array which is reverse
    // sorted does not cause O(n^2) running time.
    var pivotIndex = randomIntInRange(p, r);
    var i = p - 1;
    swap(ary, pivotIndex, r);
    var pivot = ary[r]; // Immediately after `j` is incremented in this loop, the following hold
    // true:
    //
    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
    //
    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.

    for (var j = p; j < r; j++) {
      if (comparator(ary[j], pivot) <= 0) {
        i += 1;
        swap(ary, i, j);
      }
    }

    swap(ary, i + 1, j);
    var q = i + 1; // (2) Recurse on each half.

    doQuickSort(ary, comparator, p, q - 1);
    doQuickSort(ary, comparator, q + 1, r);
  }
}
/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */


exports.quickSort = function (ary, comparator) {
  doQuickSort(ary, comparator, 0, ary.length - 1);
};
},{}],"node_modules/get-source/node_modules/source-map/lib/source-map-consumer.js":[function(require,module,exports) {
/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
var util = require('./util');

var binarySearch = require('./binary-search');

var ArraySet = require('./array-set').ArraySet;

var base64VLQ = require('./base64-vlq');

var quickSort = require('./quick-sort').quickSort;

function SourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;

  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
}

SourceMapConsumer.fromSourceMap = function (aSourceMap, aSourceMapURL) {
  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
};
/**
 * The version of the source mapping spec that we are consuming.
 */


SourceMapConsumer.prototype._version = 3; // `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__generatedMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__generatedMappings;
  }
});
SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__originalMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__originalMappings;
  }
});

SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
  var c = aStr.charAt(index);
  return c === ";" || c === ",";
};
/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */


SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
  throw new Error("Subclasses must implement _parseMappings");
};

SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;
SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;
/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */

SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
  var context = aContext || null;
  var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
  var mappings;

  switch (order) {
    case SourceMapConsumer.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;

    case SourceMapConsumer.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;

    default:
      throw new Error("Unknown order of iteration.");
  }

  var sourceRoot = this.sourceRoot;
  mappings.map(function (mapping) {
    var source = mapping.source === null ? null : this._sources.at(mapping.source);
    source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
    return {
      source: source,
      generatedLine: mapping.generatedLine,
      generatedColumn: mapping.generatedColumn,
      originalLine: mapping.originalLine,
      originalColumn: mapping.originalColumn,
      name: mapping.name === null ? null : this._names.at(mapping.name)
    };
  }, this).forEach(aCallback, context);
};
/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number is 1-based.
 *   - column: Optional. the column number in the original source.
 *    The column number is 0-based.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *    line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *    The column number is 0-based.
 */


SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
  var line = util.getArg(aArgs, 'line'); // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
  // returns the index of the closest mapping less than the needle. By
  // setting needle.originalColumn to 0, we thus find the last mapping for
  // the given line, provided such a mapping exists.

  var needle = {
    source: util.getArg(aArgs, 'source'),
    originalLine: line,
    originalColumn: util.getArg(aArgs, 'column', 0)
  };
  needle.source = this._findSourceIndex(needle.source);

  if (needle.source < 0) {
    return [];
  }

  var mappings = [];

  var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);

  if (index >= 0) {
    var mapping = this._originalMappings[index];

    if (aArgs.column === undefined) {
      var originalLine = mapping.originalLine; // Iterate until either we run out of mappings, or we run into
      // a mapping for a different line than the one we found. Since
      // mappings are sorted, this is guaranteed to find all mappings for
      // the line we found.

      while (mapping && mapping.originalLine === originalLine) {
        mappings.push({
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        });
        mapping = this._originalMappings[++index];
      }
    } else {
      var originalColumn = mapping.originalColumn; // Iterate until either we run out of mappings, or we run into
      // a mapping for a different line than the one we were searching for.
      // Since mappings are sorted, this is guaranteed to find all mappings for
      // the line we are searching for.

      while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
        mappings.push({
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        });
        mapping = this._originalMappings[++index];
      }
    }
  }

  return mappings;
};

exports.SourceMapConsumer = SourceMapConsumer;
/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The first parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */

function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;

  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  var version = util.getArg(sourceMap, 'version');
  var sources = util.getArg(sourceMap, 'sources'); // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
  // requires the array) to play nice here.

  var names = util.getArg(sourceMap, 'names', []);
  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
  var mappings = util.getArg(sourceMap, 'mappings');
  var file = util.getArg(sourceMap, 'file', null); // Once again, Sass deviates from the spec and supplies the version as a
  // string rather than a number, so we use loose equality checking here.

  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  if (sourceRoot) {
    sourceRoot = util.normalize(sourceRoot);
  }

  sources = sources.map(String) // Some source maps produce relative source paths like "./foo.js" instead of
  // "foo.js".  Normalize these first so that future comparisons will succeed.
  // See bugzil.la/1090768.
  .map(util.normalize) // Always ensure that absolute sources are internally stored relative to
  // the source root, if the source root is absolute. Not doing this would
  // be particularly problematic when the source root is a prefix of the
  // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
  .map(function (source) {
    return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
  }); // Pass `true` below to allow duplicate names and sources. While source maps
  // are intended to be compressed and deduplicated, the TypeScript compiler
  // sometimes generates source maps with duplicates in them. See Github issue
  // #72 and bugzil.la/889492.

  this._names = ArraySet.fromArray(names.map(String), true);
  this._sources = ArraySet.fromArray(sources, true);
  this._absoluteSources = this._sources.toArray().map(function (s) {
    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
  });
  this.sourceRoot = sourceRoot;
  this.sourcesContent = sourcesContent;
  this._mappings = mappings;
  this._sourceMapURL = aSourceMapURL;
  this.file = file;
}

BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
/**
 * Utility function to find the index of a source.  Returns -1 if not
 * found.
 */

BasicSourceMapConsumer.prototype._findSourceIndex = function (aSource) {
  var relativeSource = aSource;

  if (this.sourceRoot != null) {
    relativeSource = util.relative(this.sourceRoot, relativeSource);
  }

  if (this._sources.has(relativeSource)) {
    return this._sources.indexOf(relativeSource);
  } // Maybe aSource is an absolute URL as returned by |sources|.  In
  // this case we can't simply undo the transform.


  var i;

  for (i = 0; i < this._absoluteSources.length; ++i) {
    if (this._absoluteSources[i] == aSource) {
      return i;
    }
  }

  return -1;
};
/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @param String aSourceMapURL
 *        The URL at which the source map can be found (optional)
 * @returns BasicSourceMapConsumer
 */


BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
  var smc = Object.create(BasicSourceMapConsumer.prototype);
  var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
  var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
  smc.sourceRoot = aSourceMap._sourceRoot;
  smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
  smc.file = aSourceMap._file;
  smc._sourceMapURL = aSourceMapURL;
  smc._absoluteSources = smc._sources.toArray().map(function (s) {
    return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
  }); // Because we are modifying the entries (by converting string sources and
  // names to indices into the sources and names ArraySets), we have to make
  // a copy of the entry or else bad things happen. Shared mutable state
  // strikes again! See github issue #191.

  var generatedMappings = aSourceMap._mappings.toArray().slice();

  var destGeneratedMappings = smc.__generatedMappings = [];
  var destOriginalMappings = smc.__originalMappings = [];

  for (var i = 0, length = generatedMappings.length; i < length; i++) {
    var srcMapping = generatedMappings[i];
    var destMapping = new Mapping();
    destMapping.generatedLine = srcMapping.generatedLine;
    destMapping.generatedColumn = srcMapping.generatedColumn;

    if (srcMapping.source) {
      destMapping.source = sources.indexOf(srcMapping.source);
      destMapping.originalLine = srcMapping.originalLine;
      destMapping.originalColumn = srcMapping.originalColumn;

      if (srcMapping.name) {
        destMapping.name = names.indexOf(srcMapping.name);
      }

      destOriginalMappings.push(destMapping);
    }

    destGeneratedMappings.push(destMapping);
  }

  quickSort(smc.__originalMappings, util.compareByOriginalPositions);
  return smc;
};
/**
 * The version of the source mapping spec that we are consuming.
 */


BasicSourceMapConsumer.prototype._version = 3;
/**
 * The list of original sources.
 */

Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
  get: function () {
    return this._absoluteSources.slice();
  }
});
/**
 * Provide the JIT with a nice shape / hidden class.
 */

function Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}
/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */


BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
  var generatedLine = 1;
  var previousGeneratedColumn = 0;
  var previousOriginalLine = 0;
  var previousOriginalColumn = 0;
  var previousSource = 0;
  var previousName = 0;
  var length = aStr.length;
  var index = 0;
  var cachedSegments = {};
  var temp = {};
  var originalMappings = [];
  var generatedMappings = [];
  var mapping, str, segment, end, value;

  while (index < length) {
    if (aStr.charAt(index) === ';') {
      generatedLine++;
      index++;
      previousGeneratedColumn = 0;
    } else if (aStr.charAt(index) === ',') {
      index++;
    } else {
      mapping = new Mapping();
      mapping.generatedLine = generatedLine; // Because each offset is encoded relative to the previous one,
      // many segments often have the same encoding. We can exploit this
      // fact by caching the parsed variable length fields of each segment,
      // allowing us to avoid a second parse if we encounter the same
      // segment again.

      for (end = index; end < length; end++) {
        if (this._charIsMappingSeparator(aStr, end)) {
          break;
        }
      }

      str = aStr.slice(index, end);
      segment = cachedSegments[str];

      if (segment) {
        index += str.length;
      } else {
        segment = [];

        while (index < end) {
          base64VLQ.decode(aStr, index, temp);
          value = temp.value;
          index = temp.rest;
          segment.push(value);
        }

        if (segment.length === 2) {
          throw new Error('Found a source, but no line and column');
        }

        if (segment.length === 3) {
          throw new Error('Found a source and line, but no column');
        }

        cachedSegments[str] = segment;
      } // Generated column.


      mapping.generatedColumn = previousGeneratedColumn + segment[0];
      previousGeneratedColumn = mapping.generatedColumn;

      if (segment.length > 1) {
        // Original source.
        mapping.source = previousSource + segment[1];
        previousSource += segment[1]; // Original line.

        mapping.originalLine = previousOriginalLine + segment[2];
        previousOriginalLine = mapping.originalLine; // Lines are stored 0-based

        mapping.originalLine += 1; // Original column.

        mapping.originalColumn = previousOriginalColumn + segment[3];
        previousOriginalColumn = mapping.originalColumn;

        if (segment.length > 4) {
          // Original name.
          mapping.name = previousName + segment[4];
          previousName += segment[4];
        }
      }

      generatedMappings.push(mapping);

      if (typeof mapping.originalLine === 'number') {
        originalMappings.push(mapping);
      }
    }
  }

  quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
  this.__generatedMappings = generatedMappings;
  quickSort(originalMappings, util.compareByOriginalPositions);
  this.__originalMappings = originalMappings;
};
/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */


BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
  // To return the position we are searching for, we must first find the
  // mapping for the given position and then return the opposite position it
  // points to. Because the mappings are sorted, we can use binary search to
  // find the best mapping.
  if (aNeedle[aLineName] <= 0) {
    throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);
  }

  if (aNeedle[aColumnName] < 0) {
    throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);
  }

  return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
};
/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */


BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
  for (var index = 0; index < this._generatedMappings.length; ++index) {
    var mapping = this._generatedMappings[index]; // Mappings do not contain a field for the last generated columnt. We
    // can come up with an optimistic estimate, however, by assuming that
    // mappings are contiguous (i.e. given two consecutive mappings, the
    // first mapping ends where the second one starts).

    if (index + 1 < this._generatedMappings.length) {
      var nextMapping = this._generatedMappings[index + 1];

      if (mapping.generatedLine === nextMapping.generatedLine) {
        mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
        continue;
      }
    } // The last mapping for each line spans the entire line.


    mapping.lastGeneratedColumn = Infinity;
  }
};
/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */


BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
  var needle = {
    generatedLine: util.getArg(aArgs, 'line'),
    generatedColumn: util.getArg(aArgs, 'column')
  };

  var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));

  if (index >= 0) {
    var mapping = this._generatedMappings[index];

    if (mapping.generatedLine === needle.generatedLine) {
      var source = util.getArg(mapping, 'source', null);

      if (source !== null) {
        source = this._sources.at(source);
        source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
      }

      var name = util.getArg(mapping, 'name', null);

      if (name !== null) {
        name = this._names.at(name);
      }

      return {
        source: source,
        line: util.getArg(mapping, 'originalLine', null),
        column: util.getArg(mapping, 'originalColumn', null),
        name: name
      };
    }
  }

  return {
    source: null,
    line: null,
    column: null,
    name: null
  };
};
/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */


BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
  if (!this.sourcesContent) {
    return false;
  }

  return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function (sc) {
    return sc == null;
  });
};
/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */


BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
  if (!this.sourcesContent) {
    return null;
  }

  var index = this._findSourceIndex(aSource);

  if (index >= 0) {
    return this.sourcesContent[index];
  }

  var relativeSource = aSource;

  if (this.sourceRoot != null) {
    relativeSource = util.relative(this.sourceRoot, relativeSource);
  }

  var url;

  if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
    // XXX: file:// URIs and absolute paths lead to unexpected behavior for
    // many users. We can help them out when they expect file:// URIs to
    // behave like it would if they were running a local HTTP server. See
    // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
    var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");

    if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
      return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
    }

    if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
      return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
    }
  } // This function is used recursively from
  // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
  // don't want to throw if we can't find the source - we just want to
  // return null, so we provide a flag to exit gracefully.


  if (nullOnMissing) {
    return null;
  } else {
    throw new Error('"' + relativeSource + '" is not in the SourceMap.');
  }
};
/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */


BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
  var source = util.getArg(aArgs, 'source');
  source = this._findSourceIndex(source);

  if (source < 0) {
    return {
      line: null,
      column: null,
      lastColumn: null
    };
  }

  var needle = {
    source: source,
    originalLine: util.getArg(aArgs, 'line'),
    originalColumn: util.getArg(aArgs, 'column')
  };

  var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));

  if (index >= 0) {
    var mapping = this._originalMappings[index];

    if (mapping.source === needle.source) {
      return {
        line: util.getArg(mapping, 'generatedLine', null),
        column: util.getArg(mapping, 'generatedColumn', null),
        lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
      };
    }
  }

  return {
    line: null,
    column: null,
    lastColumn: null
  };
};

exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The first parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */

function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;

  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  var version = util.getArg(sourceMap, 'version');
  var sections = util.getArg(sourceMap, 'sections');

  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  this._sources = new ArraySet();
  this._names = new ArraySet();
  var lastOffset = {
    line: -1,
    column: 0
  };
  this._sections = sections.map(function (s) {
    if (s.url) {
      // The url field will require support for asynchronicity.
      // See https://github.com/mozilla/source-map/issues/16
      throw new Error('Support for url field in sections not implemented.');
    }

    var offset = util.getArg(s, 'offset');
    var offsetLine = util.getArg(offset, 'line');
    var offsetColumn = util.getArg(offset, 'column');

    if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
      throw new Error('Section offsets must be ordered and non-overlapping.');
    }

    lastOffset = offset;
    return {
      generatedOffset: {
        // The offset fields are 0-based, but we use 1-based indices when
        // encoding/decoding from VLQ.
        generatedLine: offsetLine + 1,
        generatedColumn: offsetColumn + 1
      },
      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
    };
  });
}

IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
/**
 * The version of the source mapping spec that we are consuming.
 */

IndexedSourceMapConsumer.prototype._version = 3;
/**
 * The list of original sources.
 */

Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
  get: function () {
    var sources = [];

    for (var i = 0; i < this._sections.length; i++) {
      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }

    return sources;
  }
});
/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */

IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
  var needle = {
    generatedLine: util.getArg(aArgs, 'line'),
    generatedColumn: util.getArg(aArgs, 'column')
  }; // Find the section containing the generated position we're trying to map
  // to an original position.

  var sectionIndex = binarySearch.search(needle, this._sections, function (needle, section) {
    var cmp = needle.generatedLine - section.generatedOffset.generatedLine;

    if (cmp) {
      return cmp;
    }

    return needle.generatedColumn - section.generatedOffset.generatedColumn;
  });
  var section = this._sections[sectionIndex];

  if (!section) {
    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  }

  return section.consumer.originalPositionFor({
    line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
    column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
    bias: aArgs.bias
  });
};
/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */


IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
  return this._sections.every(function (s) {
    return s.consumer.hasContentsOfAllSources();
  });
};
/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */


IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
  for (var i = 0; i < this._sections.length; i++) {
    var section = this._sections[i];
    var content = section.consumer.sourceContentFor(aSource, true);

    if (content) {
      return content;
    }
  }

  if (nullOnMissing) {
    return null;
  } else {
    throw new Error('"' + aSource + '" is not in the SourceMap.');
  }
};
/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based. 
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */


IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
  for (var i = 0; i < this._sections.length; i++) {
    var section = this._sections[i]; // Only consider this section if the requested source is in the list of
    // sources of the consumer.

    if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
      continue;
    }

    var generatedPosition = section.consumer.generatedPositionFor(aArgs);

    if (generatedPosition) {
      var ret = {
        line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
        column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
      };
      return ret;
    }
  }

  return {
    line: null,
    column: null
  };
};
/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */


IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
  this.__generatedMappings = [];
  this.__originalMappings = [];

  for (var i = 0; i < this._sections.length; i++) {
    var section = this._sections[i];
    var sectionMappings = section.consumer._generatedMappings;

    for (var j = 0; j < sectionMappings.length; j++) {
      var mapping = sectionMappings[j];

      var source = section.consumer._sources.at(mapping.source);

      source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);

      this._sources.add(source);

      source = this._sources.indexOf(source);
      var name = null;

      if (mapping.name) {
        name = section.consumer._names.at(mapping.name);

        this._names.add(name);

        name = this._names.indexOf(name);
      } // The mappings coming from the consumer for the section have
      // generated positions relative to the start of the section, so we
      // need to offset them to be relative to the start of the concatenated
      // generated file.


      var adjustedMapping = {
        source: source,
        generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
        generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: name
      };

      this.__generatedMappings.push(adjustedMapping);

      if (typeof adjustedMapping.originalLine === 'number') {
        this.__originalMappings.push(adjustedMapping);
      }
    }
  }

  quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
  quickSort(this.__originalMappings, util.compareByOriginalPositions);
};

exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
},{"./util":"node_modules/get-source/node_modules/source-map/lib/util.js","./binary-search":"node_modules/get-source/node_modules/source-map/lib/binary-search.js","./array-set":"node_modules/get-source/node_modules/source-map/lib/array-set.js","./base64-vlq":"node_modules/get-source/node_modules/source-map/lib/base64-vlq.js","./quick-sort":"node_modules/get-source/node_modules/source-map/lib/quick-sort.js"}],"node_modules/get-source/node_modules/source-map/lib/source-node.js":[function(require,module,exports) {
/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;

var util = require('./util'); // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).


var REGEX_NEWLINE = /(\r?\n)/; // Newline character code for charCodeAt() comparisons

var NEWLINE_CODE = 10; // Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!

var isSourceNode = "$$$isSourceNode$$$";
/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */

function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
  this.children = [];
  this.sourceContents = {};
  this.line = aLine == null ? null : aLine;
  this.column = aColumn == null ? null : aColumn;
  this.source = aSource == null ? null : aSource;
  this.name = aName == null ? null : aName;
  this[isSourceNode] = true;
  if (aChunks != null) this.add(aChunks);
}
/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */


SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
  // The SourceNode we want to fill with the generated code
  // and the SourceMap
  var node = new SourceNode(); // All even indices of this array are one line of the generated code,
  // while all odd indices are the newlines between two adjacent lines
  // (since `REGEX_NEWLINE` captures its match).
  // Processed fragments are accessed by calling `shiftNextLine`.

  var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
  var remainingLinesIndex = 0;

  var shiftNextLine = function () {
    var lineContents = getNextLine(); // The last line of a file might not have a newline.

    var newLine = getNextLine() || "";
    return lineContents + newLine;

    function getNextLine() {
      return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;
    }
  }; // We need to remember the position of "remainingLines"


  var lastGeneratedLine = 1,
      lastGeneratedColumn = 0; // The generate SourceNodes we need a code range.
  // To extract it current and last mapping is used.
  // Here we store the last mapping.

  var lastMapping = null;
  aSourceMapConsumer.eachMapping(function (mapping) {
    if (lastMapping !== null) {
      // We add the code from "lastMapping" to "mapping":
      // First check if there is a new line in between.
      if (lastGeneratedLine < mapping.generatedLine) {
        // Associate first line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
        lastGeneratedLine++;
        lastGeneratedColumn = 0; // The remaining code is added without mapping
      } else {
        // There is no new line in between.
        // Associate the code between "lastGeneratedColumn" and
        // "mapping.generatedColumn" with "lastMapping"
        var nextLine = remainingLines[remainingLinesIndex] || '';
        var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
        addMappingWithCode(lastMapping, code); // No more remaining code, continue

        lastMapping = mapping;
        return;
      }
    } // We add the generated code until the first mapping
    // to the SourceNode without any mapping.
    // Each line is added as separate string.


    while (lastGeneratedLine < mapping.generatedLine) {
      node.add(shiftNextLine());
      lastGeneratedLine++;
    }

    if (lastGeneratedColumn < mapping.generatedColumn) {
      var nextLine = remainingLines[remainingLinesIndex] || '';
      node.add(nextLine.substr(0, mapping.generatedColumn));
      remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
      lastGeneratedColumn = mapping.generatedColumn;
    }

    lastMapping = mapping;
  }, this); // We have processed all mappings.

  if (remainingLinesIndex < remainingLines.length) {
    if (lastMapping) {
      // Associate the remaining code in the current line with "lastMapping"
      addMappingWithCode(lastMapping, shiftNextLine());
    } // and add the remaining lines without any mapping


    node.add(remainingLines.splice(remainingLinesIndex).join(""));
  } // Copy sourcesContent into SourceNode


  aSourceMapConsumer.sources.forEach(function (sourceFile) {
    var content = aSourceMapConsumer.sourceContentFor(sourceFile);

    if (content != null) {
      if (aRelativePath != null) {
        sourceFile = util.join(aRelativePath, sourceFile);
      }

      node.setSourceContent(sourceFile, content);
    }
  });
  return node;

  function addMappingWithCode(mapping, code) {
    if (mapping === null || mapping.source === undefined) {
      node.add(code);
    } else {
      var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
      node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
    }
  }
};
/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */


SourceNode.prototype.add = function SourceNode_add(aChunk) {
  if (Array.isArray(aChunk)) {
    aChunk.forEach(function (chunk) {
      this.add(chunk);
    }, this);
  } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    if (aChunk) {
      this.children.push(aChunk);
    }
  } else {
    throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
  }

  return this;
};
/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */


SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
  if (Array.isArray(aChunk)) {
    for (var i = aChunk.length - 1; i >= 0; i--) {
      this.prepend(aChunk[i]);
    }
  } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    this.children.unshift(aChunk);
  } else {
    throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
  }

  return this;
};
/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */


SourceNode.prototype.walk = function SourceNode_walk(aFn) {
  var chunk;

  for (var i = 0, len = this.children.length; i < len; i++) {
    chunk = this.children[i];

    if (chunk[isSourceNode]) {
      chunk.walk(aFn);
    } else {
      if (chunk !== '') {
        aFn(chunk, {
          source: this.source,
          line: this.line,
          column: this.column,
          name: this.name
        });
      }
    }
  }
};
/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */


SourceNode.prototype.join = function SourceNode_join(aSep) {
  var newChildren;
  var i;
  var len = this.children.length;

  if (len > 0) {
    newChildren = [];

    for (i = 0; i < len - 1; i++) {
      newChildren.push(this.children[i]);
      newChildren.push(aSep);
    }

    newChildren.push(this.children[i]);
    this.children = newChildren;
  }

  return this;
};
/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */


SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
  var lastChild = this.children[this.children.length - 1];

  if (lastChild[isSourceNode]) {
    lastChild.replaceRight(aPattern, aReplacement);
  } else if (typeof lastChild === 'string') {
    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
  } else {
    this.children.push(''.replace(aPattern, aReplacement));
  }

  return this;
};
/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */


SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
  this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
};
/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */


SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
  for (var i = 0, len = this.children.length; i < len; i++) {
    if (this.children[i][isSourceNode]) {
      this.children[i].walkSourceContents(aFn);
    }
  }

  var sources = Object.keys(this.sourceContents);

  for (var i = 0, len = sources.length; i < len; i++) {
    aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
  }
};
/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */


SourceNode.prototype.toString = function SourceNode_toString() {
  var str = "";
  this.walk(function (chunk) {
    str += chunk;
  });
  return str;
};
/**
 * Returns the string representation of this source node along with a source
 * map.
 */


SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
  var generated = {
    code: "",
    line: 1,
    column: 0
  };
  var map = new SourceMapGenerator(aArgs);
  var sourceMappingActive = false;
  var lastOriginalSource = null;
  var lastOriginalLine = null;
  var lastOriginalColumn = null;
  var lastOriginalName = null;
  this.walk(function (chunk, original) {
    generated.code += chunk;

    if (original.source !== null && original.line !== null && original.column !== null) {
      if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
        map.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        });
      }

      lastOriginalSource = original.source;
      lastOriginalLine = original.line;
      lastOriginalColumn = original.column;
      lastOriginalName = original.name;
      sourceMappingActive = true;
    } else if (sourceMappingActive) {
      map.addMapping({
        generated: {
          line: generated.line,
          column: generated.column
        }
      });
      lastOriginalSource = null;
      sourceMappingActive = false;
    }

    for (var idx = 0, length = chunk.length; idx < length; idx++) {
      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
        generated.line++;
        generated.column = 0; // Mappings end at eol

        if (idx + 1 === length) {
          lastOriginalSource = null;
          sourceMappingActive = false;
        } else if (sourceMappingActive) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
      } else {
        generated.column++;
      }
    }
  });
  this.walkSourceContents(function (sourceFile, sourceContent) {
    map.setSourceContent(sourceFile, sourceContent);
  });
  return {
    code: generated.code,
    map: map
  };
};

exports.SourceNode = SourceNode;
},{"./source-map-generator":"node_modules/get-source/node_modules/source-map/lib/source-map-generator.js","./util":"node_modules/get-source/node_modules/source-map/lib/util.js"}],"node_modules/get-source/node_modules/source-map/source-map.js":[function(require,module,exports) {
/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = require('./lib/source-map-generator').SourceMapGenerator;
exports.SourceMapConsumer = require('./lib/source-map-consumer').SourceMapConsumer;
exports.SourceNode = require('./lib/source-node').SourceNode;
},{"./lib/source-map-generator":"node_modules/get-source/node_modules/source-map/lib/source-map-generator.js","./lib/source-map-consumer":"node_modules/get-source/node_modules/source-map/lib/source-map-consumer.js","./lib/source-node":"node_modules/get-source/node_modules/source-map/lib/source-node.js"}],"node_modules/get-source/impl/path.js":[function(require,module,exports) {
var process = require("process");
"use strict";

/*  ------------------------------------------------------------------------ */

const isBrowser = (typeof window !== 'undefined') && (window.window === window) && window.navigator
const cwd = isBrowser ? window.location.href : process.cwd ()

/*  ------------------------------------------------------------------------ */

const path = module.exports = {

    concat (a, b) {

                const a_endsWithSlash = (a[a.length - 1] === '/'),
                	  b_startsWithSlash = (b[0] === '/')

                return a + ((a_endsWithSlash || b_startsWithSlash) ? '' : '/') +
                           ((a_endsWithSlash && b_startsWithSlash) ? b.substring (1) : b) },

    resolve (x) {

    	if (path.isAbsolute (x)) {
    		return path.normalize (x) }

    	return path.normalize (path.concat (cwd, x))
    },

	normalize (x) {

		let output = [],
		    skip = 0

		x.split ('/').reverse ().filter (x => x !== '.').forEach (x => {

			     if (x === '..') { skip++ }
			else if (skip === 0) { output.push (x) }
			else                 { skip-- }
		})

		const result = output.reverse ().join ('/')

		return ((isBrowser && (result[0] === '/')) ? window.location.origin : '') + result
	},

	isData: x => x.indexOf ('data:') === 0,

	isAbsolute: x => (x[0] === '/') || /^[^\/]*:/.test (x),

	relativeToFile (a, b) {
		
	    return (path.isData (a) || path.isAbsolute (b)) ?
	    			path.normalize (b) :
	    			path.normalize (path.concat (a.split ('/').slice (0, -1).join ('/'), b))
	}
}

/*  ------------------------------------------------------------------------ */

},{"process":"../../../../.nvm/versions/node/v12.18.3/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"../../../../.nvm/versions/node/v12.18.3/lib/node_modules/parcel-bundler/node_modules/base64-js/index.js":[function(require,module,exports) {
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],"../../../../.nvm/versions/node/v12.18.3/lib/node_modules/parcel-bundler/node_modules/ieee754/index.js":[function(require,module,exports) {
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],"../../../../.nvm/versions/node/v12.18.3/lib/node_modules/parcel-bundler/node_modules/isarray/index.js":[function(require,module,exports) {
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],"../../../../.nvm/versions/node/v12.18.3/lib/node_modules/parcel-bundler/node_modules/buffer/index.js":[function(require,module,exports) {

var global = arguments[3];
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

},{"base64-js":"../../../../.nvm/versions/node/v12.18.3/lib/node_modules/parcel-bundler/node_modules/base64-js/index.js","ieee754":"../../../../.nvm/versions/node/v12.18.3/lib/node_modules/parcel-bundler/node_modules/ieee754/index.js","isarray":"../../../../.nvm/versions/node/v12.18.3/lib/node_modules/parcel-bundler/node_modules/isarray/index.js","buffer":"../../../../.nvm/versions/node/v12.18.3/lib/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"node_modules/data-uri-to-buffer/index.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
'use strict';

/**
 * Module exports.
 */

module.exports = dataUriToBuffer;

/**
 * Returns a `Buffer` instance from the given data URI `uri`.
 *
 * @param {String} uri Data URI to turn into a Buffer instance
 * @return {Buffer} Buffer instance from Data URI
 * @api public
 */

function dataUriToBuffer(uri) {
  if (!/^data\:/i.test(uri)) {
    throw new TypeError(
      '`uri` does not appear to be a Data URI (must begin with "data:")'
    );
  }

  // strip newlines
  uri = uri.replace(/\r?\n/g, '');

  // split the URI up into the "metadata" and the "data" portions
  var firstComma = uri.indexOf(',');
  if (-1 === firstComma || firstComma <= 4) {
    throw new TypeError('malformed data: URI');
  }

  // remove the "data:" scheme and parse the metadata
  var meta = uri.substring(5, firstComma).split(';');

  var type = meta[0] || 'text/plain';
  var typeFull = type;
  var base64 = false;
  var charset = '';
  for (var i = 1; i < meta.length; i++) {
    if ('base64' == meta[i]) {
      base64 = true;
    } else {
      typeFull += ';' + meta[i];
      if (0 == meta[i].indexOf('charset=')) {
        charset = meta[i].substring(8);
      }
    }
  }
  // defaults to US-ASCII only if type is not provided
  if (!meta[0] && !charset.length) {
    typeFull += ';charset=US-ASCII';
    charset = 'US-ASCII';
  }

  // get the encoded data portion and decode URI-encoded chars
  var data = unescape(uri.substring(firstComma + 1));

  var encoding = base64 ? 'base64' : 'ascii';
  var buffer = Buffer.from ? Buffer.from(data, encoding) : new Buffer(data, encoding);

  // set `.type` and `.typeFull` properties to MIME type
  buffer.type = type;
  buffer.typeFull = typeFull;

  // set the `.charset` property
  buffer.charset = charset;

  return buffer;
}

},{"buffer":"../../../../.nvm/versions/node/v12.18.3/lib/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"node_modules/get-source/get-source.js":[function(require,module,exports) {
"use strict";

/*  ------------------------------------------------------------------------ */

const O                 = Object,
      isBrowser         = (typeof window !== 'undefined') && (window.window === window) && window.navigator,
      SourceMapConsumer = require ('source-map').SourceMapConsumer,
      path              = require ('./impl/path'),
      dataURIToBuffer   = require ('data-uri-to-buffer'),
      lastOf            = x => x[x.length - 1]

/*  ------------------------------------------------------------------------ */

const memoize = f => {
    
    const m = x => (x in m.cache) ? m.cache[x] : (m.cache[x] = f(x))
    m.forgetEverything = () => { m.cache = Object.create (null) }
    m.cache = Object.create (null)

    return m
}

/*  ------------------------------------------------------------------------ */

const newSourceFileMemoized = memoize (file => new SourceFile (file))

const getSource = module.exports = file => { return newSourceFileMemoized (path.resolve (file)) }

getSource.resetCache = () => newSourceFileMemoized.forgetEverything ()
getSource.getCache = () => newSourceFileMemoized.cache

/*  ------------------------------------------------------------------------ */

class SourceMap {

    constructor (originalFilePath, sourceMapPath) {

        this.file = sourceMapPath.startsWith ('data:')
                        ? new SourceFile (originalFilePath, dataURIToBuffer (sourceMapPath).toString ())
                        : getSource (path.relativeToFile (originalFilePath, sourceMapPath))

        this.parsed    = (this.file.text && SourceMapConsumer (JSON.parse (this.file.text))) || null
        this.sourceFor = memoize (this.sourceFor.bind (this))
    }

    sourceFor (file) {
        const content = this.parsed.sourceContentFor (file, true /* return null on missing */)
        const fullPath = path.relativeToFile (this.file.path, file)
        return content ? new SourceFile (fullPath, content) : getSource (fullPath)
    }

    resolve (loc) {

        const originalLoc = this.parsed.originalPositionFor (loc)
        return originalLoc.source ? this.sourceFor (originalLoc.source)
                                        .resolve (O.assign ({}, loc, {
                                            line: originalLoc.line,
                                            column: originalLoc.column,
                                            name: originalLoc.name })) : loc
    }
}

/*  ------------------------------------------------------------------------ */

class SourceFile {

    constructor (path, text /* optional */) {
        
        this.path = path

        if (text) {
            this.text = text }

        else {
            try {
                if (isBrowser) {

                    let xhr = new XMLHttpRequest ()

                        xhr.open ('GET', path, false /* SYNCHRONOUS XHR FTW :) */)
                        xhr.send (null)
                        
                    this.text = xhr.responseText }

                else {
                    this.text = module.require ('fs').readFileSync (path, { encoding: 'utf8' }) } }

            catch (e) {
                this.error = e
                this.text = '' } }
    }

    get lines () {
        return (this.lines_ = this.lines_ || this.text.split ('\n'))
    }

    get sourceMap () {

        try {

            if (this.sourceMap_ === undefined) {

                // Node v4 does not support destructuring...
                // const [,url] = this.text.match (/\u0023 sourceMappingURL=(.+)\n?/) || [undefined, undefined] // escape #, otherwise it will match this exact line.. %)
                
                const match = this.text.match (/\u0023 sourceMappingURL=(.+)\n?/) || [undefined, undefined] // escape #, otherwise it will match this exact line.. %)
                    , url = match[1]

                if (url) {
                    
                    const sourceMap = new SourceMap (this.path, url)

                    if (sourceMap.parsed) {
                        this.sourceMap_ = sourceMap
                    }

                } else {

                    this.sourceMap_ = null
                }
            }
        }

        catch (e) {
            this.sourceMap_ = null
            this.sourceMapError = e
        }

        return this.sourceMap_
    }

    resolve (loc /* { line[, column] } */) /*  { line, column, sourceFile, sourceLine } */ {

        return this.sourceMap ? this.sourceMap.resolve (loc) : O.assign ({}, loc, {

            sourceFile:  this,
            sourceLine: (this.lines[loc.line - 1] || ''),
            error:       this.error
        })
    }
}

/*  ------------------------------------------------------------------------ */

},{"source-map":"node_modules/get-source/node_modules/source-map/source-map.js","./impl/path":"node_modules/get-source/impl/path.js","data-uri-to-buffer":"node_modules/data-uri-to-buffer/index.js"}],"node_modules/stacktracey/impl/partition.js":[function(require,module,exports) {
"use strict";

module.exports = (arr_, pred) => {

    const arr   = arr_ || [],
          spans = []
    
    let span = { label: undefined,
                 items: [arr.first] }
                 
    arr.forEach (x => {

        const label = pred (x)

        if ((span.label !== label) && span.items.length) {
            spans.push (span = { label: label, items: [x] }) }

        else {
            span.items.push (x) } })

    return spans
}
},{}],"node_modules/as-table/build/as-table.js":[function(require,module,exports) {
"use strict";

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

const O = Object;

var _require = require('printable-characters');

const first = _require.first,
      strlen = _require.strlen,
      limit = (s, n) => first(s, n - 1) + '';

const asColumns = (rows, cfg_) => {

    const zip = (arrs, f) => arrs.reduce((a, b) => b.map((b, i) => [].concat(_toConsumableArray(a[i] || []), [b])), []).map(args => f.apply(undefined, _toConsumableArray(args))),


    /*  Convert cell data to string (converting multiline text to singleline) */

    cells = rows.map(r => r.map(c => c === undefined ? '' : cfg_.print(c).replace(/\n/g, '\\n'))),


    /*  Compute column widths (per row) and max widths (per column)     */

    cellWidths = cells.map(r => r.map(strlen)),
          maxWidths = zip(cellWidths, Math.max),


    /*  Default config     */

    cfg = O.assign({
        delimiter: '  ',
        minColumnWidths: maxWidths.map(x => 0),
        maxTotalWidth: 0 }, cfg_),
          delimiterLength = strlen(cfg.delimiter),


    /*  Project desired column widths, taking maxTotalWidth and minColumnWidths in account.     */

    totalWidth = maxWidths.reduce((a, b) => a + b, 0),
          relativeWidths = maxWidths.map(w => w / totalWidth),
          maxTotalWidth = cfg.maxTotalWidth - delimiterLength * (maxWidths.length - 1),
          excessWidth = Math.max(0, totalWidth - maxTotalWidth),
          computedWidths = zip([cfg.minColumnWidths, maxWidths, relativeWidths], (min, max, relative) => Math.max(min, Math.floor(max - excessWidth * relative))),


    /*  This is how many symbols we should pad or cut (per column).  */

    restCellWidths = cellWidths.map(widths => zip([computedWidths, widths], (a, b) => a - b));

    /*  Perform final composition.   */

    return zip([cells, restCellWidths], (a, b) => zip([a, b], (str, w) => w >= 0 ? cfg.right ? ' '.repeat(w) + str : str + ' '.repeat(w) : limit(str, strlen(str) + w)).join(cfg.delimiter));
};

const asTable = cfg => O.assign(arr => {
    var _ref;

    /*  Print arrays  */

    if (arr[0] && Array.isArray(arr[0])) return asColumns(arr, cfg).join('\n');

    /*  Print objects   */

    const colNames = [].concat(_toConsumableArray(new Set((_ref = []).concat.apply(_ref, _toConsumableArray(arr.map(O.keys)))))),
          columns = [colNames.map(cfg.title)].concat(_toConsumableArray(arr.map(o => colNames.map(key => o[key])))),
          lines = asColumns(columns, cfg);

    return [lines[0], cfg.dash.repeat(strlen(lines[0]))].concat(_toConsumableArray(lines.slice(1))).join('\n');
}, cfg, {

    configure: newConfig => asTable(O.assign({}, cfg, newConfig))
});

module.exports = asTable({

    maxTotalWidth: Number.MAX_SAFE_INTEGER,
    print: String,
    title: String,
    dash: '-',
    right: false
});


},{"printable-characters":"node_modules/printable-characters/build/printable-characters.js"}],"node_modules/stacktracey/stacktracey.js":[function(require,module,exports) {
var process = require("process");
"use strict";

/*  ------------------------------------------------------------------------ */

const O            = Object,
      isBrowser    = (typeof window !== 'undefined') && (window.window === window) && window.navigator,
      lastOf       = x => x[x.length - 1],
      getSource    = require ('get-source'),
      partition    = require ('./impl/partition'),
      asTable      = require ('as-table'),
      pathRoot     = isBrowser ? window.location.href : (process.cwd () + '/')

/*  ------------------------------------------------------------------------ */

class StackTracey extends Array {

    constructor (input, offset) {
        
        const originalInput          = input
            , isParseableSyntaxError = input && (input instanceof SyntaxError && !isBrowser)
        
        super ()

    /*  Fixes for Safari    */

        this.constructor = StackTracey
        this.__proto__   = StackTracey.prototype

    /*  new StackTracey ()            */

        if (!input) {
             input = new Error ()
             offset = (offset === undefined) ? 1 : offset
        }

    /*  new StackTracey (Error)      */

        if (input instanceof Error) {
            input = input[StackTracey.stack] || input.stack || ''
        }

    /*  new StackTracey (string)     */

        if (typeof input === 'string') {
            input = StackTracey.rawParse (input).slice (offset).map (StackTracey.extractEntryMetadata)
        }

    /*  new StackTracey (array)      */

        if (Array.isArray (input)) {

            if (isParseableSyntaxError) {
                
                const rawLines = module.require ('util').inspect (originalInput).split ('\n')
                    , fileLine = rawLines[0].match (/^([^:]+):(.+)/)

                if (fileLine) {
                    input.unshift ({
                        file: fileLine[1],
                        line: fileLine[2],
                        column: (rawLines[2] || '').indexOf ('^') + 1,
                        sourceLine: rawLines[1],
                        callee: '(syntax error)',
                        syntaxError: true
                    })
                }
            }

            this.length = input.length
            input.forEach ((x, i) => this[i] = x)
        }
    }

    static extractEntryMetadata (e) {
        
        const fileRelative = StackTracey.relativePath (e.file || '')

        return O.assign (e, {

            calleeShort:  e.calleeShort || lastOf ((e.callee || '').split ('.')),
            fileRelative: fileRelative,
            fileShort:    StackTracey.shortenPath (fileRelative),
            fileName:     lastOf ((e.file || '').split ('/')),
            thirdParty:   StackTracey.isThirdParty (fileRelative) && !e.index
        })
    }

    static shortenPath (relativePath) {
        return relativePath.replace (/^node_modules\//, '')
                           .replace (/^webpack\/bootstrap\//, '')
    }

    static relativePath (fullPath) {
        return fullPath.replace (pathRoot, '')
                       .replace (/^.*\:\/\/?\/?/, '')
    }

    static isThirdParty (relativePath) {
        return (relativePath[0] === '~')                          || // webpack-specific heuristic
               (relativePath[0] === '/')                          || // external source
               (relativePath.indexOf ('node_modules')      === 0) ||
               (relativePath.indexOf ('webpack/bootstrap') === 0)
    }

    static rawParse (str) {

        const lines = (str || '').split ('\n')

        const entries = lines.map (line => { line = line.trim ()

            var callee, fileLineColumn = [], native, planA, planB

            if ((planA = line.match (/at (.+) \((.+)\)/)) ||
                (planA = line.match (/(.*)@(.*)/))) {

                callee         =  planA[1]
                native         = (planA[2] === 'native')
                fileLineColumn = (planA[2].match (/(.*):(.+):(.+)/) || []).slice (1) }

            else if ((planB = line.match (/^(at\s+)*(.+):([0-9]+):([0-9]+)/) )) {
                fileLineColumn = (planB).slice (2) }

            else {
                return undefined }

            return {
                beforeParse: line,
                callee:      callee || '',
                index:       isBrowser && (fileLineColumn[0] === window.location.href),
                native:      native || false,
                file:        fileLineColumn[0] || '',
                line:        parseInt (fileLineColumn[1] || '', 10) || undefined,
                column:      parseInt (fileLineColumn[2] || '', 10) || undefined } })

        return entries.filter (x => (x !== undefined))
    }

    withSource (i) {
        return this[i] && StackTracey.withSource (this[i])
    }

    static withSource (loc) {

        if (loc.sourceFile || (loc.file && loc.file.indexOf ('<') >= 0)) { // skip things like <anonymous> and stuff that was already fetched
            return loc
            
        } else {
            let resolved = getSource (loc.file || '').resolve (loc)

            if (resolved.sourceFile) {
                resolved.file = resolved.sourceFile.path
                resolved = StackTracey.extractEntryMetadata (resolved)
            }

            if (resolved.sourceLine && resolved.sourceLine.includes ('// @hide')) {
                resolved.sourceLine  = resolved.sourceLine.replace  ('// @hide', '')
                resolved.hide = true
            }

            return O.assign ({ sourceLine: '' }, loc, resolved)
        }
    }

    get withSources () {
        return new StackTracey (this.map (StackTracey.withSource))
    }

    get mergeRepeatedLines () {
        return new StackTracey (
            partition (this, e => e.file + e.line).map (
                group => {
                    return group.items.slice (1).reduce ((memo, entry) => {
                        memo.callee      = (memo.callee      || '<anonymous>') + '  ' + (entry.callee      || '<anonymous>')
                        memo.calleeShort = (memo.calleeShort || '<anonymous>') + '  ' + (entry.calleeShort || '<anonymous>')
                        return memo }, O.assign ({}, group.items[0])) }))
    }

    get clean () {
        return this.withSources.mergeRepeatedLines.filter ((e, i) => (i === 0) || !(e.thirdParty || e.hide))
    }

    at (i) {
        return O.assign ({

            beforeParse: '',
            callee:      '<???>',
            index:       false,
            native:      false,
            file:        '<???>',
            line:        0,
            column:      0

        }, this[i])
    }

    static locationsEqual (a, b) {
        return (a.file   === b.file) &&
               (a.line   === b.line) &&
               (a.column === b.column)
    }

    get pretty () {

        const trimEnd   = (s, n) => (s.length > n) ? (s.slice (0, n-1) + '') : s        
        const trimStart = (s, n) => (s.length > n) ? ('' + s.slice (-(n-1))) : s

        return asTable (this.withSources.map (
                            e => [
                                ('at ' + trimEnd (e.calleeShort, 30)),
                                trimStart ((e.fileShort && (e.fileShort + ':' + e.line)) || '', 40),
                                trimEnd (((e.sourceLine || '').trim () || ''), 80)
                            ]))
    }

    static resetCache () {

        getSource.resetCache ()
    }

    get asArray () {

    }
}

/*  Chaining helper for .isThirdParty
    ------------------------------------------------------------------------ */

(() => {

    const methods = {

        include (pred) {

            const f = StackTracey.isThirdParty
            O.assign (StackTracey.isThirdParty = (path => f (path) ||  pred (path)), methods)
        },

        except (pred) {

            const f = StackTracey.isThirdParty
            O.assign (StackTracey.isThirdParty = (path => f (path) && !pred (path)), methods)
        },
    }

    O.assign (StackTracey.isThirdParty, methods)

}) ()

/*  Array methods
    ------------------------------------------------------------------------ */

;['map', 'filter', 'slice', 'concat', 'reverse'].forEach (name => {

    StackTracey.prototype[name] = function (/*...args */) { // no support for ...args in Node v4 :(
        
        const arr = Array.from (this)
        return new StackTracey (arr[name].apply (arr, arguments))
    }
})

/*  A private field that an Error instance can expose
    ------------------------------------------------------------------------ */

StackTracey.stack = /* istanbul ignore next */ (typeof Symbol !== 'undefined') ? Symbol.for ('StackTracey') : '__StackTracey'

/*  ------------------------------------------------------------------------ */

module.exports = StackTracey

/*  ------------------------------------------------------------------------ */


},{"get-source":"node_modules/get-source/get-source.js","./impl/partition":"node_modules/stacktracey/impl/partition.js","as-table":"node_modules/as-table/build/as-table.js","process":"../../../../.nvm/versions/node/v12.18.3/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"node_modules/useless/base/reflection.js":[function(require,module,exports) {
var __filename = "/Users/teresapayne/Projects/FM/Beginning-Web-Dev/popdemo/node_modules/useless/base/reflection.js";
"use strict";
/*  ------------------------------------------------------------------------ */

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var O = Object;
/*  ------------------------------------------------------------------------ */

_.hasReflection = true;
/*  ------------------------------------------------------------------------ */

$global.getSource = require('get-source');
/*  ------------------------------------------------------------------------ */

$global.StackTracey = O.assign(require('stacktracey'), {
  fromErrorWithAsync: function (e) {
    var stackEntries = new StackTracey(e),
        asyncContext = e.asyncContext;

    while (asyncContext) {
      stackEntries = stackEntries.concat(new StackTracey(asyncContext.stack));
      asyncContext = asyncContext.asyncContext;
    }

    return stackEntries.mergeRepeatedLines;
  }
});
/*  ------------------------------------------------------------------------ */

_.tests.reflection = {
  'file paths': function () {
    $assert(typeof $uselessPath === "undefined" ? "undefined" : _typeof($uselessPath), 'string');
    $assert($sourcePath.length > 0);
    $assert($uselessPath.length > 0);
  }
};

(function () {
  var currentFile = $platform.Browser ? (new StackTracey()[2] || {
    file: ''
  }).file : __filename;
  $global.const('$uselessPath', _.initial(currentFile.split('/'), $platform.NodeJS ? 2 : 1).join('/') + '/');
  $global.const('$sourcePath', function () {
    var local = ($uselessPath.match(/(.+)\/node_modules\/(.+)/) || [])[1];
    return local ? local + '/' : $uselessPath;
  }());
})();
/*  ------------------------------------------------------------------------ */


var asTable = require('as-table');

StackTracey.prototype[Symbol.for('String.ify')] = function (stringify) {
  return asTable(this.map(function (entry) {
    return ['\t' + 'at ' + entry.calleeShort.slice(0, 30), entry.fileShort && entry.fileShort + ':' + entry.line || '', ((entry.sourceLine || '').trim() || '').slice(0, 80)];
  }));
};

Error.prototype[Symbol.for('String.ify')] = function (stringify) {
  try {
    var stack = StackTracey.fromErrorWithAsync(this).slice(this.stackOffset || 0).clean;
    var why = stringify.limit((this.message || '').replace(/\r|\n/g, '').trim(), 120);
    return '[EXCEPTION] ' + why + (this.notMatching && [].concat(this.notMatching).map(function (x) {
      return '\t' + stringify.noPretty(x);
    }).join('\n') + '\n\n' || '') + '\n\n' + stringify(stack) + '\n';
  } catch (sub) {
    return 'YO DAWG I HEARD YOU LIKE EXCEPTIONS... SO WE THREW EXCEPTION WHILE PRINTING YOUR EXCEPTION:\n\n' + sub.stack + '\n\nORIGINAL EXCEPTION:\n\n' + this.stack + '\n\n';
  }
};
/*  ------------------------------------------------------------------------ */


_.tests.prototypeMeta = {
  'Prototype.$meta': function () {
    var DummyProto = $prototype();
    var DummyTrait = $trait();
    $assertMatches(DummyProto.$meta, {
      name: 'DummyProto',
      type: 'prototype'
    });
    $assertMatches(DummyTrait.$meta, {
      name: 'DummyTrait',
      type: 'trait'
    });
  },
  'String.ify': function () {
    var Dummy = $prototype({});
    $assert(String.ify(Dummy), 'Dummy ()');
  }
};

(function () {
  var findMeta = function (stack) {
    return _.find2(stack.withSources.reverse(), function (location) {
      var match = location.sourceLine.match(/([A-z]+)\s*=\s*\$([A-Za-z0-9_]+)/);
      return match && {
        name: match[1] === 'exports' ? location.fileName : match[1],
        type: match[2],
        file: location.fileShort
      } || false;
    });
  };

  $prototype.macro(function (def, base) {
    if (typeof Symbol !== 'undefined') {
      def.constructor[Symbol.for('String.ify')] = function () {
        return (this.$meta && this.$meta.name || '<prototype>') + ' ()';
      };
    }
    /*  NB: memoization is here because findMeta performs slow (needs to fetch sources and sourcemaps),
            and we dont wanna do this at construction of each prototype. Better do this on first $meta request.    */


    if (!def.$meta) {
      var stack = new StackTracey();
      def.$meta = $static($property(_.memoize(function () {
        return findMeta(stack);
      })));
    }

    return def;
  });
})();
/*  ------------------------------------------------------------------------ */
},{"get-source":"node_modules/get-source/get-source.js","stacktracey":"node_modules/stacktracey/stacktracey.js","as-table":"node_modules/as-table/build/as-table.js"}],"node_modules/useless/base/log.js":[function(require,module,exports) {
"use strict";

var O = require('es7-object-polyfill'),
    bullet = require('string.bullet'),
    asTable = require('as-table');

_.hasLog = true;
_.tests.log = {
  basic: function () {
    log('log (x)'); //  Basic API

    log.green('log.green'); //  Use for plain colored output.

    log.boldGreen('log.boldGreen');
    log.darkGreen('log.darkGreen');
    log.blue('log.blue');
    log.boldBlue('log.boldBlue');
    log.darkBlue('log.darkBlue');
    log.orange('log.orange');
    log.boldOrange('log.boldOrange');
    log.darkOrange('log.darkOrange');
    log.red('log.red'); //  ..for more colors, see the implementation below

    log.boldRed('log.boldRed');
    log.darkRed('log.darkRed');
    log.pink('log.pink');
    log.boldPink('log.boldPink');
    log.darkPink('log.darkPink');
    log.margin();
    log.margin(); // collapses

    log.bright('log.bright');
    log.dark('log.dark');
    log.margin();
    log.success('log.success'); //  Use for quality production logging (logging that lasts).

    log.ok('log.ok');
    log.g('log.g');
    log.gg('log.gg');
    log.info('log.info'); //  Printed location greatly helps to find log cause in code.

    log.i('log.i');
    log.ii('log.ii');
    log.warning('log.warning'); //  For those who cant remember which one, there's plenty of aliases

    log.warn('log.warn');
    log.w('log.w');
    log.ww('log.ww');
    log.error('log.error');
    log.e('log.e');
    log.ee('log.ee');
    $assert(log('log (x) === x'), 'log (x) === x'); // Can be used for debugging of functional expressions
    // (as it returns it first argument, like in _.identity)

    log.write('Consequent', 'arguments', log.color.red, ' joins', 'with', 'whitespace');
    log.write('Multi', log.color.red, 'Colored', log.color.green, 'Output', log.color.blue, 'For', log.color.orange, 'The', log.color.pink, 'Fucking', log.color.none, 'Win');
    log.write(log.boldLine); //  ASCII art <hr>

    log.write(log.thinLine);
    log.write(log.line);
    log.write(log.indent(1), ['You can set indentation', 'that is nicely handled', 'in case of multiline text'].join('\n'));
    log.orange(log.indent(2), '\nCan print nice table layout view for arrays of objects:\n');
    log.orange(log.config({
      indent: 2,
      table: true
    }), [{
      field: 'line',
      matches: false,
      valueType: 'string',
      contractType: 'number'
    }, {
      field: 'column',
      matches: true,
      valueType: 'string',
      contractType: 'number'
    }]);
    log.write('\nObject:', {
      foo: 1,
      bar: 2,
      qux: 3
    }); //  Object printing is supported

    log.write('Array:', [1, 2, 3]); //  Arrays too

    log.write('Function:', _.identity); //  Prints code of a function

    log.write('Complex object:', {
      foo: 1,
      bar: {
        qux: [1, 2, 3],
        garply: _.identity
      }
    }, '\n\n');
    log.withConfig(log.indent(1), function () {
      log.pink('Config stack + scopes + higher order API test:');

      _.each([5, 6, 7], logs.pink(log.indent(1), 'item = ', log.color.blue));
    });
    $assert(log(42), 42);
    $assert(logs.red(42)(), 42);
  }
};

_.extend(
/*  Basic API
 */
$global.log = function () {
  return log.write.apply(this, [log.config({
    location: true
  })].concat(_.asArray(arguments)));
}, {
  // @hide
  Config: $prototype(),

  /*  Could be passed as any argument to any write function.
   */
  config: function (cfg) {
    return new log.Config(cfg);
  }
});

_.extend(log, {
  /*  Shortcut for common cases
   */
  indent: function (n) {
    return log.config({
      indent: n
    });
  },
  where: function (wat) {
    return log.config({
      location: true,
      where: wat || undefined
    });
  },
  color: _.extend(function (x) {
    return (log.color[x] || {}).color;
  }, _.fromPairs(_.map([['none', '0m', ''], ['red', '31m', 'color:crimson'], ['boldRed', ['31m', '1m'], 'color:crimson;font-weight:bold'], ['darkRed', ['31m', '2m'], 'color:crimson'], ['blue', '36m', 'color:royalblue'], ['boldBlue', ['36m', '1m'], 'color:royalblue;font-weight:bold;'], ['darkBlue', ['36m', '2m'], 'color:rgba(65,105,225,0.5)'], ['boldOrange', ['33m', '1m'], 'color:saddlebrown;font-weight:bold;'], ['darkOrange', ['33m', '2m'], 'color:saddlebrown'], ['orange', '33m', 'color:saddlebrown'], ['brown', ['33m', '2m'], 'color:saddlebrown'], ['green', '32m', 'color:forestgreen'], ['boldGreen', ['32m', '1m'], 'color:forestgreen;font-weight:bold'], ['darkGreen', ['32m', '2m'], 'color:forestgreen;opacity:0.5'], ['pink', '35m', 'color:magenta'], ['boldPink', ['35m', '1m'], 'color:magenta;font-weight:bold;'], ['darkPink', ['35m', '2m'], 'color:magenta'], ['black', '0m', 'color:black'], ['bright', ['0m', '1m'], 'color:rgba(0,0,0);font-weight:bold'], ['dark', ['0m', '2m'], 'color:rgba(0,0,0,0.25)']], function (def) {
    return [def[0], log.config({
      color: {
        shell: _.coerceToArray(_.map2(def[1], _.prepends("\x1B["))).join(''),
        css: def[2]
      }
    })];
  }))),

  /*  Need one? Take! I have plenty of them!
   */
  boldLine: '======================================',
  line: '--------------------------------------',
  thinLine: '......................................',

  /*  Set to true to precede each log message with date and time (useful for server side logs).
   */
  timestampEnabled: false,

  /*  For hacking log output (contextFn should be conformant to CPS interface, e.g. have 'then' as last argument)
   */
  withWriteBackend: $scope(function (release, backend, contextFn, done) {
    var prev = log.writeBackend.value;
    log.writeBackend.value = backend;
    contextFn(function (
    /* release */
    then) {
      // @hide
      release(function () {
        log.writeBackend.value = prev;
        if (then) then();
        if (done) done();
      });
    });
  }),

  /*  For writing with forced default backend
   */
  writeUsingDefaultBackend: function ()
  /* arguments */
  {
    var args = arguments;
    log.withWriteBackend(log.impl.defaultWriteBackend, function (done) {
      log.write.apply(null, args);
      done();
    });
  },
  // @hide
  writeBackend: function () {
    return log.writeBackend.value || log.impl.defaultWriteBackend;
  },
  withConfig: function (config, what) {
    log.impl.configStack.push(config);
    var result = what();
    log.impl.configStack.pop();
    return result;
  },
  currentConfig: function () {
    return log.impl.configure(log.impl.configStack);
  },

  /*  Use instead of 'log.newline ()' for collapsing newlines
   */
  margin: function () {
    var lastWrite = undefined;
    return function () {
      if (lastWrite !== log.impl.numWrites) log.newline();
      lastWrite = log.impl.numWrites;
    };
  }(),

  /*  Internals
   */
  impl: {
    configStack: [],
    numWrites: 0,
    configure: function (configs) {
      return _.reduce2({
        indent: 0
      }, _.nonempty(configs), function (memo, cfg) {
        return _.extend(memo, _.nonempty(cfg), {
          indent: memo.indent + (cfg.indent || 0)
        });
      });
    },

    /*  Nuts & guts
     */
    processArguments: function (args) {
      var writeBackend = log.writeBackend();
      var config = log.impl.configure([{
        indent: writeBackend.indent || 0
      }].concat(log.impl.configStack));

      var runs = _.reduce2(
      /*  Initial memo
       */
      [],
      /*  Arguments split by configs
       */
      _.partition3(args, _.isTypeOf.$(log.Config)),
      /*  Gather function
       */
      function (runs, span) {
        if (span.label === true) {
          config = log.impl.configure([config].concat(span.items));
          return runs;
        } else {
          return runs.concat({
            config: config,
            text: log.impl.stringifyArguments(span.items, config)
          });
        }
      });

      var trailNewlinesMatch = runs.last && runs.last.text.reversed.match(/(\n*)([^]*)/);
      var trailNewlines = trailNewlinesMatch && trailNewlinesMatch[1]; // dumb way to select trailing newlines (i'm no good at regex)

      if (trailNewlinesMatch) {
        runs.last.text = trailNewlinesMatch[2].reversed;
      }
      /*  Split by linebreaks
       */


      var newline = {};

      var lines = _.pluck.with('items', _.reject.with(_.property('label'), _.partition3.with(_.equals(newline), _.scatter(runs, function (run, i, emit) {
        _.each(run.text.split('\n'), function (line, i, arr) {
          emit(_.extended(run, {
            text: line
          }));

          if (i !== arr.lastIndex) {
            emit(newline);
          }
        });
      }))));

      var totalText = _.pluck(runs, 'text').join('');

      var where = config.where || log.impl.findWhere(new StackTracey()); // @hide

      var indentation = (config.indentPattern || '\t').repeats(config.indent);
      return {
        lines: lines,
        config: config,
        color: config.color,
        when: new Date().toISOString(),
        args: _.reject(args, _.isTypeOf.$(log.Config)),
        indentation: indentation,
        indentedText: lines.map(_.seq(_.pluck.tails2('text'), _.joinsWith(''), _.prepends(indentation))).join('\n'),
        text: totalText,
        codeLocation: config.location && log.impl.location(where) || '',
        trailNewlines: trailNewlines || '',
        where: config.location && where || undefined
      };
    },
    write: $restArg(_.bindable(function () {
      log.impl.numWrites++;

      var args = _.asArray(arguments);

      var params = log.impl.processArguments(args); // @hide

      log.writeBackend()(params);
      return _.find(args, _.not(_.isTypeOf.$(log.Config)));
    })),
    findWhere: function (stack) {
      //console.log (log.impl.stringify (stack))
      return stack.withSources.filter(function (x) {
        return !(x.hide || x.fileName === 'underscore.js');
      }).at(0);
    },
    defaultWriteBackend: function (params) {
      var codeLocation = params.codeLocation;

      if ($platform.NodeJS) {
        var lines = _.map(params.lines, function (line) {
          return params.indentation + _.map(line, function (run) {
            return run.config.color ? run.config.color.shell + run.text + "\x1B[0m" : run.text;
          }).join('');
        }).join('\n');

        if (log.timestampEnabled) {
          lines = log.color('dark').shell + bullet(String(params.when) + ' ', log.color('none').shell + lines);
        }

        console.log(lines, log.color('dark').shell + codeLocation + "\x1B[0m", params.trailNewlines);
      } else {
        console.log.apply(console, _.reject.with(_.equals(undefined), [].concat(
        /*  Text   */
        [log.timestampEnabled ? '%c' + params.when + '%c' : '', _.map(params.lines, function (line, i) {
          return params.indentation + _.reduce2('', line, function (s, run) {
            return s + (run.text && (run.config.color ? '%c' : '') + run.text || '');
          });
        }).join('\n'), codeLocation ? '%c' + codeLocation : ''].nonempty.join(' '),
        /*  Colors */
        (log.timestampEnabled ? ['color:rgba(0,0,0,0.4)', 'color:black'] : []).concat(_.scatter(params.lines, function (line, i, emit) {
          _.each(line, function (run) {
            if (run.text && run.config.color) {
              emit(run.config.color.css);
            }
          });
        }) || []).concat(codeLocation ? 'color:rgba(0,0,0,0.25)' : []), params.trailNewlines)));
      }
    },

    /*  Ex.: function @ source.js:321  */
    location: function (where) {
      return '(' + [].concat(where.calleeShort || [], [].concat(where.fileName || [], where.line || []).join(':')).join(' @ ') + ')';
    },
    stringifyArguments: function (args, cfg) {
      return args.map(function (arg) {
        var x = log.impl.stringify(arg, cfg);
        return cfg.maxArgLength ? String.ify.limit(x, cfg.maxArgLength) : x;
      }).join(' ');
    },
    stringify: function (what, cfg) {
      return typeof what === 'string' ? what : Array.isArray(what) && (cfg || {}).table ? asTable(what) : String.ify.configure(cfg || {})(what);
    }
  }
})
/*  Printing API
 */
;

(function () {
  var write = log.impl.write;

  _.extend(log, log.printAPI = _.fromPairs(_.concat([['newline', write.$(log.config({
    location: false
  }), '')], ['write', write]], _.flat(_.map(['red failure error e', 'blue info i', 'darkBlue minor m', 'orange warning warn w', 'green success ok g', 'darkGreen dg', 'pink notice alert p', 'boldPink pp', 'dark hint d', 'boldGreen gg', 'bright b', 'boldRed bloody bad ee', 'darkPink dp', 'brown br', 'darkOrange wtf', 'boldOrange ww', 'darkRed er', 'boldBlue ii'], _.splitsWith(' ').then(_.mapsWith(function (name, i, names) {
    return [name, write.$(log.config({
      location: i !== 0,
      color: log.color(names.first)
    }))];
  })))))));
})();

$global.logs = _.higherOrder.map(log.printAPI);

if ($platform.NodeJS) {
  module.exports = log;
}
},{"es7-object-polyfill":"node_modules/es7-object-polyfill/es7-object-polyfill.js","string.bullet":"node_modules/string.bullet/string.bullet.js","as-table":"node_modules/as-table/build/as-table.js"}],"node_modules/useless/base/Testosterone.js":[function(require,module,exports) {
"use strict";

var O = require('es7-object-polyfill');
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
------------------------------------------------------------------------

Testosterone is a cross-platform unit test shell. Features:

    - asynchronous tests
    - asynchronous assertions
    - log handling (log.xxx calls are scheduled to current test log)
    - exception handling (uncaught exceptions are nicely handled)

------------------------------------------------------------------------
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */


var bullet = require('string.bullet'),
    asTable = require('as-table');
/*  A contract for test routines that says that test should fail and it's the behavior expected
 */


Meta.globalTag('shouldFail');
/*  A contract for custom assertions, says that assertion is asynchronous.
 */

Meta.globalTag('async');
/*  This is test suite for tests framework itself.

    As you can see, tests are defined as _.tests.xxx. So, if you have module called 'foo',
    place tests for that module in _.tests.foo  it will be picked up by tests framework
    automagically 
 */

_.tests.Testosterone = {
  /*  3.  To write asynchronous tests, define second argument in your test routine, which
          is 'done' callback. The framework will look into argument count of your routine,
          and if second argument is there, your routine will be considered as asynchronous,
          i.e. not completing until 'done' is explicitly triggered.
   */
  'async': function (done) {
    _.delay(function () {
      done();
    });
  },

  /*  4.  Use $tests to define unit tests on prototypes (works only on stuff in global namespace)
   */
  '$tests': function () {
    var DummyPrototypeWithTest = $prototype({
      $test: function () {}
    });
    var DummyPrototypeWithTests = $prototype({
      $tests: {
        dummy: function () {}
      }
    });
    /*  $test/$tests renders to static immutable property $tests
     */

    $assertTypeMatches(DummyPrototypeWithTests.$tests, [{
      '*': 'function'
    }]);
    $assertThrows(function () {
      DummyPrototypeWithTests.$tests = 42;
    });
    /*  Tests are added to Testosterone.prototypeTests
     */

    $assertMatches(_.pluck(Testosterone.prototypeTests, 'tests'), [DummyPrototypeWithTest.$tests, DummyPrototypeWithTests.$tests]);
  }
};
/*  For marking methods in internal impl that should publish themselves as global functions (like $assert)
 */

Meta.globalTag('assertion');
$global.Testosterone = $singleton({
  prototypeTests: [],

  get isRunning() {
    return this.currentAssertion !== undefined;
  },

  /*  Hook up to assertion syntax defined in common.js
   */
  constructor: function () {
    var _this = this;

    _.each(_.assertions, function (fn, name) {
      this.defineAssertion(name, name === 'assertFails' ? $shouldFail(function (what) {
        what.call(this);
      }) : fn);
    }, this);
    /*  For defining tests inside prototype definitions
     */


    (function (register) {
      $prototype.macro('$test', register);
      $prototype.macro('$tests', register);
    })(function (def, value, name) {
      _this.prototypeTests.push({
        proto: def.constructor,
        tests: value
      });

      def.$tests = $static($property($constant(_.isStrictlyObject(value) && value || _.object([['test', value]]))));
      return def;
    });

    this.run = this.$(this.run);
  },

  /*  Entry point
   */
  run: _.interlocked(function (cfg_) {
    var _this2 = this;

    /*  Configuration
     */
    var defaults = {
      suites: [],
      silent: true,
      verbose: false,
      timeout: 2000,
      filter: _.identity,
      testStarted: function (test) {},
      testComplete: function (test) {}
    };

    var cfg = this.runConfig = _.extend(defaults, cfg_);
    /*  Read cfg.suites
     */


    var suitesIsArray = _.isArray(cfg.suites); // accept either [{ name: xxx, tests: yyy }, ...] or { name: tests, ... }


    var suites = _.map(cfg.suites, this.$(function (suite, name) {
      return this.testSuite(suitesIsArray ? suite.name : name, suitesIsArray ? suite.tests : suite, cfg.context, suite.proto);
    }));
    /*  Pick prototype tests
     */


    var prototypeTests = cfg.codebase === false ? [] : this.collectPrototypeTests();
    /*  Gather tests
     */

    var baseTests = cfg.codebase === false ? [] : this.collectTests();

    var allTests = _.flatten(_.pluck(baseTests.concat(suites).concat(prototypeTests), 'tests'));

    var selectTests = _.filter(allTests, cfg.shouldRun || _.constant(true));
    /*  Reset context (assigning indices)
     */


    this.runningTests = _.map(selectTests, function (test, i) {
      return _.extend(test, {
        indent: cfg.indent,
        index: i
      });
    });

    _.each(this.runningTests, function (t) {
      if (!(t.routine instanceof Function)) {
        log.ee(t.suite, t.name, ' test routine is not a function:', t.routine);
        throw new Error();
      }
    });

    this.runningTests = _.filter(this.runningTests, cfg.filter || _.identity);
    /*  Go
     */

    return __.each(this.runningTests, this.$(this.runTest)).then(function () {
      _.assert(cfg.done !== true);

      cfg.done = true;

      _this2.printLog(cfg);

      _this2.failedTests = _.filter(_this2.runningTests, _.property('failed'));
      _this2.failed = _this2.failedTests.length > 0;
      return !_this2.failed;
    }).catch(function (e) {
      log.margin();
      log.ee(log.boldLine, 'TESTOSTERONE CRASHED', log.boldLine, '\n\n', e);
      throw e;
    });
  }),
  onException: function (e) {
    if (this.currentAssertion) this.currentAssertion.onException(e);else throw e;
  },

  /*  You may define custom assertions through this API
   */
  defineAssertions: function (assertions) {
    _.each(assertions, function (fn, name) {
      this.defineAssertion(name, fn);
    }, this);
  },

  /*  Internal impl
   */
  runTest: function (test, i) {
    var self = this,
        runConfig = this.runConfig;
    log.impl.configStack = []; // reset log config stack, to prevent stack pollution due to exceptions raised within log.withConfig (..)

    return __.then(runConfig.testStarted(test), function () {
      test.verbose = runConfig.verbose;
      test.timeout = runConfig.timeout;
      test.startTime = Date.now();
      return test.run().then(function () {
        test.time = Date.now() - test.startTime;
        return runConfig.testComplete(test);
      });
    });
  },
  collectTests: function () {
    return _.map(_.tests, this.$(function (suite, name) {
      return this.testSuite(name, suite);
    }));
  },
  collectPrototypeTests: function () {
    var _this3 = this;

    return this.prototypeTests.map(function (def) {
      return _this3.testSuite(def.proto.$meta && def.proto.$meta.name || '<prototype>', def.tests, undefined, def.proto);
    });
  },
  testSuite: function (name, tests, context, proto) {
    return {
      name: name || '',
      tests: _(O.entries(typeof tests === 'function' && _.fromPairs([[name, tests]]) || tests)).map(function (keyValue) {
        var test = new Test({
          proto: proto,
          name: keyValue[0],
          routine: keyValue[1],
          suite: name,
          context: context
        });
        test.complete(function () {
          if (!(test.hasLog = test.logCalls.length > 0)) {
            if (test.failed) {
              log.red('FAIL');
            } else if (test.verbose) {
              log.green('PASS');
            }
          }
        });
        return test;
      })
    };
  },
  defineAssertion: function (name, def) {
    var self = this;
    var fn = $untag(def);
    delete $global['$' + name];
    $global['$' + name] = _.withSameArgs(fn, function () {
      var loc = new StackTracey().withSource($platform.Browser && !$platform.Chrome ? 0 : 1);

      if (!self.currentAssertion) {
        return fn.apply(self, arguments);
      } else {
        return self.currentAssertion.babyAssertion(name, def, fn, arguments, loc);
      }
    });
  },
  printLog: function (cfg) {
    if (!cfg.supressLog) {
      var loggedTests = _.filter(this.runningTests, function (test) {
        return test.failed || !cfg.silent && test.hasLog;
      });

      var failedTests = _.filter(this.runningTests, _.property('failed'));

      _.invoke(cfg.verbose ? this.runningTests : loggedTests, 'printLog');

      if (failedTests.length) {
        log.orange('\n' + log.boldLine + '\n' + 'SOME TESTS FAILED:', _.pluck(failedTests, 'name').join(', '), '\n\n');
      } else if (cfg.silent !== true) {
        log.green('\n' + log.boldLine + '\n' + 'ALL TESTS PASS\n\n');
      }
    }
  }
});
/*  Encapsulates internals of test's I/O.
 */

$global.Test = $prototype({
  constructor: function (cfg) {
    _.defaults(this, cfg, {
      name: '<< UNNAMED FOR UNKNOWN REASON >>',
      failed: false,
      routine: undefined,
      verbose: false,
      depth: 1,
      indent: 0,
      failedAssertions: [],
      context: this,
      complete: _.extend(_.barrier(), {
        context: this
      })
    });

    this.babyAssertion = _.interlocked(this.babyAssertion);
  },
  finalize: function () {
    this.babyAssertion.wait(this.$(function () {
      if (this.canFail && this.failedAssertions.length) {
        this.failed = true;
      }

      this.complete(true);
    }));
  },
  babyAssertion: function (name, def, fn, args, loc) {
    var self = this;
    var assertion = new Test({
      mother: this,
      name: name,
      shouldFail: $shouldFail.is(def) || this.shouldFail,
      depth: this.depth + 1,
      location: loc,
      context: this.context,
      timeout: this.timeout / 2,
      verbose: this.verbose,
      silent: this.silent,
      routine: Meta.modify(def, function (fn) {
        return function (done) {
          if ($async.is(args[0]) || $async.is(def)) {
            _.cps.apply(fn, self.context, args, function (args, then) {
              if (then) {
                then.apply(this, args);
              }

              done();
            });
          } else {
            try {
              fn.apply(self.context, args);
              done();
            } catch (e) {
              assertion.onException(e);
            }
          }
        };
      })
    });
    return assertion.run().finally(function (e, x) {
      Testosterone.currentAssertion = self;

      if (assertion.failed || assertion.verbose && assertion.logCalls.notEmpty) {
        var src = assertion.location.sourceLine.trim();
        log.red(log.config({
          location: assertion.location,
          where: assertion.location
        }), src);
        assertion.evalLogCalls();
        return src;
      }
    }).then(function () {
      if (assertion.failed && self.canFail) {
        self.failedAssertions.push(assertion);
      }
    }).catch(function (e) {
      log.ee(log.boldLine, 'TESTOSTERONE CRASHED', log.boldLine, '\n\n', e);
    });
  },
  canFail: $property(function () {
    return !this.failed && !this.shouldFail;
  }),
  fail: function () {
    this.failed = true;
    this.finalize();
  },
  assertionStack: $property(function () {
    var result = [],
        a = this;

    do {
      result.push(a);
      a = a.mother;
    } while (a);

    return result;
  }),
  onException: function (e) {
    if (this.canFail || this.verbose) {
      if (_.isAssertionError(e)) {
        //   a
        //   b
        if ('notMatching' in e) {
          var notMatching = _.coerceToArray(e.notMatching);

          if (e.asColumns) {
            log.orange(asTable(_.map(notMatching, function (obj) {
              return ['\t ' + _.keys(obj)[0], String.ify(_.values(obj)[0])];
            })));
          } else {
            var cases = _.map(notMatching, log.impl.stringify.arity1.then(bullet.$('\t ')));

            var common = _.reduce2(cases, _.longestCommonSubstring) || '';

            if (common.length < 4) {
              common = undefined;
            }

            _.each(cases, function (what) {
              if (common) {
                var where = what.indexOf(common);
                log.write(log.color.orange, what.substr(0, where), log.color.dark, common, log.color.orange, what.substr(where + common.length));
              } else {
                log.orange(what);
              }
            });
          }
        }
      } // print exception
      else {
          if (this.depth > 1) {
            log.newline();
          }

          log.write(e);
        }

      log.newline();
    }

    if (this.canFail) {
      this.fail();
    } else {
      this.finalize();
    }
  },
  run: function () {
    var self = Testosterone.currentAssertion = this,
        routine = Meta.unwrap(this.routine);
    return new Channel(this.$(function (then) {
      this.shouldFail = $shouldFail.is(this.routine);
      this.failed = false;
      this.hasLog = false;
      this.logCalls = [];
      this.failureLocations = {};

      _.withTimeout({
        maxTime: self.timeout,
        expired: function () {
          if (self.canFail) {
            log.ee('TIMEOUT EXPIRED');
            self.fail();
          }
        }
      }, self.complete);

      _.withUncaughtExceptionHandler(self.$(self.onException), self.complete);

      log.withWriteBackend(_.extendWith({
        indent: 1
      }, function (x) {
        /*log.impl.defaultWriteBackend (x);*/
        self.logCalls.push(x);
      }), function (doneWithLogging) {
        self.complete(doneWithLogging.arity0);

        if (then) {
          self.complete(then);
        }
        /*  Continuation-passing style flow control
         */


        if (routine.length > 0) {
          routine.call(self.context, self.$(self.finalize));
        }
        /*  Return-style flow control
         */
        else {
            /*  TODO:   investigate why Promise.resolve ().then (self.$ (self.finalize))
                        leads to broken unhandled exception handling after the Testosterone run completes  */
            var result = undefined;

            try {
              result = routine.call(self.context);
            } catch (e) {
              self.onException(e);
            }

            if (_.isArrayLike(result) && result[0] instanceof Promise) {
              result = __.all(result);
            }

            if (result instanceof Promise) {
              result.then(function (x) {
                self.finalize();
              }.postponed, function (e) {
                self.onException(e);
              });
            } else {
              self.finalize();
            }
          }
      });
    }));
  },
  printLog: function () {
    var suiteName = this.suite && this.suite !== this.name && (this.suite || '').quote('[]') || '';
    log.write(log.color.blue, '\n' + log.boldLine, '\n' + _.nonempty([suiteName, this.name]).join(' '), (this.index + ' of ' + Testosterone.runningTests.length).quote('()') + (this.failed ? ' FAILED' : '') + ':', '\n');
    this.evalLogCalls();
  },
  evalLogCalls: function () {
    _.each(this.logCalls, log.writeBackend().arity1);
  }
});
/*
 */

Meta.globalTag('allowsRecursion');

_.limitRecursion = function (max, fn, name) {
  if (!fn) {
    fn = max;
    max = 0;
  }

  var depth = -1;
  var reported = false;
  return function () {
    if (!reported) {
      if (depth > max) {
        reported = true;
        throw _.extendWith({
          notMatching: _.map(arguments, function (arg, i) {
            return 'arg' + (i + 1) + ': ' + String.ify(arg);
          })
        }, new Error(name + ': max recursion depth reached (' + max + ')'));
      } else {
        var result = (++depth, fn.apply(this, arguments));
        depth--;
        return result;
      }
    }
  };
};

Testosterone.ValidatesRecursion = $trait({
  $test: function () {
    var test = new ($component({
      $traits: [Testosterone.ValidatesRecursion],
      foo: function () {},
      bar: function () {
        this.bar();
      },
      baz: $allowsRecursion({
        max: 2
      }, function () {
        this.baz();
      }),
      qux: $allowsRecursion(function () {
        if (!this.quxCalled) {
          this.quxCalled = true;
          this.qux();
        }
      })
    }))();
    test.foo();
    $assertThrows(test.bar, {
      message: 'bar: max recursion depth reached (0)'
    });
    test.bar(); // should not report second time (to prevent overflood in case of buggy code)

    $assertThrows(test.baz, {
      message: 'baz: max recursion depth reached (2)'
    });
    test.qux();
  },
  $constructor: function () {
    _.each(this, function (member, name) {
      var allowsRecursion = $allowsRecursion.read(member);

      if (_.isFunction($untag(member)) && name !== 'constructor' && (!allowsRecursion || allowsRecursion.max !== undefined)) {
        this[name] = Meta.modify(member, function (fn) {
          return _.limitRecursion(allowsRecursion && allowsRecursion.max || 0, fn, name);
        });
      }
    }, this);
  }
})
/*  $log for methods
 */
;

(function () {
  var colors = _.keys(_.omit(log.color, 'none'));

  colors.each(Meta.globalTag);
  var stringify = String.ify.configure({
    pretty: false
  });
  Meta.globalTag('verbose');
  Testosterone.LogsMethodCalls = $trait({
    /*
            $test: $platform.Browser ? (function () {}) : function (testDone) {
    
                        var Proto = $prototype ({ $traits: [Testosterone.LogsMethodCalls] })
                        var Compo = $extends (Proto, {
                                            foo: $log ($pink ($verbose (function (_42) { $assert (_42, 42); return 24 }))) })
    
                        var compo = new Compo ()
                        var testContext = this
    
                        Compo.$meta (function () {
                            $assert (compo.foo (42), 24)
                            $assert (_.pluck (testContext.logCalls, 'text'), ['Compo.foo (42)', ' 24', ''])
                            $assert (testContext.logCalls[0].color === log.color ('pink'))
                            testDone () }) },
    */
    $macroTags: {
      log: function (def, member, name) {
        var logTag = $log.read(member);
        var param = (_.isBoolean(logTag) ? undefined : logTag) || ($verbose.is(member) ? '{{$proto}}' : '');
        var meta = def.$meta || {};

        var color = log.color[_.find(colors, Meta.hasTag.$(member))];

        var template = param && _.template(param, {
          interpolate: /\{\{(.+?)\}\}/g
        });

        return $prototype.impl.modifyMember(member, function (fn, name_) {
          return function () {
            var this_ = this,
                arguments_ = _.asArray(arguments);

            var this_dump = template && template.call(this, _.extend({
              $proto: meta.name
            }, _.map2(this, stringify))) || this.desc || '';

            var args_dump = _.map(arguments_, stringify).join(', ').quote('()');

            log.write(log.config({
              color: color,
              location: true,
              where: $verbose.is(member) ? undefined : {
                calleeShort: meta.name
              }
            }), _.nonempty([this_dump, name, name_]).join('.'), args_dump);
            return log.withConfig({
              indent: 1,
              color: color,
              protoName: meta.name
            }, function () {
              var numWritesBefore = log.impl.numWrites;
              var result = fn.apply(this_, arguments_);

              if (result !== undefined) {
                log.write('', stringify(result));
              }

              if (log.currentConfig().indent < 2 && log.impl.numWrites - numWritesBefore > 0) {
                log.newline();
              }

              return result;
            });
          };
        });
      }
    }
  });
})();

if ($platform.NodeJS) {
  module.exports = Testosterone;
}
},{"es7-object-polyfill":"node_modules/es7-object-polyfill/es7-object-polyfill.js","string.bullet":"node_modules/string.bullet/string.bullet.js","as-table":"node_modules/as-table/build/as-table.js"}],"node_modules/pipez/build/pipez.es5.js":[function(require,module,exports) {
"use strict";

/*  ------------------------------------------------------------------------ */

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _objectEntries(obj) {
    var entries = [];
    var keys = Object.keys(obj);

    for (var k = 0; k < keys.length; ++k) entries.push([keys[k], obj[keys[k]]]);

    return entries;
}

var merge = function merge(to, from) {

    for (var prop in from) {
        Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
    }

    return to;
};

/*  ------------------------------------------------------------------------ */

var pipez = module.exports = function (functions_, prev) {

    var functions = {}; // bound to self

    var functionNames = Reflect.ownKeys(functions_); // guaranteed to be in property creation order (as defined by the standard)
    var self = Object.assign(

    /*  Function of functions (call chain)  */

    function () {
        for (var _len = arguments.length, initial = Array(_len), _key = 0; _key < _len; _key++) {
            initial[_key] = arguments[_key];
        }

        return functionNames.reduce(function (memo, k) {
            return functions[k].call(self, memo, { initialArguments: initial });
        }, initial);
    }, // @hide

    /*  Additional methods     */

    {
        configure: function configure() {
            var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};


            var modifiedFunctions = {};

            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                var _loop = function _loop() {
                    var k = _step.value;


                    var override = overrides[k],
                        before = overrides['+' + k] || function (x) {
                        return x;
                    },
                        after = overrides[k + '+'] || function (x) {
                        return x;
                    };

                    var boundArgs = typeof override === 'boolean' ? { yes: override } : override || {};

                    modifiedFunctions[k] = function (x, args) {

                        var fn = typeof override === 'function' ? override : functions[k]; // dont cache so people can dynamically change .impl ()

                        var newArgs = Object.assign({}, boundArgs, args),
                            maybeFn = newArgs.yes === false ? function (x) {
                            return x;
                        } : fn;

                        return after.call(this, maybeFn.call(this, before.call(this, x, newArgs), newArgs), newArgs);
                    };
                };

                for (var _iterator = functionNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    _loop();
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            return pipez(modifiedFunctions, self).methods(this.methods_);
        },
        from: function from(name) {

            var subset = null;

            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                for (var _iterator2 = functionNames[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var _k = _step2.value;

                    if (_k === name) {
                        subset = { takeFirstArgument: function takeFirstArgument(args) {
                                return args[0];
                            } };
                    }
                    if (subset) {
                        subset[_k] = functions[_k];
                    }
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                        _iterator2.return();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }

            return pipez(subset, self);
        },
        before: function before(name) {

            var subset = {};

            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
                for (var _iterator3 = functionNames[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                    var _k2 = _step3.value;

                    if (_k2 === name) {
                        break;
                    }
                    subset[_k2] = functions[_k2];
                }
            } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion3 && _iterator3.return) {
                        _iterator3.return();
                    }
                } finally {
                    if (_didIteratorError3) {
                        throw _iteratorError3;
                    }
                }
            }

            return pipez(subset, self);
        },


        methods_: {},

        methods: function methods(_methods) {
            return merge(this, merge(this.methods_, _methods));
        },


        get impl() {
            return functions;
        },
        get prev() {
            return prev;
        }
    });

    var _iteratorNormalCompletion4 = true;
    var _didIteratorError4 = false;
    var _iteratorError4 = undefined;

    try {
        for (var _iterator4 = _objectEntries(functions_)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var _step4$value = _slicedToArray(_step4.value, 2),
                _k3 = _step4$value[0],
                f = _step4$value[1];

            functions[_k3] = f.bind(self);
        }
    } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion4 && _iterator4.return) {
                _iterator4.return();
            }
        } finally {
            if (_didIteratorError4) {
                throw _iteratorError4;
            }
        }
    }

    return self;
};

/*  ------------------------------------------------------------------------ */


},{}],"node_modules/ololog/build/ololog.js":[function(require,module,exports) {
"use strict";

/*  ------------------------------------------------------------------------ */

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _defineEnumerableProperties(obj, descs) { for (var key in descs) { var desc = descs[key]; desc.configurable = desc.enumerable = true; if ("value" in desc) desc.writable = true; Object.defineProperty(obj, key, desc); } return obj; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

var O = Object,
    StackTracey = require('stacktracey'),
    ansi = require('ansicolor'),
    bullet = require('string.bullet'),
    pipez = require('pipez');

/*  ------------------------------------------------------------------------ */

var _stringify = require('string.ify').configure({
    formatter: function formatter(x, stringify) {

        if (x instanceof Error && !(typeof Symbol !== 'undefined' && x[Symbol.for('String.ify')])) {

            if (stringify.state.depth > 0) return '<Error: ' + x.message + '>'; // prevents unwanted pretty printing for Errors that are properties of complex objects

            var indent = '    ',
                why = stringify.limit((x.message || '').replace(/\r|\n/g, '').trim(), 120),
                stack = new StackTracey(x).pretty,
                stackIndented = stack.split('\n').map(function (x) {
                return indent + x;
            }).join('\n'),
                isAssertion = 'actual' in x && 'expected' in x,
                type = x.constructor.name || 'Error';

            if (isAssertion) {

                var str = stringify.configure({ maxStringLength: Number.MAX_VALUE, maxDepth: 8 });

                var actual = bullet(indent + 'actual:   ', str(x.actual)),
                    expected = bullet(indent + 'expected: ', str(x.expected));

                if (actual.split('\n').length > 1 || expected.split('\n').length > 1) // if multiline actual/expected, need extra whitespace inbetween
                    actual += '\n';

                return '[' + type + '] ' + why + '\n\n' + ansi.red(actual) + '\n' + ansi.green(expected) + '\n\n' + stackIndented + '\n';
            } else {
                return '[' + type + '] ' + why + '\n\n' + stackIndented + '\n';
            }
        }
    }
});

/*  ------------------------------------------------------------------------ */

var _require = require('printable-characters'),
    isBlank = _require.isBlank,
    blank = _require.blank,
    changeLastNonemptyLine = function changeLastNonemptyLine(lines, fn) {

    for (var i = lines.length - 1; i >= 0; i--) {

        if (i === 0 || !isBlank(lines[i])) {

            lines[i] = fn(lines[i]);
            break;
        }
    }
    return lines;
};

/*  ------------------------------------------------------------------------ */

var log = pipez({

    /*  ------------------------------------------------------------------------ */

    stringify: function stringify(args, cfg) {
        var print = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _stringify.configure(cfg);
        return args.map(function (arg) {
            return typeof arg === 'string' ? arg : print(arg);
        });
    },

    trim: function trim(tokens, _ref) {
        var _ref$max = _ref.max,
            max = _ref$max === undefined ? undefined : _ref$max;
        return !max ? tokens : tokens.map(function (t) {
            return _stringify.limit(t, max);
        });
    },

    lines: function lines(tokens, _ref2) {
        var _ref2$linebreak = _ref2.linebreak,
            linebreak = _ref2$linebreak === undefined ? '\n' : _ref2$linebreak;


        var lines = [[]];
        var leftPad = [];

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = tokens[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var t = _step.value;

                var _t$split = t.split(linebreak),
                    _t$split2 = _toArray(_t$split),
                    first = _t$split2[0],
                    rest = _t$split2.slice(1);

                lines[lines.length - 1].push(first);
                lines = [].concat(_toConsumableArray(lines), _toConsumableArray(rest.map(function (t) {
                    return t ? [].concat(leftPad, [t]) : [];
                })));

                var pad = blank(!rest.length ? t : rest[rest.length - 1]);

                if (pad) {
                    leftPad.push(pad);
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }

        return lines;
    },

    concat: function concat(lines, _ref3) {
        var _ref3$separator = _ref3.separator,
            separator = _ref3$separator === undefined ? ' ' : _ref3$separator;
        return lines.map(function (tokens) {
            return tokens.join(separator);
        });
    },

    indent: function indent(lines, _ref4) {
        var _ref4$level = _ref4.level,
            level = _ref4$level === undefined ? 0 : _ref4$level,
            _ref4$pattern = _ref4.pattern,
            pattern = _ref4$pattern === undefined ? '\t' : _ref4$pattern;
        return lines.map(function (line) {
            return pattern.repeat(level) + line;
        });
    },

    time: function time(lines, _ref5) {
        var _ref5$when = _ref5.when,
            when = _ref5$when === undefined ? new Date() : _ref5$when,
            _ref5$print = _ref5.print,
            print = _ref5$print === undefined ? function (when) {
            return ansi.darkGray(when.toISOString()) + '\t';
        } : _ref5$print;
        return bullet(print(when), lines);
    },

    locate: function locate(lines, _ref6) {
        var _ref6$shift = _ref6.shift,
            shift = _ref6$shift === undefined ? 0 : _ref6$shift,
            _ref6$where = _ref6.where,
            where = _ref6$where === undefined ? new StackTracey().clean.at(2 + shift) : _ref6$where,
            _ref6$join = _ref6.join,
            join = _ref6$join === undefined ? function (a, sep, b) {
            return a && b ? a + sep + b : a || b;
        } : _ref6$join,
            _ref6$print = _ref6.print,
            print = _ref6$print === undefined ? function (_ref7) {
            var calleeShort = _ref7.calleeShort,
                _ref7$fileName = _ref7.fileName,
                fileName = _ref7$fileName === undefined ? [] : _ref7$fileName,
                _ref7$line = _ref7.line,
                line = _ref7$line === undefined ? [] : _ref7$line;
            return ansi.darkGray('(' + join(calleeShort, ' @ ', join(fileName, ':', line)) + ')');
        } : _ref6$print;
        return changeLastNonemptyLine(lines, function (line) {
            return join(line, ' ', print(where));
        });
    },

    join: function join(lines, _ref8) {
        var _ref8$linebreak = _ref8.linebreak,
            linebreak = _ref8$linebreak === undefined ? '\n' : _ref8$linebreak;
        return lines.join(linebreak);
    },

    render: function render(text, _ref9) {
        var _ref9$engine = _ref9.engine,
            engine = _ref9$engine === undefined ? typeof window !== 'undefined' && window.window === window && window.navigator ? navigator.userAgent.indexOf('Chrome') >= 0 ? 'chrome' : 'generic' : 'ansi' : _ref9$engine,
            _ref9$engines = _ref9.engines,
            engines = _ref9$engines === undefined ? {/* configurable */} : _ref9$engines,
            _ref9$consoleMethod = _ref9.consoleMethod,
            consoleMethod = _ref9$consoleMethod === undefined ? 'log' : _ref9$consoleMethod,
            _ref9$defaults = _ref9.defaults,
            defaults = _ref9$defaults === undefined ? {

            ansi: function ansi(s) {
                return console[consoleMethod](s);
            },
            chrome: function chrome(s) {
                var _console;

                return (_console = console)[consoleMethod].apply(_console, _toConsumableArray(ansi.parse(s).asChromeConsoleLogArguments));
            },
            generic: function generic(s) {
                return console[consoleMethod](ansi.strip(s));
            }
        } : _ref9$defaults;
        return text && O.assign(defaults, engines)[engine](text), text;
    },

    returnValue: function returnValue(__, _ref10) {
        var _ref10$initialArgumen = _slicedToArray(_ref10.initialArguments, 1),
            firstArgument = _ref10$initialArgumen[0];

        return firstArgument;
    }

    /*  ------------------------------------------------------------------------ */

}).configure({

    time: false // disables 'time' step (until enabled back explicitly)

    /*  ------------------------------------------------------------------------ */

}).methods({

    get null() {
        return pipez({ returnValue: function returnValue(args) {
                return args[0];
            } }).methods(this.methods_);
    },

    indent: function indent(level) {
        return this.configure({ indent: { level: level } });
    },


    get error() {
        return this.configure({ render: { consoleMethod: 'error' } });
    },
    get warn() {
        return this.configure({ render: { consoleMethod: 'warn' } });
    },
    get info() {
        return this.configure({ render: { consoleMethod: 'info' } });
    },

    maxArrayLength: function maxArrayLength(n) {
        return this.configure({ stringify: { maxArrayLength: n } });
    },
    maxDepth: function maxDepth(n) {
        return this.configure({ stringify: { maxDepth: n } });
    },
    maxLength: function maxLength(n) {
        return this.configure({ stringify: { maxLength: n } });
    },


    get unlimited() {
        return this.configure({ stringify: { maxStringLength: Number.MAX_VALUE, maxArrayLength: Number.MAX_VALUE, maxDepth: Number.MAX_VALUE } });
    },
    get noPretty() {
        return this.configure({ stringify: { pretty: false } });
    },
    get noLocate() {
        return this.configure({ locate: false });
    },
    precision: function precision(n) {
        return this.configure({ stringify: { precision: n } });
    },


    get serialize() {
        return this.before('render');
    },
    get deserialize() {
        return this.from('render');
    },

    newline: function newline() {
        return this.from('join')(['']);
    }
});

/*  ------------------------------------------------------------------------ */

ansi.names.forEach(function (color) {
    var _log$methods, _mutatorMap;

    log.methods((_log$methods = {}, _mutatorMap = {}, _mutatorMap[color] = _mutatorMap[color] || {}, _mutatorMap[color].get = function () {
        return this.configure({ 'concat+': function concat(lines) {
                return lines.map(ansi[color]);
            } });
    }, _defineEnumerableProperties(_log$methods, _mutatorMap), _log$methods));
});

/*  ------------------------------------------------------------------------ */

module.exports = log;

/*  ------------------------------------------------------------------------ */


},{"stacktracey":"node_modules/stacktracey/stacktracey.js","ansicolor":"node_modules/ansicolor/build/ansicolor.js","string.bullet":"node_modules/string.bullet/string.bullet.js","pipez":"node_modules/pipez/build/pipez.es5.js","string.ify":"node_modules/string.ify/build/string.ify.js","printable-characters":"node_modules/printable-characters/build/printable-characters.js"}],"node_modules/useless/base/Androgene.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

(function () {
  var _ = require('underscore');

  var O = Object;

  var StackTracey = require('stacktracey');

  var ololog = require('ololog');
  /*  ------------------------------------------------------------------------ */


  var locationId = function (x) {
    return '' + x.file + (x.line || '');
  }; // do not count column, because we show whole source lines (TODO: maybe implement column highlighting)

  /*  TODO: move outta here
      ------------------------------------------------------------------------ */


  $mixin(Promise, {
    shouldBe: function (x) {
      return this.then(function (y) {
        if (x !== y) {
          throw new AndrogeneError();
        }
      });
    },
    shouldFail: $property(function () {
      return this.then(function () {
        throw new AndrogeneError();
      }, function () {});
    })
  });
  /*  ------------------------------------------------------------------------ */

  var AndrogeneError = /*#__PURE__*/function (_Error) {
    _inherits(AndrogeneError, _Error);

    var _super = _createSuper(AndrogeneError);

    function AndrogeneError(msg) {
      _classCallCheck(this, AndrogeneError);

      return _super.call(this, msg || 'assertion failed');
    }

    return AndrogeneError;
  }( /*#__PURE__*/_wrapNativeSuper(Error));

  var OriginalPromise = Promise;
  /*  ------------------------------------------------------------------------ */

  $global.AndrogeneProcessContext = $prototype({
    current: undefined,
    constructor: function () {
      this.eventLog = [];
      this.numLogMessages = 0;
      this.numErrors = 0;
      this.where = new Error(); // @hide

      this.state = 'pending';

      if ((this.parent = AndrogeneProcessContext.current) !== undefined) {
        this.parent.eventLog.push(this);
        this.env = this.parent.env;
      }
    },
    root: $property(function () {
      return this.parent && this.parent.root || this;
    }),
    push: $static(function (context) {
      var prev = AndrogeneProcessContext.current;
      AndrogeneProcessContext.current = context;
      var PrevPromise = Promise;
      Promise = AndrogenePromise;

      var logHook = function () {
        context.addEvent([log.config({
          where: new StackTracey().withSource(5)
        })].concat(_.initial(arguments)));
        return _.find(arguments, _.not(_.instanceOf(log.Config)));
      };

      log.impl.write.intercept(logHook);
      var olologRender = ololog.impl.render;

      ololog.impl.render = function (text) {
        context.addEvent({
          olologRender: olologRender,
          text: text
        });
      };

      return function ()
      /* pop */
      {
        AndrogeneProcessContext.current = prev;
        Promise = PrevPromise;
        log.impl.write.off(logHook);
        ololog.impl.render = olologRender;
      };
    }),
    addEvent: function (e) {
      for (var ctx = this; ctx; ctx = ctx.parent) {
        if (e instanceof Error) {
          ctx.numErrors++;
        } else if (e.olologRender || Array.isArray(e)) {
          ctx.numLogMessages++;
        }
      }

      this.eventLog.push(e);
    },

    get hasSomethingToReport() {
      return this.numErrors + this.numLogMessages > 0;
    },

    within: function (fn) {
      var self = this;
      return function () {
        var pop = AndrogeneProcessContext.push(self);

        try {
          var x = fn.apply(this, arguments);
          pop();
          return x;
        } // @hide
        catch (e) {
          pop();
          throw e;
        }
      };
    },
    stackTracey: function (where) {
      return new StackTracey(where).filter(function (e, i) {
        return !(e.line === 5);
      }); // Babeled sources produce stacktraces with a glitch, fast-fix for it
    },
    report: function () {
      var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var {
        indent = 0,
        prevLocations = []
      } = state;
      var supressRedundantNesting = this.eventLog.length === 1 && this.eventLog[0] instanceof AndrogeneProcessContext;
      var head = this.reportLocation(state);
      var body = this.reportContents(O.assign({}, state, {
        indent: indent + (head.length === 0 || supressRedundantNesting ? 0 : 1),
        prevLocations: new Set([].concat(_toConsumableArray(prevLocations), _toConsumableArray(_.map(head, function (m) {
          return locationId(m.data.where);
        }))))
      }));
      return state.verbose || body.length > 0 ? [].concat(_toConsumableArray(head), _toConsumableArray(body)) : [];
    },
    reportLocation: function () {
      var _this = this;

      var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var {
        prevLocations: prevLocations
      } = state;
      var color = log.color[{
        'fulfilled': 'green',
        'pending': 'orange',
        'rejected': 'red',
        '': 'purple'
      }[this.state || '']];
      var stack = this.stackTracey(this.where).slice(3).clean.filter(function (e) {
        return !e.hide && !e.native && e.sourceLine && !prevLocations.has(locationId(e));
      }).reverse();
      return stack.map(function (loc) {
        return {
          type: 'location',
          data: _this.log(color, log.config({
            indent: state.indent || 0,
            location: true,
            where: loc
          }), '', (loc.sourceLine || '').trim())
        };
      });
    },
    reportContents: function () {
      var _this2 = this;

      var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var {
        indent = 0,
        visited = new Set()
      } = state;
      var report = [];
      return this.eventLog.filter(function (x) {
        return !visited.has(x);
      }).each(function (x) {
        return visited.add(x);
      }).map(function (x) {
        return x instanceof AndrogeneProcessContext ? x.report(O.assign(state, {
          visited: visited
        })) : x instanceof Error ? _this2.reportError(x, state) : Array.isArray(x) ? [{
          type: 'log',
          data: _this2.log.apply(_this2, [log.indent(indent)].concat(_toConsumableArray(x || [])))
        }] : [{
          type: 'log',
          data: _this2.log(log.indent(indent), x.text)
        }];
      }).reduce(function (a, b) {
        return [].concat(_toConsumableArray(a), _toConsumableArray(b));
      }, []);
    },
    reportError: function (e, _ref) {
      var {
        indent = 0
      } = _ref;
      var loc = this.stackTracey(e).withSource(e.stackOffset || 0);
      return [].concat(_toConsumableArray(loc ? [{
        type: 'location',
        data: this.log(log.config({
          indent: indent,
          color: log.color('boldRed'),
          location: true,
          where: loc
        }), '', (loc.sourceLine || '').trim())
      }] : []), [{
        type: 'error',
        data: this.log(log.config({
          indent: indent + 1,
          color: log.color('bright')
        }), '[EXCEPTION] ' + e.message)
      }]);
    },
    log: function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return log.impl.processArguments(args);
    },
    displayReport: function () {
      var report = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.report();

      var blocks = _.partition2(report, function (_ref2, i) {
        var {
          type: type,
          data: {
            lines: lines,
            config: {
              indent: indent
            }
          }
        } = _ref2;
        return (// generates unique 'block id'
          type + indent + ( // groups entries by type/indent
          lines.length > 1 && i)
        );
      } // separates multiline log items
      );

      for (var block of blocks) {
        for (var {
          data: data
        } of block) {
          log.writeBackend()(data);
        }

        log.newline();
      }
    }
  });
  /*  ------------------------------------------------------------------------ */

  AndrogeneProcessContext.within = function (fn) {
    return AndrogeneProcessContext.current && AndrogeneProcessContext.current.within(fn) || fn;
  };
  /*  ------------------------------------------------------------------------ */


  $global.AndrogenePromise = /*#__PURE__*/function (_Promise) {
    _inherits(_class, _Promise);

    var _super2 = _createSuper(_class);

    function _class(fn) {
      var _thisSuper, _this3;

      _classCallCheck(this, _class);

      if (AndrogenePromise.constructing === true) {
        _this3 = _super2.call(this, fn);
      } else {
        var processContext = new AndrogeneProcessContext(); // @hide

        /*  Run super constuctor to acquire resolve/reject triggers,
            wrapping 'reject' so that it reports errors to the current log.
         */

        var resolve, reject;
        _this3 = _super2.call(this, function (resolve_, reject_) {
          resolve = resolve_;

          reject = function (e) {
            processContext.addEvent(e);
            reject_(e);
          };
        });
        _this3.processContext = processContext;
        /*  Run 'fn' within created process context
         */

        try {
          processContext.within(fn)(resolve, reject);
        } // @hide
        catch (e) {
          reject(e);
        }
        /*  Bind to self to introduce the synchronous state flag. And hence 'then' method creates
            an instance of AndrogenePromise internally, the 'constructing' flag needed to prevent
            an infinite init loop.
         */


        AndrogenePromise.constructing = true;

        _get((_thisSuper = _assertThisInitialized(_this3), _getPrototypeOf(_class.prototype)), "then", _thisSuper).call(_thisSuper, function (x) {
          processContext.state = 'fulfilled';
        }, function (x) {
          processContext.state = 'rejected';
        });

        delete AndrogenePromise.constructing;
      }

      return _possibleConstructorReturn(_this3);
    }

    _createClass(_class, [{
      key: "then",
      value: function then(resolve, reject) {
        var next = this.processContext.within(OriginalPromise.prototype.then, 2).apply(this, // @hide
        _.map(arguments, function (fn) {
          return fn && function (x) {
            return next.processContext.within(fn, -3)(x);
          };
        })); // @hide

        return next;
      }
    }, {
      key: "disarmAndrogene",
      value: function disarmAndrogene() {
        return new OriginalPromise(OriginalPromise.prototype.then.bind(this));
      }
    }], [{
      key: "race",
      value: function race(promises) {
        return OriginalPromise.race(promises);
      }
    }, {
      key: "eval",
      value: function _eval(x) {
        return x instanceof AndrogenePromise ? x : x instanceof Function ? new AndrogenePromise(function (resolve) {
          resolve(x());
        }) : // @hide
        AndrogenePromise.resolve(x);
      }
    }]);

    return _class;
  }( /*#__PURE__*/_wrapNativeSuper(Promise));
  /*  ------------------------------------------------------------------------ */

})();
},{"underscore":"node_modules/underscore/underscore.js","stacktracey":"node_modules/stacktracey/stacktracey.js","ololog":"node_modules/ololog/build/ololog.js"}],"node_modules/xhr2/lib/browser.js":[function(require,module,exports) {
module.exports = XMLHttpRequest;
},{}],"node_modules/useless/base/http.js":[function(require,module,exports) {
"use strict";
/*  ------------------------------------------------------------------------ */

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _ = require('underscore');

var O = Object;
/*  ------------------------------------------------------------------------ */

if (!$global.XMLHttpRequest) {
  $global.XMLHttpRequest = require('xhr2');
}
/*  ------------------------------------------------------------------------ */


$global.Http = $singleton(Component, {
  /*  You can re-use the HttpMethods trait to build API-specific layers over Http */
  $traits: [$global.HttpMethods = $trait({
    get: function (path, cfg) {
      return this.request('GET', path, cfg);
    },
    post: function (path, cfg) {
      return this.request('POST', path, cfg);
    },
    loadFile: function (path, cfg) {
      return this.request('GET', path, {
        responseType: 'arraybuffer'
      });
    },
    uploadFile: function (path, file, cfg) {
      return this.post(path, _.extend2({
        data: file,
        headers: {
          'Content-Type': 'binary/octet-stream',
          'X-File-Name': Parse.fileName(file.name || 'file').transliterate || 'file',
          'X-File-Size': file.size,
          'X-File-Type': file.type
        }
      }, cfg));
    }
  })],
  request: function (type, path, cfg_) {
    var cfg = cfg_ || {};
    /*  Local state (will be initialized at Promise construction) */

    var xhr, abort;

    var progress = _.observable(0);

    if (cfg.progress) {
      progress(cfg.progress);
    }
    /*  returned Promise     */


    var p = new Promise(function (resolve, reject) {
      var prePath = $platform.Browser && (cfg.protocol || cfg.hostname || cfg.port) ? (cfg.protocol || window.location.protocol) + '//' + (cfg.hostname || window.location.hostname) + ':' + (cfg.port || window.location.port) : '';
      /*  Init XMLHttpRequest
       */

      xhr = new XMLHttpRequest();
      xhr.open(type, prePath + path, true);
      /*  Set to 'arraybuffer' to receive binary data
       */

      if (cfg.responseType) xhr.responseType = cfg.responseType;
      /*  Set headers
       */

      _.each(cfg.headers, function (value, key) {
        xhr.setRequestHeader(key, value);
      });
      /*  Bind events
       */


      xhr.onprogress = Http.progressCallbackWithSimulation(progress);

      xhr.onload = xhr.onerror = function () {
        if (cfg.progress) {
          cfg.progress(1);
        }

        var response = xhr.responseType === 'arraybuffer' ? xhr.response : xhr.responseText;

        if (xhr.status === 200) {
          resolve(response);
        } else {
          reject(_.extend(new Error(xhr.statusText), {
            httpResponse: response,
            httpStatus: xhr.status
          }));
        }
      };
      /*  Send
       */


      if (cfg.data) {
        xhr.send(cfg.data);
      } else {
        xhr.send();
      }
    });
    /*  Publish some additional methods as properties of the returned Promise */

    p.progress = function (accept) {
      progress(accept);
      return this;
    };

    p.abortableWith(function () {
      return xhr.abort();
    });
    return p;
  },
  progressCallbackWithSimulation: function (accept) {
    var simulated = 0;
    accept(0);
    return function (e) {
      if (e.lengthComputable) {
        accept(e.loaded / e.total);
      } else {
        accept(simulated = (simulated += 0.1) > 1 ? 0 : simulated);
      }
    };
  }
});
/*  An example of custom API layer over Http:

    1.  Converts request I/O to JSON
    2.  Interprets { success: true/false, value: ... } semantics
    3.  Adds cross-machine exception throwing
    
    ------------------------------------------------------------------------ */

$global.JSONAPI = $singleton(Component, {
  $traits: [HttpMethods],
  request: function (type, path, cfg_) {
    var isAbsolutePath = /^[^\/]*:/.test(path);

    var cfg = _.extend2({
      headers: {
        'Cache-Control': 'no-cache',
        'Content-Type': 'application/json; charset=utf-8'
      }
    }, cfg_);

    if (cfg.what) {
      cfg.data = JSON.stringify(cfg.what);
    }

    var stackBeforeCall = _.hasReflection && new StackTracey(); // @hide 

    return Http.request(type, isAbsolutePath ? path : '/api/' + path, cfg).finally(function (e, response) {
      if (response) {
        return JSON.parse(response);
      } else if (e) {
        if (e.httpResponse) {
          return JSON.parse(e.httpResponse);
        } else {
          throw e;
        }
      } else {
        throw new Error('empty response');
      }
    }).then(function (response) {
      if (response.success) {
        return response.value;
      } else {
        if (response.parsedStack) {
          var fieldName = typeof Symbol !== 'undefined' ? Symbol.for('StackTracey') : '__StackTracey';
          var joinedStack = response.parsedStack.map(function (e) {
            return O.assign(e, {
              file: '/api/source/' + e.file
            });
          }).concat(stackBeforeCall || []);
          throw O.assign(new Error('SERVER: ' + response.error), _defineProperty({
            remote: true
          }, fieldName, joinedStack));
        } else {
          throw new Error(response.error);
        }
      }
    });
  }
});
},{"underscore":"node_modules/underscore/underscore.js","xhr2":"node_modules/xhr2/lib/browser.js"}],"node_modules/useless/useless.js":[function(require,module,exports) {
var global = arguments[3];
"use strict";

var isBrowser = typeof window !== 'undefined';

if (!isBrowser) {
  require('./babel'); // transpiles ES6+ via the `require` hook

}

var $global = isBrowser ? window : global;
$global.$uselessFile = 'useless.js';

var _ = $global._ = module.exports = require('./base/3rd/underscore-fix'); // latest underscore from GitHub, fixes strict-mode issue

/*  Internal dependencies
    ======================================================================== */

/*  Basics of basics
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */


require('./base/tier0/platform'); // platform abstraction layer


require('./base/tier0/meta-tags'); // metaprogramming utility


require('./base/tier0/assert'); // $assert syntax


require('./base/tier0/arguments'); // argument count tracking utility (to streamline metaprogramming utilities)


require('./base/tier0/function'); // function-centric utilities


require('./base/tier0/busybox'); // a vocabulary for functional expressions that process real stuff


require('./base/tier0/type'); // type system extensions


require('./base/tier0/stdlib'); // consider it as underscore 2.0


require('./base/tier0/properties'); // properties 2.0


require('./base/tier0/typeMatch'); // advanced type system extensions

/*  Delivers continuation-passing style notation to various common things
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */


require('./base/CPS');
/*  Provides infix notation for stdlib utility
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */


require('./base/infix/extensionMethods'); // bootstrap


require('./base/infix/Function'); // extends Function


require('./base/infix/Array'); // extends Array


require('./base/infix/String'); // extends String

/*  Dynamic code binding toolbox
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */


require('./base/dynamic/bindable'); // for ad-hoc dependency injection in any object's method


require('./base/dynamic/stream'); // a generalization of Event (multicast model for function calls)

/*  OOP paradigm
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */


require('./base/OOP');
/*  Otherwise basic utility
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */


require('./base/infix/Set');

require('./base/Promise+');

require('./base/Channel');

require('./base/Parse'); // clumsy parsing utils


require('./base/Sort'); // sort utils


require('./base/concurrency'); // concurrency utility


require('./base/math'); // math utility


require('./base/component'); // component facility


require('./base/Rx'); // regular expressions helper

/*  Developer tools
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */


String.ify = require('string.ify');
$global.ansi = require('ansicolor').nice;

require('./base/uncaught'); // uncaught exception facility


require('./base/reflection'); // callstack access + source code access


require('./base/log'); // logging facility


require('./base/Testosterone'); // unit test shell


require('./base/Androgene'); // a "promising" evolution of Testosterone.js (SKETCH)

/*  Networking
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */


require('./base/http');
},{"./babel":"node_modules/useless/babel.js","./base/3rd/underscore-fix":"node_modules/useless/base/3rd/underscore-fix.js","./base/tier0/platform":"node_modules/useless/base/tier0/platform.js","./base/tier0/meta-tags":"node_modules/useless/base/tier0/meta-tags.js","./base/tier0/assert":"node_modules/useless/base/tier0/assert.js","./base/tier0/arguments":"node_modules/useless/base/tier0/arguments.js","./base/tier0/function":"node_modules/useless/base/tier0/function.js","./base/tier0/busybox":"node_modules/useless/base/tier0/busybox.js","./base/tier0/type":"node_modules/useless/base/tier0/type.js","./base/tier0/stdlib":"node_modules/useless/base/tier0/stdlib.js","./base/tier0/properties":"node_modules/useless/base/tier0/properties.js","./base/tier0/typeMatch":"node_modules/useless/base/tier0/typeMatch.js","./base/CPS":"node_modules/useless/base/CPS.js","./base/infix/extensionMethods":"node_modules/useless/base/infix/extensionMethods.js","./base/infix/Function":"node_modules/useless/base/infix/Function.js","./base/infix/Array":"node_modules/useless/base/infix/Array.js","./base/infix/String":"node_modules/useless/base/infix/String.js","./base/dynamic/bindable":"node_modules/useless/base/dynamic/bindable.js","./base/dynamic/stream":"node_modules/useless/base/dynamic/stream.js","./base/OOP":"node_modules/useless/base/OOP.js","./base/infix/Set":"node_modules/useless/base/infix/Set.js","./base/Promise+":"node_modules/useless/base/Promise+.js","./base/Channel":"node_modules/useless/base/Channel.js","./base/Parse":"node_modules/useless/base/Parse.js","./base/Sort":"node_modules/useless/base/Sort.js","./base/concurrency":"node_modules/useless/base/concurrency.js","./base/math":"node_modules/useless/base/math.js","./base/component":"node_modules/useless/base/component.js","./base/Rx":"node_modules/useless/base/Rx.js","string.ify":"node_modules/string.ify/build/string.ify.js","ansicolor":"node_modules/ansicolor/build/ansicolor.js","./base/uncaught":"node_modules/useless/base/uncaught.js","./base/reflection":"node_modules/useless/base/reflection.js","./base/log":"node_modules/useless/base/log.js","./base/Testosterone":"node_modules/useless/base/Testosterone.js","./base/Androgene":"node_modules/useless/base/Androgene.js","./base/http":"node_modules/useless/base/http.js"}],"animation.js":[function(require,module,exports) {
var popmotion = require("popmotion");

require("useless"); // code taken from one of the examples on popmotion.io


var styler = popmotion.styler,
    spring = popmotion.spring,
    listen = popmotion.listen,
    pointer = popmotion.pointer,
    value = popmotion.value; // the above syntax is instead of writing out each variable - I know there's something in popmotion called spring, so let's call it spring

var ball = document.querySelector('.box');
var divStyler = styler(ball);
var ballXY = value({
  x: 0,
  y: 0
}, divStyler.set);
listen(ball, 'mousedown touchstart').start(function (e) {
  e.preventDefault();
  pointer(ballXY.get()).start(ballXY);
});
listen(document, 'mouseup touchend').start(function () {
  spring({
    from: ballXY.get(),
    velocity: ballXY.getVelocity(),
    to: {
      x: 0,
      y: 0
    },
    stiffness: 200 // mass: 1,
    // damping: 10

  }).start(ballXY);
});
},{"popmotion":"node_modules/popmotion/dist/popmotion.es.js","useless":"node_modules/useless/useless.js"}],"../../../../.nvm/versions/node/v12.18.3/lib/node_modules/parcel-bundler/src/builtins/hmr-runtime.js":[function(require,module,exports) {
var global = arguments[3];
var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;

function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}

module.bundle.Module = Module;
var checkedAssets, assetsToAccept;
var parent = module.bundle.parent;

if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = "" || location.hostname;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + ':' + "53137" + '/');

  ws.onmessage = function (event) {
    checkedAssets = {};
    assetsToAccept = [];
    var data = JSON.parse(event.data);

    if (data.type === 'update') {
      var handled = false;
      data.assets.forEach(function (asset) {
        if (!asset.isNew) {
          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);

          if (didAccept) {
            handled = true;
          }
        }
      }); // Enable HMR for CSS by default.

      handled = handled || data.assets.every(function (asset) {
        return asset.type === 'css' && asset.generated.js;
      });

      if (handled) {
        console.clear();
        data.assets.forEach(function (asset) {
          hmrApply(global.parcelRequire, asset);
        });
        assetsToAccept.forEach(function (v) {
          hmrAcceptRun(v[0], v[1]);
        });
      } else if (location.reload) {
        // `location` global exists in a web worker context but lacks `.reload()` function.
        location.reload();
      }
    }

    if (data.type === 'reload') {
      ws.close();

      ws.onclose = function () {
        location.reload();
      };
    }

    if (data.type === 'error-resolved') {
      console.log('[parcel]  Error resolved');
      removeErrorOverlay();
    }

    if (data.type === 'error') {
      console.error('[parcel]   ' + data.error.message + '\n' + data.error.stack);
      removeErrorOverlay();
      var overlay = createErrorOverlay(data);
      document.body.appendChild(overlay);
    }
  };
}

function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);

  if (overlay) {
    overlay.remove();
  }
}

function createErrorOverlay(data) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID; // html encode message and stack trace

  var message = document.createElement('div');
  var stackTrace = document.createElement('pre');
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;
  overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;"></span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>';
  return overlay;
}

function getParents(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return [];
  }

  var parents = [];
  var k, d, dep;

  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];

      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push(k);
      }
    }
  }

  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }

  return parents;
}

function hmrApply(bundle, asset) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (modules[asset.id] || !bundle.parent) {
    var fn = new Function('require', 'module', 'exports', asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}

function hmrAcceptCheck(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (!modules[id] && bundle.parent) {
    return hmrAcceptCheck(bundle.parent, id);
  }

  if (checkedAssets[id]) {
    return;
  }

  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }

  return getParents(global.parcelRequire, id).some(function (id) {
    return hmrAcceptCheck(global.parcelRequire, id);
  });
}

function hmrAcceptRun(bundle, id) {
  var cached = bundle.cache[id];
  bundle.hotData = {};

  if (cached) {
    cached.hot.data = bundle.hotData;
  }

  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }

  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      cb();
    });

    return true;
  }
}
},{}]},{},["../../../../.nvm/versions/node/v12.18.3/lib/node_modules/parcel-bundler/src/builtins/hmr-runtime.js","animation.js"], null)
//# sourceMappingURL=/animation.7bfd2d21.js.map